// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.33.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding
)]

// Section: imports

use crate::api::api_service::address_client::*;
use crate::api::api_service::bitcoin_address_client::*;
use crate::api::api_service::email_integration_client::*;
use crate::api::api_service::event_client::*;
use crate::api::api_service::exchange_rate_client::*;
use crate::api::api_service::invite_client::*;
use crate::api::api_service::onramp_gateway_client::*;
use crate::api::api_service::proton_api_service::*;
use crate::api::api_service::proton_contacts_client::*;
use crate::api::api_service::proton_email_addr_client::*;
use crate::api::api_service::proton_users_client::*;
use crate::api::api_service::settings_client::*;
use crate::api::api_service::transaction_client::*;
use crate::api::api_service::wallet_auth_store::*;
use crate::api::api_service::wallet_client::*;
use crate::api::bdk_wallet::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.33";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1263359491;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_add_one_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_one",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_left = <usize>::sse_decode(&mut deserializer);
            let api_right = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::api2::add_one(api_left, api_right))
                })())
            }
        },
    )
}
fn wire_add_three_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_three",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_left = <usize>::sse_decode(&mut deserializer);
            let api_right = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::api2::add_three(api_left, api_right))
                })())
            }
        },
    )
}
fn wire_greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                Result::<_, ()>::Ok(crate::api::api2::greet(api_name))
            })())
        },
    )
}
fn wire_helloworld_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "helloworld",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse((move || Result::<_, ()>::Ok(crate::api::api2::helloworld()))())
        },
    )
}
fn wire_init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || Result::<_, ()>::Ok(crate::api::api2::init_app()))())
            }
        },
    )
}
fn wire_AddressClient_get_address_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AddressClient_get_address_balance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_decode(&mut deserializer);
let api_address = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::address_client::AddressClient::get_address_balance(&api_that, api_address).await
                    })().await)
                } })
}
fn wire_AddressClient_get_scripthash_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AddressClient_get_scripthash_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_decode(&mut deserializer);
let api_script_hash = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::address_client::AddressClient::get_scripthash_transactions(&api_that, api_script_hash).await
                    })().await)
                } })
}
fn wire_AddressClient_get_scripthash_transactions_at_transaction_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AddressClient_get_scripthash_transactions_at_transaction_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_decode(&mut deserializer);
let api_script_hash = <String>::sse_decode(&mut deserializer);
let api_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::address_client::AddressClient::get_scripthash_transactions_at_transaction_id(&api_that, api_script_hash, api_transaction_id).await
                    })().await)
                } })
}
fn wire_AddressClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AddressClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::address_client::AddressClient::new(&api_service),
                    )
                })())
            }
        },
    )
}
fn wire_BitcoinAddressClient_add_bitcoin_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_add_bitcoin_addresses", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_bitcoin_addresses = <Vec<crate::proton_api::wallet::BitcoinAddress>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::add_bitcoin_addresses(&api_that, api_wallet_id, api_wallet_account_id, api_bitcoin_addresses).await
                    })().await)
                } })
}
fn wire_BitcoinAddressClient_get_bitcoin_address_latest_index_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_get_bitcoin_address_latest_index", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::get_bitcoin_address_latest_index(&api_that, api_wallet_id, api_wallet_account_id).await
                    })().await)
                } })
}
fn wire_BitcoinAddressClient_get_wallet_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_get_wallet_bitcoin_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_only_request = <Option<u8>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::get_wallet_bitcoin_address(&api_that, api_wallet_id, api_wallet_account_id, api_only_request).await
                    })().await)
                } })
}
fn wire_BitcoinAddressClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddressClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::new(
                            &api_service,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_BitcoinAddressClient_update_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_update_bitcoin_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_bitcoin_address_id = <String>::sse_decode(&mut deserializer);
let api_bitcoin_address = <crate::proton_api::wallet::BitcoinAddress>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::update_bitcoin_address(&api_that, api_wallet_id, api_wallet_account_id, api_wallet_account_bitcoin_address_id, api_bitcoin_address).await
                    })().await)
                } })
}
fn wire_EmailIntegrationClient_lookup_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EmailIntegrationClient_lookup_bitcoin_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>>>::sse_decode(&mut deserializer);
let api_email = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::email_integration_client::EmailIntegrationClient::lookup_bitcoin_address(&api_that, api_email).await
                    })().await)
                } })
}
fn wire_EmailIntegrationClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EmailIntegrationClient_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_service_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_service.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_service_decoded = Some(api_service.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_service = api_service_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::email_integration_client::EmailIntegrationClient::new(&api_service))
                    })())
                } })
}
fn wire_EventClient_collect_events_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventClient_collect_events", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>>::sse_decode(&mut deserializer);
let api_latest_event_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::event_client::EventClient::collect_events(&api_that, api_latest_event_id).await
                    })().await)
                } })
}
fn wire_EventClient_get_latest_event_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventClient_get_latest_event_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::event_client::EventClient::get_latest_event_id(&api_that).await
                    })().await)
                } })
}
fn wire_EventClient_is_valid_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventClient_is_valid_token", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::event_client::EventClient::is_valid_token(&api_that).await
                    })().await)
                } })
}
fn wire_EventClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(crate::api::api_service::event_client::EventClient::new(
                        &api_service,
                    ))
                })())
            }
        },
    )
}
fn wire_ExchangeRateClient_get_exchange_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ExchangeRateClient_get_exchange_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>>::sse_decode(&mut deserializer);
let api_fiat_currency = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
let api_time = <Option<u64>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::exchange_rate_client::ExchangeRateClient::get_exchange_rate(&api_that, api_fiat_currency, api_time).await
                    })().await)
                } })
}
fn wire_ExchangeRateClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ExchangeRateClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::exchange_rate_client::ExchangeRateClient::new(
                            &api_service,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_InviteClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "InviteClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(crate::api::api_service::invite_client::InviteClient::new(
                        &api_service,
                    ))
                })())
            }
        },
    )
}
fn wire_InviteClient_send_email_integration_invite_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "InviteClient_send_email_integration_invite", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_decode(&mut deserializer);
let api_invitee_email = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::invite_client::InviteClient::send_email_integration_invite(&api_that, api_invitee_email).await
                    })().await)
                } })
}
fn wire_InviteClient_send_newcomer_invite_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "InviteClient_send_newcomer_invite", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_decode(&mut deserializer);
let api_invitee_email = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::invite_client::InviteClient::send_newcomer_invite(&api_that, api_invitee_email).await
                    })().await)
                } })
}
fn wire_OnRampGatewayClient_create_on_ramp_checkout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_create_on_ramp_checkout", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_amount = <String>::sse_decode(&mut deserializer);
let api_btc_address = <String>::sse_decode(&mut deserializer);
let api_fiat_currency = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
let api_pay_method = <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(&mut deserializer);
let api_provider = <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::create_on_ramp_checkout(&api_that, api_amount, api_btc_address, api_fiat_currency, api_pay_method, api_provider).await
                    })().await)
                } })
}
fn wire_OnRampGatewayClient_get_countries_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_countries", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_countries(&api_that).await
                    })().await)
                } })
}
fn wire_OnRampGatewayClient_get_fiat_currencies_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_fiat_currencies", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_fiat_currencies(&api_that).await
                    })().await)
                } })
}
fn wire_OnRampGatewayClient_get_payment_methods_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_payment_methods", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_fiat_symbol = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_payment_methods(&api_that, api_fiat_symbol).await
                    })().await)
                } })
}
fn wire_OnRampGatewayClient_get_quotes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_quotes", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_amount = <String>::sse_decode(&mut deserializer);
let api_fiat_currency = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
let api_pay_method = <Option<crate::proton_api::payment_gateway::PaymentMethod>>::sse_decode(&mut deserializer);
let api_provider = <Option<crate::proton_api::payment_gateway::GatewayProvider>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_quotes(&api_that, api_amount, api_fiat_currency, api_pay_method, api_provider).await
                    })().await)
                } })
}
fn wire_OnRampGatewayClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnRampGatewayClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::new(
                            &api_service,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_ProtonApiService_get_address_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_address_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_address_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_bitcoin_addr_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_bitcoin_addr_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_bitcoin_addr_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_email_integration_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_email_integration_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_email_integration_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_event_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_get_event_client",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![api_that.rust_auto_opaque_lock_order_info(0, false)],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(
                    crate::api::api_service::proton_api_service::ProtonAPIService::get_event_client(
                        &api_that,
                    ),
                )
            })())
        },
    )
}
fn wire_ProtonApiService_get_exchange_rate_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_exchange_rate_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_exchange_rate_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_invite_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_invite_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_invite_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_on_ramp_gateway_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_on_ramp_gateway_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_on_ramp_gateway_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_proton_contacts_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_proton_contacts_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_proton_contacts_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_proton_email_addr_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_proton_email_addr_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_proton_email_addr_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_settings_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_settings_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_settings_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_transaction_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_transaction_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_transaction_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_wallet_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_wallet_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_wallet_client(&api_that))
                })()) })
}
fn wire_ProtonApiService_get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_wallets", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::proton_api_service::ProtonAPIService::get_wallets(&api_that).await
                    })().await)
                } })
}
fn wire_ProtonApiService_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_login", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);
let api_username = <String>::sse_decode(&mut deserializer);
let api_password = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::proton_api_service::ProtonAPIService::login(&api_that, api_username, api_password).await
                    })().await)
                } })
}
fn wire_ProtonApiService_logout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_logout", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::logout(&mut api_that).await)
                    })().await)
                } })
}
fn wire_ProtonApiService_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_env = <String>::sse_decode(&mut deserializer);
            let api_app_version = <String>::sse_decode(&mut deserializer);
            let api_user_agent = <String>::sse_decode(&mut deserializer);
            let api_store = <ProtonWalletAuthStore>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                crate::api::api_service::proton_api_service::ProtonAPIService::new(
                    api_env,
                    api_app_version,
                    api_user_agent,
                    api_store,
                )
            })())
        },
    )
}
fn wire_ProtonApiService_set_proton_api_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_set_proton_api", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref_mut()),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::set_proton_api(&mut api_that))
                    })())
                } })
}
fn wire_ProtonApiService_update_auth_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_update_auth", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);
let api_uid = <String>::sse_decode(&mut deserializer);
let api_access = <String>::sse_decode(&mut deserializer);
let api_refresh = <String>::sse_decode(&mut deserializer);
let api_scopes = <Vec<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::update_auth(&mut api_that, api_uid, api_access, api_refresh, api_scopes).await)
                    })().await)
                } })
}
fn wire_ContactsClient_get_contacts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ContactsClient_get_contacts", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::proton_contacts_client::ContactsClient::get_contacts(&api_that).await
                    })().await)
                } })
}
fn wire_ContactsClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ContactsClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::proton_contacts_client::ContactsClient::new(
                            &api_service,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_ProtonEmailAddressClient_get_all_public_keys_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonEmailAddressClient_get_all_public_keys", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>>>::sse_decode(&mut deserializer);
let api_email = <String>::sse_decode(&mut deserializer);
let api_internal_only = <u8>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::proton_email_addr_client::ProtonEmailAddressClient::get_all_public_keys(&api_that, api_email, api_internal_only).await
                    })().await)
                } })
}
fn wire_ProtonEmailAddressClient_get_proton_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonEmailAddressClient_get_proton_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::proton_email_addr_client::ProtonEmailAddressClient::get_proton_address(&api_that).await
                    })().await)
                } })
}
fn wire_ProtonEmailAddressClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonEmailAddressClient_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_service_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_service.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_service_decoded = Some(api_service.rust_auto_opaque_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_service = api_service_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::proton_email_addr_client::ProtonEmailAddressClient::new(&api_service))
                    })())
                } })
}
fn wire_ProtonUsersClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonUsersClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <Arc<ProtonAPIService>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(
                        crate::api::api_service::proton_users_client::ProtonUsersClient::new(
                            api_client,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_SettingsClient_bitcoin_unit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_bitcoin_unit", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_symbol = <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::settings_client::SettingsClient::bitcoin_unit(&api_that, api_symbol).await
                    })().await)
                } })
}
fn wire_SettingsClient_fiat_currency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_fiat_currency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_symbol = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::settings_client::SettingsClient::fiat_currency(&api_that, api_symbol).await
                    })().await)
                } })
}
fn wire_SettingsClient_get_user_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_get_user_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::settings_client::SettingsClient::get_user_settings(&api_that).await
                    })().await)
                } })
}
fn wire_SettingsClient_hide_empty_used_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_hide_empty_used_addresses", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_hide_empty_used_addresses = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::settings_client::SettingsClient::hide_empty_used_addresses(&api_that, api_hide_empty_used_addresses).await
                    })().await)
                } })
}
fn wire_SettingsClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SettingsClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::settings_client::SettingsClient::new(&api_service),
                    )
                })())
            }
        },
    )
}
fn wire_SettingsClient_two_fa_threshold_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_two_fa_threshold", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_amount = <u64>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::settings_client::SettingsClient::two_fa_threshold(&api_that, api_amount).await
                    })().await)
                } })
}
fn wire_TransactionClient_broadcast_raw_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "TransactionClient_broadcast_raw_transaction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>>::sse_decode(&mut deserializer);
let api_signed_transaction_hex = <String>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_label = <Option<String>>::sse_decode(&mut deserializer);
let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);
let api_address_id = <Option<String>>::sse_decode(&mut deserializer);
let api_subject = <Option<String>>::sse_decode(&mut deserializer);
let api_body = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::transaction_client::TransactionClient::broadcast_raw_transaction(&api_that, api_signed_transaction_hex, api_wallet_id, api_wallet_account_id, api_label, api_exchange_rate_id, api_transaction_time, api_address_id, api_subject, api_body).await
                    })().await)
                } })
}
fn wire_TransactionClient_get_raw_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "TransactionClient_get_raw_transaction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>>::sse_decode(&mut deserializer);
let api_txid = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::transaction_client::TransactionClient::get_raw_transaction(&api_that, api_txid).await
                    })().await)
                } })
}
fn wire_TransactionClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TransactionClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(
                        crate::api::api_service::transaction_client::TransactionClient::new(
                            &api_service,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_ProtonWalletAuthStore_clear_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_clear_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::clear_auth_dart_callback(&api_that).await
                    })().await)
                } })
}
fn wire_ProtonWalletAuthStore_from_session_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonWalletAuthStore_from_session",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_env = <String>::sse_decode(&mut deserializer);
            let api_uid = <String>::sse_decode(&mut deserializer);
            let api_access = <String>::sse_decode(&mut deserializer);
            let api_refresh = <String>::sse_decode(&mut deserializer);
            let api_scopes = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::from_session(
                    &api_env,
                    api_uid,
                    api_access,
                    api_refresh,
                    api_scopes,
                )
            })())
        },
    )
}
fn wire_ProtonWalletAuthStore_logout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_logout", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::logout(&mut api_that).await)
                    })().await)
                } })
}
fn wire_ProtonWalletAuthStore_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonWalletAuthStore_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_env = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::new(&api_env)
            })())
        },
    )
}
fn wire_ProtonWalletAuthStore_set_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_set_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs_child_session_Output_String(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::set_auth_dart_callback(&mut api_that, api_callback).await
                    })().await)
                } })
}
fn wire_ProtonWalletAuthStore_set_auth_sync_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonWalletAuthStore_set_auth_sync",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
            >>::sse_decode(&mut deserializer);
            let api_uid = <String>::sse_decode(&mut deserializer);
            let api_access = <String>::sse_decode(&mut deserializer);
            let api_refresh = <String>::sse_decode(&mut deserializer);
            let api_scopes = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![api_that.rust_auto_opaque_lock_order_info(0, true)],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => {
                            api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref_mut())
                        }
                        _ => unreachable!(),
                    }
                }
                let mut api_that = api_that_decoded.unwrap();
                crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::set_auth_sync(
                    &mut api_that,
                    api_uid,
                    api_access,
                    api_refresh,
                    api_scopes,
                )
            })())
        },
    )
}
fn wire_WalletClient_add_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_add_email_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::add_email_address(&api_that, api_wallet_id, api_wallet_account_id, api_address_id).await
                    })().await)
                } })
}
fn wire_WalletClient_create_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_create_wallet", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_req = <crate::proton_api::wallet::CreateWalletReq>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::create_wallet(&api_that, api_wallet_req).await
                    })().await)
                } })
}
fn wire_WalletClient_create_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_create_wallet_account", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_req = <crate::proton_api::wallet_account::CreateWalletAccountReq>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::create_wallet_account(&api_that, api_wallet_id, api_req).await
                    })().await)
                } })
}
fn wire_WalletClient_create_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_create_wallet_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_transaction_id = <String>::sse_decode(&mut deserializer);
let api_hashed_transaction_id = <String>::sse_decode(&mut deserializer);
let api_label = <Option<String>>::sse_decode(&mut deserializer);
let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::create_wallet_transactions(&api_that, api_wallet_id, api_wallet_account_id, api_transaction_id, api_hashed_transaction_id, api_label, api_exchange_rate_id, api_transaction_time).await
                    })().await)
                } })
}
fn wire_WalletClient_delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::delete_wallet(&api_that, api_wallet_id).await
                    })().await)
                } })
}
fn wire_WalletClient_delete_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet_account", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::delete_wallet_account(&api_that, api_wallet_id, api_wallet_account_id).await
                    })().await)
                } })
}
fn wire_WalletClient_delete_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::delete_wallet_transactions(&api_that, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id).await
                    })().await)
                } })
}
fn wire_WalletClient_get_wallet_accounts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_get_wallet_accounts", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::get_wallet_accounts(&api_that, api_wallet_id).await
                    })().await)
                } })
}
fn wire_WalletClient_get_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_get_wallet_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <Option<String>>::sse_decode(&mut deserializer);
let api_hashed_txids = <Option<Vec<String>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::get_wallet_transactions(&api_that, api_wallet_id, api_wallet_account_id, api_hashed_txids).await
                    })().await)
                } })
}
fn wire_WalletClient_get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_get_wallets", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::get_wallets(&api_that).await
                    })().await)
                } })
}
fn wire_WalletClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "WalletClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    let mut api_service_decoded = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                            vec![api_service.rust_auto_opaque_lock_order_info(0, false)],
                        );
                    for i in decode_indices_ {
                        match i {
                            0 => {
                                api_service_decoded =
                                    Some(api_service.rust_auto_opaque_decode_sync_ref())
                            }
                            _ => unreachable!(),
                        }
                    }
                    let api_service = api_service_decoded.unwrap();
                    Result::<_, ()>::Ok(crate::api::api_service::wallet_client::WalletClient::new(
                        &api_service,
                    ))
                })())
            }
        },
    )
}
fn wire_WalletClient_remove_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_remove_email_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::remove_email_address(&api_that, api_wallet_id, api_wallet_account_id, api_address_id).await
                    })().await)
                } })
}
fn wire_WalletClient_update_wallet_account_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_account_label", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_new_label = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::update_wallet_account_label(&api_that, api_wallet_id, api_wallet_account_id, api_new_label).await
                    })().await)
                } })
}
fn wire_WalletClient_update_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_name", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_new_name = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::update_wallet_name(&api_that, api_wallet_id, api_new_name).await
                    })().await)
                } })
}
fn wire_WalletClient_update_wallet_transaction_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_transaction_label", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);
let api_label = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![api_that.rust_auto_opaque_lock_order_info(0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::api_service::wallet_client::WalletClient::update_wallet_transaction_label(&api_that, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id, api_label).await
                    })().await)
                } })
}
fn wire_BdkWalletManager_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BdkWalletManager_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BdkWalletManager>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![api_that.rust_auto_opaque_lock_order_info(0, false)],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(api_that.rust_auto_opaque_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(crate::api::bdk_wallet::BdkWalletManager::fingerprint(
                    &api_that,
                ))
            })())
        },
    )
}
fn wire_BdkWalletManager_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BdkWalletManager_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_bip39_mnemonic = <String>::sse_decode(&mut deserializer);
            let api_bip38_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::bdk_wallet::BdkWalletManager::new(
                        api_network,
                        api_bip39_mnemonic,
                        api_bip38_passphrase,
                    )
                })())
            }
        },
    )
}
fn wire_info_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "info_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::flutter_logger::LogEntry,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::flutter_logger::info_logger(api_sink))
                })())
            }
        },
    )
}
fn wire_panic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "panic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::flutter_logger::panic())
                })())
            }
        },
    )
}
fn wire_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_i = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::flutter_logger::test(api_i))
                })())
            }
        },
    )
}
fn wire_add_two_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_two",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_left = <usize>::sse_decode(&mut deserializer);
            let api_right = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::ldk_api::add_two(api_left, api_right))
                })())
            }
        },
    )
}
fn wire_test_one_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "test_one",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::ldk_api::test_one())
                })())
            }
        },
    )
}
fn wire_add_bitcoin_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_bitcoin_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_bitcoin_addresses =
                <Vec<crate::proton_api::wallet::BitcoinAddress>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::add_bitcoin_addresses(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_bitcoin_addresses,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_add_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_email_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_address_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::add_email_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_address_id,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_bitcoin_unit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bitcoin_unit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_symbol =
                <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::proton_api::bitcoin_unit(api_symbol).await
                    })().await)
            }
        },
    )
}
fn wire_broadcast_raw_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "broadcast_raw_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signed_transaction_hex = <String>::sse_decode(&mut deserializer);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_label = <Option<String>>::sse_decode(&mut deserializer);
            let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
            let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);
            let api_address_id = <Option<String>>::sse_decode(&mut deserializer);
            let api_subject = <Option<String>>::sse_decode(&mut deserializer);
            let api_body = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::broadcast_raw_transaction(
                            api_signed_transaction_hex,
                            api_wallet_id,
                            api_wallet_account_id,
                            api_label,
                            api_exchange_rate_id,
                            api_transaction_time,
                            api_address_id,
                            api_subject,
                            api_body,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_collect_events_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "collect_events",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_latest_event_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::collect_events(api_latest_event_id).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_create_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_req =
                <crate::proton_api::wallet::CreateWalletReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::proton_api::create_wallet(api_wallet_req).await
                    })().await)
            }
        },
    )
}
fn wire_create_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_wallet_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_req = <crate::proton_api::wallet_account::CreateWalletAccountReq>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::create_wallet_account(api_wallet_id, api_req).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_create_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_wallet_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_transaction_id = <String>::sse_decode(&mut deserializer);
            let api_hashed_transaction_id = <String>::sse_decode(&mut deserializer);
            let api_label = <Option<String>>::sse_decode(&mut deserializer);
            let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
            let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::create_wallet_transactions(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_transaction_id,
                            api_hashed_transaction_id,
                            api_label,
                            api_exchange_rate_id,
                            api_transaction_time,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::proton_api::delete_wallet(api_wallet_id).await
                    })().await)
            }
        },
    )
}
fn wire_delete_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::delete_wallet_account(
                            api_wallet_id,
                            api_wallet_account_id,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_delete_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::delete_wallet_transactions(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_wallet_transaction_id,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_fiat_currency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fiat_currency",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_symbol =
                <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::proton_api::fiat_currency(api_symbol).await
                    })().await)
            }
        },
    )
}
fn wire_fork_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fork",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::fork().await })().await,
                )
            }
        },
    )
}
fn wire_get_all_public_keys_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_all_public_keys",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_email = <String>::sse_decode(&mut deserializer);
            let api_internal_only = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::get_all_public_keys(api_email, api_internal_only)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_get_bitcoin_address_latest_index_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_bitcoin_address_latest_index",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::get_bitcoin_address_latest_index(
                            api_wallet_id,
                            api_wallet_account_id,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_get_contacts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_contacts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::get_contacts().await })().await,
                )
            }
        },
    )
}
fn wire_get_exchange_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_exchange_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_fiat_currency =
                <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
            let api_time = <Option<u64>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::get_exchange_rate(api_fiat_currency, api_time).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_get_latest_event_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_latest_event_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::get_latest_event_id().await })()
                        .await,
                )
            }
        },
    )
}
fn wire_get_proton_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_proton_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::get_proton_address().await })()
                        .await,
                )
            }
        },
    )
}
fn wire_get_user_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_user_settings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::get_user_settings().await })()
                        .await,
                )
            }
        },
    )
}
fn wire_get_wallet_accounts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallet_accounts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::get_wallet_accounts(api_wallet_id).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_get_wallet_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallet_bitcoin_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_only_request = <Option<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::get_wallet_bitcoin_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_only_request,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_get_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallet_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <Option<String>>::sse_decode(&mut deserializer);
            let api_hashed_txids = <Option<Vec<String>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::get_wallet_transactions(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_hashed_txids,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::get_wallets().await })().await,
                )
            }
        },
    )
}
fn wire_hide_empty_used_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "hide_empty_used_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_hide_empty_used_addresses = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::hide_empty_used_addresses(
                            api_hide_empty_used_addresses,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_is_valid_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_valid_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move { crate::api::proton_api::is_valid_token().await })().await,
                )
            }
        },
    )
}
fn wire_lookup_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lookup_bitcoin_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_email = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::lookup_bitcoin_address(api_email).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_remove_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_email_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_address_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::remove_email_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_address_id,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_two_fa_threshold_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "two_fa_threshold",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_amount = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::proton_api::two_fa_threshold(api_amount).await
                    })().await)
            }
        },
    )
}
fn wire_update_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_bitcoin_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_bitcoin_address_id = <String>::sse_decode(&mut deserializer);
            let api_bitcoin_address =
                <crate::proton_api::wallet::BitcoinAddress>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::update_bitcoin_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_wallet_account_bitcoin_address_id,
                            api_bitcoin_address,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_update_wallet_account_fiat_currency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_wallet_account_fiat_currency",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_new_fiat_currency =
                <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::update_wallet_account_fiat_currency(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_new_fiat_currency,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_update_wallet_account_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_wallet_account_label",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_new_label = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::update_wallet_account_label(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_new_label,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_update_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_wallet_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::update_wallet_name(api_wallet_id, api_new_name)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_update_wallet_transaction_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_wallet_transaction_label",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);
            let api_label = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::proton_api::update_wallet_transaction_label(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_wallet_transaction_id,
                            api_label,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_address_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_address_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_script = <crate::bdk::types::Script>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::address_from_script(api_script, api_network)
                })())
            }
        },
    )
}
fn wire_api_address_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_address_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::address_network(api_address)
                })())
            }
        },
    )
}
fn wire_api_address_to_script_pubkey_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_address_to_script_pubkey",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::address_to_script_pubkey(api_address)
                })())
            }
        },
    )
}
fn wire_api_broadcast_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_broadcast",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            let api_blockchain_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::broadcast(api_tx, api_blockchain_id)
                })())
            }
        },
    )
}
fn wire_api_bump_fee_tx_builder_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_bump_fee_tx_builder_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_txid = <String>::sse_decode(&mut deserializer);
            let api_fee_rate = <f32>::sse_decode(&mut deserializer);
            let api_allow_shrinking = <Option<String>>::sse_decode(&mut deserializer);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_enable_rbf = <bool>::sse_decode(&mut deserializer);
            let api_n_sequence = <Option<u32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::bump_fee_tx_builder_finish(
                        api_txid,
                        api_fee_rate,
                        api_allow_shrinking,
                        api_wallet_id,
                        api_enable_rbf,
                        api_n_sequence,
                    )
                })())
            }
        },
    )
}
fn wire_api_combine_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_combine_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            let api_other = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::combine_psbt(api_psbt_str, api_other).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_create_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::create_address(api_address)
                })())
            }
        },
    )
}
fn wire_api_create_derivation_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_derivation_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::create_derivation_path(api_path).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_create_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::create_descriptor(api_descriptor, api_network)
                })())
            }
        },
    )
}
fn wire_api_create_descriptor_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_descriptor_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_xpub = <Option<String>>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            let api_derive = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::create_descriptor_public(
                            api_xpub, api_path, api_derive,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_create_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_mnemonic = <String>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::create_descriptor_secret(
                            api_network,
                            api_mnemonic,
                            api_password,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_create_esplora_blockchain_with_api_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_esplora_blockchain_with_api",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_config = <crate::bdk::blockchain::EsploraConfig>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::create_esplora_blockchain_with_api(api_config)
                })())
            }
        },
    )
}
fn wire_api_create_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::create_transaction(api_tx)
                })())
            }
        },
    )
}
fn wire_api_create_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <String>::sse_decode(&mut deserializer);
            let api_change_descriptor = <Option<String>>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_database_config =
                <crate::bdk::wallet::DatabaseConfig>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::create_wallet(
                        api_descriptor,
                        api_change_descriptor,
                        api_network,
                        api_database_config,
                    )
                })())
            }
        },
    )
}
fn wire_api_derive_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_derive_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        Result::<_, ()>::Ok(
                            crate::api::rust_api::Api::derive_descriptor_secret(
                                api_secret, api_path,
                            )
                            .await,
                        )
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_descriptor_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::descriptor_as_string(api_descriptor, api_network)
                })())
            }
        },
    )
}
fn wire_api_descriptor_as_string_private_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_as_string_private",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::descriptor_as_string_private(
                        api_descriptor,
                        api_network,
                    )
                })())
            }
        },
    )
}
fn wire_api_descriptor_public_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_public_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::descriptor_public_from_string(api_public_key)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_descriptor_secret_as_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_secret_as_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::descriptor_secret_as_public(api_secret).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_descriptor_secret_as_secret_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_secret_as_secret_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::descriptor_secret_as_secret_bytes(api_secret)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_descriptor_secret_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_secret_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::descriptor_secret_from_string(api_secret).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_estimate_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_estimate_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_target = <u64>::sse_decode(&mut deserializer);
            let api_blockchain_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::estimate_fee(api_target, api_blockchain_id)
                })())
            }
        },
    )
}
fn wire_api_extend_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_extend_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        Result::<_, ()>::Ok(
                            crate::api::rust_api::Api::extend_descriptor_secret(
                                api_secret, api_path,
                            )
                            .await,
                        )
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_extract_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_extract_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::rust_api::Api::extract_tx(api_psbt_str).await
                    })().await)
            }
        },
    )
}
fn wire_api_generate_seed_from_entropy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_generate_seed_from_entropy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entropy = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::generate_seed_from_entropy(api_entropy)
                })())
            }
        },
    )
}
fn wire_api_generate_seed_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_generate_seed_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mnemonic = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::generate_seed_from_string(api_mnemonic)
                })())
            }
        },
    )
}
fn wire_api_generate_seed_from_word_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_generate_seed_from_word_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_word_count = <crate::bdk::types::WordCount>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::generate_seed_from_word_count(
                        api_word_count,
                    ))
                })())
            }
        },
    )
}
fn wire_api_get_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_address_index =
                <crate::bdk::types::AddressIndex>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_address(api_wallet_id, api_address_index)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::rust_api::Api::get_balance(api_wallet_id).await
                    })().await)
            }
        },
    )
}
fn wire_api_get_blockchain_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_blockchain_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_blockchain_height = <u32>::sse_decode(&mut deserializer);
            let api_blockchain_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_blockchain_hash(
                            api_blockchain_height,
                            api_blockchain_id,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_get_descriptor_for_keychain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_descriptor_for_keychain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_keychain = <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_descriptor_for_keychain(
                            api_wallet_id,
                            api_keychain,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_get_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_blockchain_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_height(api_blockchain_id).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_get_internal_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_internal_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_address_index =
                <crate::bdk::types::AddressIndex>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_internal_address(
                            api_wallet_id,
                            api_address_index,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_get_psbt_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_psbt_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_utxo = <crate::bdk::wallet::LocalUtxo>::sse_decode(&mut deserializer);
            let api_only_witness_utxo = <bool>::sse_decode(&mut deserializer);
            let api_psbt_sighash_type =
                <Option<crate::bdk::types::PsbtSigHashType>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_psbt_input(
                            api_wallet_id,
                            api_utxo,
                            api_only_witness_utxo,
                            api_psbt_sighash_type,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_get_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_include_raw = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::get_transactions(api_wallet_id, api_include_raw)
                            .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::input(api_tx))
                })())
            }
        },
    )
}
fn wire_api_is_coin_base_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_coin_base",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::is_coin_base(api_tx))
                })())
            }
        },
    )
}
fn wire_api_is_explicitly_rbf_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_explicitly_rbf",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::is_explicitly_rbf(api_tx))
                })())
            }
        },
    )
}
fn wire_api_is_lock_time_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_lock_time_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::is_lock_time_enabled(api_tx))
                })())
            }
        },
    )
}
fn wire_api_is_mine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_mine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_script = <crate::bdk::types::Script>::sse_decode(&mut deserializer);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::is_mine(api_script, api_wallet_id).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_json_serialize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_json_serialize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::json_serialize(api_psbt_str).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_list_unspent_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_list_unspent",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::list_unspent(api_wallet_id).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_list_unspent_outputs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_list_unspent_outputs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::list_unspent_outputs(api_wallet_id).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_lock_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_lock_time",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::lock_time(api_tx))
                })())
            }
        },
    )
}
fn wire_api_max_satisfaction_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_max_satisfaction_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::max_satisfaction_weight(api_descriptor, api_network)
                })())
            }
        },
    )
}
fn wire_api_new_bip44_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip44_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::new_bip44_descriptor(
                            api_key_chain_kind,
                            api_secret_key,
                            api_network,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_new_bip44_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip44_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::new_bip44_public(
                            api_key_chain_kind,
                            api_public_key,
                            api_network,
                            api_fingerprint,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_new_bip49_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip49_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::new_bip49_descriptor(
                            api_key_chain_kind,
                            api_secret_key,
                            api_network,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_new_bip49_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip49_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::new_bip49_public(
                            api_key_chain_kind,
                            api_public_key,
                            api_network,
                            api_fingerprint,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_new_bip84_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip84_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::new_bip84_descriptor(
                            api_key_chain_kind,
                            api_secret_key,
                            api_network,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_new_bip84_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip84_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::new_bip84_public(
                            api_key_chain_kind,
                            api_public_key,
                            api_network,
                            api_fingerprint,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_output",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::output(api_tx))
                })())
            }
        },
    )
}
fn wire_api_psbt_fee_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_psbt_fee_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        Result::<_, ()>::Ok(
                            crate::api::rust_api::Api::psbt_fee_amount(api_psbt_str).await,
                        )
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_psbt_fee_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_psbt_fee_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        Result::<_, ()>::Ok(
                            crate::api::rust_api::Api::psbt_fee_rate(api_psbt_str).await,
                        )
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_psbt_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_psbt_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse((move || async move {
                         crate::api::rust_api::Api::psbt_txid(api_psbt_str).await
                    })().await)
            }
        },
    )
}
fn wire_api_serialize_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_serialize_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::serialize_psbt(api_psbt_str).await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            let api_sign_options =
                <Option<crate::bdk::wallet::SignOptions>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::rust_api::Api::sign(
                            api_wallet_id,
                            api_psbt_str,
                            api_sign_options,
                        )
                        .await
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::size(api_tx))
                })())
            }
        },
    )
}
fn wire_api_sync_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_sync_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_blockchain_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::sync_wallet(
                        api_wallet_id,
                        api_blockchain_id,
                    ))
                })())
            }
        },
    )
}
fn wire_api_tx_builder_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_tx_builder_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_recipients =
                <Vec<crate::bdk::types::ScriptAmount>>::sse_decode(&mut deserializer);
            let api_utxos = <Vec<crate::bdk::types::OutPoint>>::sse_decode(&mut deserializer);
            let api_foreign_utxo =
                <Option<(crate::bdk::types::OutPoint, String, usize)>>::sse_decode(
                    &mut deserializer,
                );
            let api_unspendable = <Vec<crate::bdk::types::OutPoint>>::sse_decode(&mut deserializer);
            let api_change_policy =
                <crate::bdk::types::ChangeSpendPolicy>::sse_decode(&mut deserializer);
            let api_manually_selected_only = <bool>::sse_decode(&mut deserializer);
            let api_fee_rate = <Option<f32>>::sse_decode(&mut deserializer);
            let api_fee_absolute = <Option<u64>>::sse_decode(&mut deserializer);
            let api_drain_wallet = <bool>::sse_decode(&mut deserializer);
            let api_drain_to = <Option<crate::bdk::types::Script>>::sse_decode(&mut deserializer);
            let api_rbf = <Option<crate::bdk::types::RbfValue>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    crate::api::rust_api::Api::tx_builder_finish(
                        api_wallet_id,
                        api_recipients,
                        api_utxos,
                        api_foreign_utxo,
                        api_unspendable,
                        api_change_policy,
                        api_manually_selected_only,
                        api_fee_rate,
                        api_fee_absolute,
                        api_drain_wallet,
                        api_drain_to,
                        api_rbf,
                        api_data,
                    )
                })())
            }
        },
    )
}
fn wire_api_tx_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_tx_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || crate::api::rust_api::Api::tx_txid(api_tx))())
            }
        },
    )
}
fn wire_api_version_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_version",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::version(api_tx))
                })())
            }
        },
    )
}
fn wire_api_vsize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_vsize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::vsize(api_tx))
                })())
            }
        },
    )
}
fn wire_api_wallet_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_wallet_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        Result::<_, ()>::Ok(
                            crate::api::rust_api::Api::wallet_network(api_wallet_id).await,
                        )
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_api_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_api::Api::weight(api_tx))
                })())
            }
        },
    )
}
fn wire_my_test_object_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "my_test_object_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_objects::MyTestObject::new())
                })())
            }
        },
    )
}
fn wire_my_test_object_read_text_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "my_test_object_read_text",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::rust_objects::MyTestObject>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(crate::api::rust_objects::MyTestObject::read_text(
                        &api_that,
                    ))
                })())
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let ApiContactEmails = None::<crate::proton_api::contacts::ApiContactEmails>.unwrap();
        let _: String = ApiContactEmails.ID;
        let _: String = ApiContactEmails.Name;
        let _: String = ApiContactEmails.Email;
        let _: String = ApiContactEmails.CanonicalEmail;
        let _: u32 = ApiContactEmails.IsProton;
    }
    {
        let ApiCountry = None::<crate::proton_api::payment_gateway::ApiCountry>.unwrap();
        let _: String = ApiCountry.Code;
        let _: String = ApiCountry.FiatCurrency;
        let _: String = ApiCountry.Name;
    }
    {
        let ApiCountryFiatCurrency =
            None::<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>.unwrap();
        let _: String = ApiCountryFiatCurrency.Name;
        let _: String = ApiCountryFiatCurrency.Symbol;
    }
    {
        let ApiEmailAddress = None::<crate::proton_api::wallet_account::ApiEmailAddress>.unwrap();
        let _: String = ApiEmailAddress.ID;
        let _: String = ApiEmailAddress.Email;
    }
    {
        let ApiWallet = None::<crate::proton_api::wallet::ApiWallet>.unwrap();
        let _: String = ApiWallet.ID;
        let _: String = ApiWallet.Name;
        let _: u8 = ApiWallet.IsImported;
        let _: u8 = ApiWallet.Priority;
        let _: u8 = ApiWallet.Type;
        let _: u8 = ApiWallet.HasPassphrase;
        let _: u8 = ApiWallet.Status;
        let _: Option<String> = ApiWallet.Mnemonic;
        let _: Option<String> = ApiWallet.Fingerprint;
        let _: Option<String> = ApiWallet.PublicKey;
    }
    {
        let ApiWalletAccount = None::<crate::proton_api::wallet_account::ApiWalletAccount>.unwrap();
        let _: String = ApiWalletAccount.ID;
        let _: String = ApiWalletAccount.WalletID;
        let _: crate::proton_api::user_settings::FiatCurrency = ApiWalletAccount.FiatCurrency;
        let _: String = ApiWalletAccount.DerivationPath;
        let _: String = ApiWalletAccount.Label;
        let _: u8 = ApiWalletAccount.ScriptType;
        let _: Vec<crate::proton_api::wallet_account::ApiEmailAddress> = ApiWalletAccount.Addresses;
    }
    {
        let ApiWalletBitcoinAddress =
            None::<crate::proton_api::wallet::ApiWalletBitcoinAddress>.unwrap();
        let _: String = ApiWalletBitcoinAddress.ID;
        let _: String = ApiWalletBitcoinAddress.WalletID;
        let _: String = ApiWalletBitcoinAddress.WalletAccountID;
        let _: u8 = ApiWalletBitcoinAddress.Fetched;
        let _: u8 = ApiWalletBitcoinAddress.Used;
        let _: Option<String> = ApiWalletBitcoinAddress.BitcoinAddress;
        let _: Option<String> = ApiWalletBitcoinAddress.BitcoinAddressSignature;
        let _: Option<u64> = ApiWalletBitcoinAddress.BitcoinAddressIndex;
    }
    {
        let ApiWalletData = None::<crate::proton_api::wallet::ApiWalletData>.unwrap();
        let _: crate::proton_api::wallet::ApiWallet = ApiWalletData.Wallet;
        let _: crate::proton_api::wallet::ApiWalletKey = ApiWalletData.WalletKey;
        let _: crate::proton_api::wallet_settings::ApiWalletSettings = ApiWalletData.WalletSettings;
    }
    {
        let ApiWalletKey = None::<crate::proton_api::wallet::ApiWalletKey>.unwrap();
        let _: String = ApiWalletKey.WalletID;
        let _: String = ApiWalletKey.UserKeyID;
        let _: String = ApiWalletKey.WalletKey;
        let _: String = ApiWalletKey.WalletKeySignature;
    }
    {
        let ApiWalletSettings =
            None::<crate::proton_api::wallet_settings::ApiWalletSettings>.unwrap();
        let _: String = ApiWalletSettings.WalletID;
        let _: u8 = ApiWalletSettings.HideAccounts;
        let _: Option<String> = ApiWalletSettings.InvoiceDefaultDescription;
        let _: u64 = ApiWalletSettings.InvoiceExpirationTime;
        let _: u64 = ApiWalletSettings.MaxChannelOpeningFee;
    }
    {
        let ApiWalletUserSettings =
            None::<crate::proton_api::user_settings::ApiWalletUserSettings>.unwrap();
        let _: crate::proton_api::user_settings::BitcoinUnit = ApiWalletUserSettings.BitcoinUnit;
        let _: crate::proton_api::user_settings::FiatCurrency = ApiWalletUserSettings.FiatCurrency;
        let _: u8 = ApiWalletUserSettings.HideEmptyUsedAddresses;
        let _: u8 = ApiWalletUserSettings.ShowWalletRecovery;
        let _: Option<u64> = ApiWalletUserSettings.TwoFactorAmountThreshold;
    }
    {
        let ChildSession = None::<crate::proton_api::auth_credential::ChildSession>.unwrap();
        let _: String = ChildSession.session_id;
        let _: String = ChildSession.access_token;
        let _: String = ChildSession.refresh_token;
        let _: Vec<String> = ChildSession.scopes;
    }
    {
        let LogEntry = None::<crate::api::flutter_logger::LogEntry>.unwrap();
        let _: i64 = LogEntry.time_millis;
        let _: String = LogEntry.msg;
        let _: crate::api::flutter_logger::Level = LogEntry.log_level;
        let _: String = LogEntry.lbl;
    }
    {
        let Quote = None::<crate::proton_api::payment_gateway::Quote>.unwrap();
        let _: String = Quote.BitcoinAmount;
        let _: String = Quote.FiatAmount;
        let _: crate::proton_api::user_settings::FiatCurrency = Quote.FiatCurrencySymbol;
        let _: String = Quote.NetworkFee;
        let _: String = Quote.PaymentGatewayFee;
        let _: crate::proton_api::payment_gateway::PaymentMethod = Quote.PaymentMethod;
    }
};

// Section: related_funcs

fn decode_DartFn_Inputs_child_session_Output_String(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(crate::proton_api::auth_credential::ChildSession) -> flutter_rust_bridge::DartFnFuture<String>
{
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: crate::proton_api::auth_credential::ChildSession,
    ) -> String {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;
        <String>::sse_decode_single(message)
    }

    move |arg0: crate::proton_api::auth_credential::ChildSession| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BdkWalletManager>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>
);

// Section: dart2rust

impl SseDecode for AddressBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for AddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ApiTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for Arc<ProtonAPIService> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for BdkWalletManager {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BdkWalletManager>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for BitcoinAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ContactsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for EmailIntegrationClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for EventClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ExchangeRateClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for InviteClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for OnRampGatewayClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ProtonAPIService {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ProtonEmailAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ProtonUsersClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for ProtonWalletAuthStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for SettingsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for TransactionClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for WalletClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for bdkTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_dart_opaque(inner) };
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiCountry>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::PaymentMethod>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::Quote>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BdkWalletManager>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::flutter_logger::LogEntry,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::bdk::types::AddressIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::bdk::types::AddressIndex::New;
            }
            1 => {
                return crate::bdk::types::AddressIndex::LastUnused;
            }
            2 => {
                let mut var_index = <u32>::sse_decode(deserializer);
                return crate::bdk::types::AddressIndex::Peek { index: var_index };
            }
            3 => {
                let mut var_index = <u32>::sse_decode(deserializer);
                return crate::bdk::types::AddressIndex::Reset { index: var_index };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::types::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_index = <u32>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        return crate::bdk::types::AddressInfo {
            index: var_index,
            address: var_address,
        };
    }
}

impl SseDecode for crate::proton_api::proton_address::AllKeyAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_flags = <u32>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        let mut var_source = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_address::AllKeyAddressKey {
            flags: var_flags,
            public_key: var_publicKey,
            source: var_source,
        };
    }
}

impl SseDecode for crate::api::rust_api::Api {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::rust_api::Api {};
    }
}

impl SseDecode for crate::proton_api::contacts::ApiContactEmails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_canonicalEmail = <String>::sse_decode(deserializer);
        let mut var_isProton = <u32>::sse_decode(deserializer);
        return crate::proton_api::contacts::ApiContactEmails {
            ID: var_id,
            Name: var_name,
            Email: var_email,
            CanonicalEmail: var_canonicalEmail,
            IsProton: var_isProton,
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::ApiCountry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_fiatCurrency = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::proton_api::payment_gateway::ApiCountry {
            Code: var_code,
            FiatCurrency: var_fiatCurrency,
            Name: var_name,
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::ApiCountryFiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        return crate::proton_api::payment_gateway::ApiCountryFiatCurrency {
            Name: var_name,
            Symbol: var_symbol,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_account::ApiEmailAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet_account::ApiEmailAddress {
            ID: var_id,
            Email: var_email,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_isImported = <u8>::sse_decode(deserializer);
        let mut var_priority = <u8>::sse_decode(deserializer);
        let mut var_type = <u8>::sse_decode(deserializer);
        let mut var_hasPassphrase = <u8>::sse_decode(deserializer);
        let mut var_status = <u8>::sse_decode(deserializer);
        let mut var_mnemonic = <Option<String>>::sse_decode(deserializer);
        let mut var_fingerprint = <Option<String>>::sse_decode(deserializer);
        let mut var_publicKey = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWallet {
            ID: var_id,
            Name: var_name,
            IsImported: var_isImported,
            Priority: var_priority,
            Type: var_type,
            HasPassphrase: var_hasPassphrase,
            Status: var_status,
            Mnemonic: var_mnemonic,
            Fingerprint: var_fingerprint,
            PublicKey: var_publicKey,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_account::ApiWalletAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_derivationPath = <String>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_scriptType = <u8>::sse_decode(deserializer);
        let mut var_addresses =
            <Vec<crate::proton_api::wallet_account::ApiEmailAddress>>::sse_decode(deserializer);
        return crate::proton_api::wallet_account::ApiWalletAccount {
            ID: var_id,
            WalletID: var_walletId,
            FiatCurrency: var_fiatCurrency,
            DerivationPath: var_derivationPath,
            Label: var_label,
            ScriptType: var_scriptType,
            Addresses: var_addresses,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWalletBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_walletAccountId = <String>::sse_decode(deserializer);
        let mut var_fetched = <u8>::sse_decode(deserializer);
        let mut var_used = <u8>::sse_decode(deserializer);
        let mut var_bitcoinAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_bitcoinAddressSignature = <Option<String>>::sse_decode(deserializer);
        let mut var_bitcoinAddressIndex = <Option<u64>>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWalletBitcoinAddress {
            ID: var_id,
            WalletID: var_walletId,
            WalletAccountID: var_walletAccountId,
            Fetched: var_fetched,
            Used: var_used,
            BitcoinAddress: var_bitcoinAddress,
            BitcoinAddressSignature: var_bitcoinAddressSignature,
            BitcoinAddressIndex: var_bitcoinAddressIndex,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWalletData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_wallet = <crate::proton_api::wallet::ApiWallet>::sse_decode(deserializer);
        let mut var_walletKey = <crate::proton_api::wallet::ApiWalletKey>::sse_decode(deserializer);
        let mut var_walletSettings =
            <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWalletData {
            Wallet: var_wallet,
            WalletKey: var_walletKey,
            WalletSettings: var_walletSettings,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_walletKey = <String>::sse_decode(deserializer);
        let mut var_walletKeySignature = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWalletKey {
            WalletID: var_walletId,
            UserKeyID: var_userKeyId,
            WalletKey: var_walletKey,
            WalletKeySignature: var_walletKeySignature,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_settings::ApiWalletSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_hideAccounts = <u8>::sse_decode(deserializer);
        let mut var_invoiceDefaultDescription = <Option<String>>::sse_decode(deserializer);
        let mut var_invoiceExpirationTime = <u64>::sse_decode(deserializer);
        let mut var_maxChannelOpeningFee = <u64>::sse_decode(deserializer);
        return crate::proton_api::wallet_settings::ApiWalletSettings {
            WalletID: var_walletId,
            HideAccounts: var_hideAccounts,
            InvoiceDefaultDescription: var_invoiceDefaultDescription,
            InvoiceExpirationTime: var_invoiceExpirationTime,
            MaxChannelOpeningFee: var_maxChannelOpeningFee,
        };
    }
}

impl SseDecode for crate::proton_api::user_settings::ApiWalletUserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinUnit =
            <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(deserializer);
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_hideEmptyUsedAddresses = <u8>::sse_decode(deserializer);
        let mut var_showWalletRecovery = <u8>::sse_decode(deserializer);
        let mut var_twoFactorAmountThreshold = <Option<u64>>::sse_decode(deserializer);
        return crate::proton_api::user_settings::ApiWalletUserSettings {
            BitcoinUnit: var_bitcoinUnit,
            FiatCurrency: var_fiatCurrency,
            HideEmptyUsedAddresses: var_hideEmptyUsedAddresses,
            ShowWalletRecovery: var_showWalletRecovery,
            TwoFactorAmountThreshold: var_twoFactorAmountThreshold,
        };
    }
}

impl SseDecode for crate::proton_api::auth_credential::AuthCredential {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sessionId = <String>::sse_decode(deserializer);
        let mut var_userId = <String>::sse_decode(deserializer);
        let mut var_accessToken = <String>::sse_decode(deserializer);
        let mut var_refreshToken = <String>::sse_decode(deserializer);
        let mut var_eventId = <String>::sse_decode(deserializer);
        let mut var_userMail = <String>::sse_decode(deserializer);
        let mut var_userName = <String>::sse_decode(deserializer);
        let mut var_displayName = <String>::sse_decode(deserializer);
        let mut var_scops = <Vec<String>>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_userPrivateKey = <String>::sse_decode(deserializer);
        let mut var_userPassphrase = <String>::sse_decode(deserializer);
        return crate::proton_api::auth_credential::AuthCredential {
            session_id: var_sessionId,
            user_id: var_userId,
            access_token: var_accessToken,
            refresh_token: var_refreshToken,
            event_id: var_eventId,
            user_mail: var_userMail,
            user_name: var_userName,
            display_name: var_displayName,
            scops: var_scops,
            user_key_id: var_userKeyId,
            user_private_key: var_userPrivateKey,
            user_passphrase: var_userPassphrase,
        };
    }
}

impl SseDecode for crate::bdk::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_immature = <u64>::sse_decode(deserializer);
        let mut var_trustedPending = <u64>::sse_decode(deserializer);
        let mut var_untrustedPending = <u64>::sse_decode(deserializer);
        let mut var_confirmed = <u64>::sse_decode(deserializer);
        let mut var_spendable = <u64>::sse_decode(deserializer);
        let mut var_total = <u64>::sse_decode(deserializer);
        return crate::bdk::types::Balance {
            immature: var_immature,
            trusted_pending: var_trustedPending,
            untrusted_pending: var_untrustedPending,
            confirmed: var_confirmed,
            spendable: var_spendable,
            total: var_total,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinAddress = <String>::sse_decode(deserializer);
        let mut var_bitcoinAddressSignature = <String>::sse_decode(deserializer);
        let mut var_bitcoinAddressIndex = <u64>::sse_decode(deserializer);
        return crate::proton_api::wallet::BitcoinAddress {
            bitcoin_address: var_bitcoinAddress,
            bitcoin_address_signature: var_bitcoinAddressSignature,
            bitcoin_address_index: var_bitcoinAddressIndex,
        };
    }
}

impl SseDecode for crate::proton_api::user_settings::BitcoinUnit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::user_settings::BitcoinUnit::BTC,
            1 => crate::proton_api::user_settings::BitcoinUnit::MBTC,
            2 => crate::proton_api::user_settings::BitcoinUnit::SATS,
            _ => unreachable!("Invalid variant for BitcoinUnit: {}", inner),
        };
    }
}

impl SseDecode for crate::bdk::types::BlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::bdk::types::BlockTime {
            height: var_height,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::proton_api::errors::BridgeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::proton_api::errors::BridgeError::AndromedaApi(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::proton_api::errors::BridgeError::Generic(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::proton_api::errors::BridgeError::MuonSession(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::bdk::types::ChangeSpendPolicy::OnlyChange,
            2 => crate::bdk::types::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::auth_credential::ChildSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sessionId = <String>::sse_decode(deserializer);
        let mut var_accessToken = <String>::sse_decode(deserializer);
        let mut var_refreshToken = <String>::sse_decode(deserializer);
        let mut var_scopes = <Vec<String>>::sse_decode(deserializer);
        return crate::proton_api::auth_credential::ChildSession {
            session_id: var_sessionId,
            access_token: var_accessToken,
            refresh_token: var_refreshToken,
            scopes: var_scopes,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::ContactEmailEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_contactEmail =
            <Option<crate::proton_api::contacts::ApiContactEmails>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::ContactEmailEvent {
            id: var_id,
            action: var_action,
            contact_email: var_contactEmail,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_account::CreateWalletAccountReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_derivationPath = <String>::sse_decode(deserializer);
        let mut var_scriptType = <u8>::sse_decode(deserializer);
        return crate::proton_api::wallet_account::CreateWalletAccountReq {
            label: var_label,
            derivation_path: var_derivationPath,
            script_type: var_scriptType,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::CreateWalletReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_isImported = <u8>::sse_decode(deserializer);
        let mut var_type = <u8>::sse_decode(deserializer);
        let mut var_hasPassphrase = <u8>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_walletKey = <String>::sse_decode(deserializer);
        let mut var_mnemonic = <Option<String>>::sse_decode(deserializer);
        let mut var_publicKey = <Option<String>>::sse_decode(deserializer);
        let mut var_fingerprint = <Option<String>>::sse_decode(deserializer);
        let mut var_walletKeySignature = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet::CreateWalletReq {
            name: var_name,
            is_imported: var_isImported,
            r#type: var_type,
            has_passphrase: var_hasPassphrase,
            user_key_id: var_userKeyId,
            wallet_key: var_walletKey,
            mnemonic: var_mnemonic,
            public_key: var_publicKey,
            fingerprint: var_fingerprint,
            wallet_key_signature: var_walletKeySignature,
        };
    }
}

impl SseDecode for crate::bdk::wallet::DatabaseConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::bdk::wallet::DatabaseConfig::Memory;
            }
            1 => {
                let mut var_config =
                    <crate::bdk::wallet::SqliteDbConfiguration>::sse_decode(deserializer);
                return crate::bdk::wallet::DatabaseConfig::Sqlite { config: var_config };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_bitcoinAddressSignature = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
            bitcoin_address: var_bitcoinAddress,
            bitcoin_address_signature: var_bitcoinAddressSignature,
        };
    }
}

impl SseDecode for crate::bdk::error::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::bdk::error::Error::InvalidU32Bytes(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Generic(var_field0);
            }
            2 => {
                return crate::bdk::error::Error::ScriptDoesntHaveAddressForm;
            }
            3 => {
                return crate::bdk::error::Error::NoRecipients;
            }
            4 => {
                return crate::bdk::error::Error::NoUtxosSelected;
            }
            5 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                return crate::bdk::error::Error::OutputBelowDustLimit(var_field0);
            }
            6 => {
                let mut var_needed = <u64>::sse_decode(deserializer);
                let mut var_available = <u64>::sse_decode(deserializer);
                return crate::bdk::error::Error::InsufficientFunds {
                    needed: var_needed,
                    available: var_available,
                };
            }
            7 => {
                return crate::bdk::error::Error::BnBTotalTriesExceeded;
            }
            8 => {
                return crate::bdk::error::Error::BnBNoExactMatch;
            }
            9 => {
                return crate::bdk::error::Error::UnknownUtxo;
            }
            10 => {
                return crate::bdk::error::Error::TransactionNotFound;
            }
            11 => {
                return crate::bdk::error::Error::TransactionConfirmed;
            }
            12 => {
                return crate::bdk::error::Error::IrreplaceableTransaction;
            }
            13 => {
                let mut var_required = <f32>::sse_decode(deserializer);
                return crate::bdk::error::Error::FeeRateTooLow {
                    required: var_required,
                };
            }
            14 => {
                let mut var_required = <u64>::sse_decode(deserializer);
                return crate::bdk::error::Error::FeeTooLow {
                    required: var_required,
                };
            }
            15 => {
                return crate::bdk::error::Error::FeeRateUnavailable;
            }
            16 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::MissingKeyOrigin(var_field0);
            }
            17 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Key(var_field0);
            }
            18 => {
                return crate::bdk::error::Error::ChecksumMismatch;
            }
            19 => {
                let mut var_field0 = <crate::bdk::types::KeychainKind>::sse_decode(deserializer);
                return crate::bdk::error::Error::SpendingPolicyRequired(var_field0);
            }
            20 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::InvalidPolicyPathError(var_field0);
            }
            21 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Signer(var_field0);
            }
            22 => {
                let mut var_requested = <crate::bdk::types::Network>::sse_decode(deserializer);
                let mut var_found = <crate::bdk::types::Network>::sse_decode(deserializer);
                return crate::bdk::error::Error::InvalidNetwork {
                    requested: var_requested,
                    found: var_found,
                };
            }
            23 => {
                let mut var_field0 = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
                return crate::bdk::error::Error::InvalidOutpoint(var_field0);
            }
            24 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Descriptor(var_field0);
            }
            25 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Encode(var_field0);
            }
            26 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Miniscript(var_field0);
            }
            27 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::MiniscriptPsbt(var_field0);
            }
            28 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Bip32(var_field0);
            }
            29 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Secp256k1(var_field0);
            }
            30 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Json(var_field0);
            }
            31 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Hex(var_field0);
            }
            32 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Psbt(var_field0);
            }
            33 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::PsbtParse(var_field0);
            }
            34 => {
                let mut var_field0 = <usize>::sse_decode(deserializer);
                let mut var_field1 = <usize>::sse_decode(deserializer);
                return crate::bdk::error::Error::MissingCachedScripts(var_field0, var_field1);
            }
            35 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Electrum(var_field0);
            }
            36 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Esplora(var_field0);
            }
            37 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Sled(var_field0);
            }
            38 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Rpc(var_field0);
            }
            39 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::bdk::error::Error::Rusqlite(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::blockchain::EsploraConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseUrl = <String>::sse_decode(deserializer);
        let mut var_proxy = <Option<String>>::sse_decode(deserializer);
        let mut var_concurrency = <Option<u8>>::sse_decode(deserializer);
        let mut var_stopGap = <u64>::sse_decode(deserializer);
        let mut var_timeout = <Option<u64>>::sse_decode(deserializer);
        return crate::bdk::blockchain::EsploraConfig {
            base_url: var_baseUrl,
            proxy: var_proxy,
            concurrency: var_concurrency,
            stop_gap: var_stopGap,
            timeout: var_timeout,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::proton_api::user_settings::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::user_settings::FiatCurrency::ALL,
            1 => crate::proton_api::user_settings::FiatCurrency::DZD,
            2 => crate::proton_api::user_settings::FiatCurrency::ARS,
            3 => crate::proton_api::user_settings::FiatCurrency::AMD,
            4 => crate::proton_api::user_settings::FiatCurrency::AUD,
            5 => crate::proton_api::user_settings::FiatCurrency::AZN,
            6 => crate::proton_api::user_settings::FiatCurrency::BHD,
            7 => crate::proton_api::user_settings::FiatCurrency::BDT,
            8 => crate::proton_api::user_settings::FiatCurrency::BYN,
            9 => crate::proton_api::user_settings::FiatCurrency::BMD,
            10 => crate::proton_api::user_settings::FiatCurrency::BOB,
            11 => crate::proton_api::user_settings::FiatCurrency::BAM,
            12 => crate::proton_api::user_settings::FiatCurrency::BRL,
            13 => crate::proton_api::user_settings::FiatCurrency::BGN,
            14 => crate::proton_api::user_settings::FiatCurrency::KHR,
            15 => crate::proton_api::user_settings::FiatCurrency::CAD,
            16 => crate::proton_api::user_settings::FiatCurrency::CLP,
            17 => crate::proton_api::user_settings::FiatCurrency::CNY,
            18 => crate::proton_api::user_settings::FiatCurrency::COP,
            19 => crate::proton_api::user_settings::FiatCurrency::CRC,
            20 => crate::proton_api::user_settings::FiatCurrency::HRK,
            21 => crate::proton_api::user_settings::FiatCurrency::CUP,
            22 => crate::proton_api::user_settings::FiatCurrency::CZK,
            23 => crate::proton_api::user_settings::FiatCurrency::DKK,
            24 => crate::proton_api::user_settings::FiatCurrency::DOP,
            25 => crate::proton_api::user_settings::FiatCurrency::EGP,
            26 => crate::proton_api::user_settings::FiatCurrency::EUR,
            27 => crate::proton_api::user_settings::FiatCurrency::GEL,
            28 => crate::proton_api::user_settings::FiatCurrency::GHS,
            29 => crate::proton_api::user_settings::FiatCurrency::GTQ,
            30 => crate::proton_api::user_settings::FiatCurrency::HNL,
            31 => crate::proton_api::user_settings::FiatCurrency::HKD,
            32 => crate::proton_api::user_settings::FiatCurrency::HUF,
            33 => crate::proton_api::user_settings::FiatCurrency::ISK,
            34 => crate::proton_api::user_settings::FiatCurrency::INR,
            35 => crate::proton_api::user_settings::FiatCurrency::IDR,
            36 => crate::proton_api::user_settings::FiatCurrency::IRR,
            37 => crate::proton_api::user_settings::FiatCurrency::IQD,
            38 => crate::proton_api::user_settings::FiatCurrency::ILS,
            39 => crate::proton_api::user_settings::FiatCurrency::JMD,
            40 => crate::proton_api::user_settings::FiatCurrency::JPY,
            41 => crate::proton_api::user_settings::FiatCurrency::JOD,
            42 => crate::proton_api::user_settings::FiatCurrency::KZT,
            43 => crate::proton_api::user_settings::FiatCurrency::KES,
            44 => crate::proton_api::user_settings::FiatCurrency::KWD,
            45 => crate::proton_api::user_settings::FiatCurrency::KGS,
            46 => crate::proton_api::user_settings::FiatCurrency::LBP,
            47 => crate::proton_api::user_settings::FiatCurrency::MKD,
            48 => crate::proton_api::user_settings::FiatCurrency::MYR,
            49 => crate::proton_api::user_settings::FiatCurrency::MUR,
            50 => crate::proton_api::user_settings::FiatCurrency::MXN,
            51 => crate::proton_api::user_settings::FiatCurrency::MDL,
            52 => crate::proton_api::user_settings::FiatCurrency::MNT,
            53 => crate::proton_api::user_settings::FiatCurrency::MAD,
            54 => crate::proton_api::user_settings::FiatCurrency::MMK,
            55 => crate::proton_api::user_settings::FiatCurrency::NAD,
            56 => crate::proton_api::user_settings::FiatCurrency::NPR,
            57 => crate::proton_api::user_settings::FiatCurrency::TWD,
            58 => crate::proton_api::user_settings::FiatCurrency::NZD,
            59 => crate::proton_api::user_settings::FiatCurrency::NIO,
            60 => crate::proton_api::user_settings::FiatCurrency::NGN,
            61 => crate::proton_api::user_settings::FiatCurrency::NOK,
            62 => crate::proton_api::user_settings::FiatCurrency::OMR,
            63 => crate::proton_api::user_settings::FiatCurrency::PKR,
            64 => crate::proton_api::user_settings::FiatCurrency::PAB,
            65 => crate::proton_api::user_settings::FiatCurrency::PEN,
            66 => crate::proton_api::user_settings::FiatCurrency::PHP,
            67 => crate::proton_api::user_settings::FiatCurrency::PLN,
            68 => crate::proton_api::user_settings::FiatCurrency::GBP,
            69 => crate::proton_api::user_settings::FiatCurrency::QAR,
            70 => crate::proton_api::user_settings::FiatCurrency::RON,
            71 => crate::proton_api::user_settings::FiatCurrency::RUB,
            72 => crate::proton_api::user_settings::FiatCurrency::SAR,
            73 => crate::proton_api::user_settings::FiatCurrency::RSD,
            74 => crate::proton_api::user_settings::FiatCurrency::SGD,
            75 => crate::proton_api::user_settings::FiatCurrency::ZAR,
            76 => crate::proton_api::user_settings::FiatCurrency::KRW,
            77 => crate::proton_api::user_settings::FiatCurrency::SSP,
            78 => crate::proton_api::user_settings::FiatCurrency::VES,
            79 => crate::proton_api::user_settings::FiatCurrency::LKR,
            80 => crate::proton_api::user_settings::FiatCurrency::SEK,
            81 => crate::proton_api::user_settings::FiatCurrency::CHF,
            82 => crate::proton_api::user_settings::FiatCurrency::THB,
            83 => crate::proton_api::user_settings::FiatCurrency::TTD,
            84 => crate::proton_api::user_settings::FiatCurrency::TND,
            85 => crate::proton_api::user_settings::FiatCurrency::TRY,
            86 => crate::proton_api::user_settings::FiatCurrency::UGX,
            87 => crate::proton_api::user_settings::FiatCurrency::UAH,
            88 => crate::proton_api::user_settings::FiatCurrency::AED,
            89 => crate::proton_api::user_settings::FiatCurrency::USD,
            90 => crate::proton_api::user_settings::FiatCurrency::UYU,
            91 => crate::proton_api::user_settings::FiatCurrency::UZS,
            92 => crate::proton_api::user_settings::FiatCurrency::VND,
            _ => unreachable!("Invalid variant for FiatCurrency: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::GatewayProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::payment_gateway::GatewayProvider::Banxa,
            1 => crate::proton_api::payment_gateway::GatewayProvider::Ramp,
            2 => crate::proton_api::payment_gateway::GatewayProvider::MoonPay,
            3 => crate::proton_api::payment_gateway::GatewayProvider::Unsupported,
            _ => unreachable!("Invalid variant for GatewayProvider: {}", inner),
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::bdk::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::KeychainKind::External,
            1 => crate::bdk::types::KeychainKind::Internal,
            _ => unreachable!("Invalid variant for KeychainKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::flutter_logger::Level {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::flutter_logger::Level::Error,
            1 => crate::api::flutter_logger::Level::Warn,
            2 => crate::api::flutter_logger::Level::Info,
            3 => crate::api::flutter_logger::Level::Debug,
            4 => crate::api::flutter_logger::Level::Trace,
            _ => unreachable!("Invalid variant for Level: {}", inner),
        };
    }
}

impl SseDecode for Vec<ApiTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ApiTx>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_address::AllKeyAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::proton_address::AllKeyAddressKey>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::contacts::ApiContactEmails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::ApiCountry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::payment_gateway::ApiCountry>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::payment_gateway::ApiCountryFiatCurrency>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet_account::ApiEmailAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet_account::ApiEmailAddress>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet_account::ApiWalletAccount>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::ApiWalletBitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet::ApiWalletBitcoinAddress>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::ApiWalletData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::ApiWalletData>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::BitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::BitcoinAddress>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::ContactEmailEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::ContactEmailEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::wallet::LocalUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::wallet::LocalUtxo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::OutPoint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_address::ProtonAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::proton_address::ProtonAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_address::ProtonAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::proton_address::ProtonAddressKey>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::ProtonEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::event_routes::ProtonEvent>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::Quote> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::payment_gateway::Quote>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiCountry>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::PaymentMethod>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::Quote>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::ScriptAmount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::ScriptAmount>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TransactionDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletAccountEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::WalletAccountEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::event_routes::WalletEvent>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletKeyEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::event_routes::WalletKeyEvent>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletSettingsEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::WalletSettingsEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::WalletTransaction>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletTransactionEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::WalletTransactionEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for crate::bdk::wallet::LocalUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_outpoint = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
        let mut var_txout = <crate::bdk::types::TxOut>::sse_decode(deserializer);
        let mut var_isSpent = <bool>::sse_decode(deserializer);
        let mut var_keychain = <crate::bdk::types::KeychainKind>::sse_decode(deserializer);
        return crate::bdk::wallet::LocalUtxo {
            outpoint: var_outpoint,
            txout: var_txout,
            is_spent: var_isSpent,
            keychain: var_keychain,
        };
    }
}

impl SseDecode for crate::api::flutter_logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timeMillis = <i64>::sse_decode(deserializer);
        let mut var_msg = <String>::sse_decode(deserializer);
        let mut var_logLevel = <crate::api::flutter_logger::Level>::sse_decode(deserializer);
        let mut var_lbl = <String>::sse_decode(deserializer);
        return crate::api::flutter_logger::LogEntry {
            time_millis: var_timeMillis,
            msg: var_msg,
            log_level: var_logLevel,
            lbl: var_lbl,
        };
    }
}

impl SseDecode for crate::api::rust_objects::MyTestObject {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::rust_objects::MyTestObject {};
    }
}

impl SseDecode for crate::bdk::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::Network::Testnet,
            1 => crate::bdk::types::Network::Regtest,
            2 => crate::bdk::types::Network::Bitcoin,
            3 => crate::bdk::types::Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::contacts::ApiContactEmails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::ApiWallet> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::ApiWallet>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::wallet_account::ApiWalletAccount>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::ApiWalletKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::ApiWalletKey>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet_settings::ApiWalletSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::user_settings::ApiWalletUserSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::user_settings::ApiWalletUserSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::BlockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::BlockTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::payment_gateway::GatewayProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::exchange_rate::ProtonExchangeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::exchange_rate::ProtonExchangeRate>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::PsbtSigHashType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::PsbtSigHashType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::RbfValue>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(crate::bdk::types::OutPoint, String, usize)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(crate::bdk::types::OutPoint, String, usize)>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::Script> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::Script>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::wallet::SignOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::wallet::SignOptions>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::WalletTransaction>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::ContactEmailEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::ContactEmailEvent>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletAccountEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletAccountEvent>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletEvent>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletKeyEvent>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletSettingsEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletSettingsEvent>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletTransactionEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletTransactionEvent>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::bdk::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::bdk::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::payment_gateway::PaymentMethod::ApplePay,
            1 => crate::proton_api::payment_gateway::PaymentMethod::BankTransfer,
            2 => crate::proton_api::payment_gateway::PaymentMethod::Card,
            3 => crate::proton_api::payment_gateway::PaymentMethod::GooglePay,
            4 => crate::proton_api::payment_gateway::PaymentMethod::InstantPayment,
            5 => crate::proton_api::payment_gateway::PaymentMethod::Unsupported,
            _ => unreachable!("Invalid variant for PaymentMethod: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::proton_address::ProtonAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_domainId = <String>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_status = <u32>::sse_decode(deserializer);
        let mut var_type = <u32>::sse_decode(deserializer);
        let mut var_receive = <u32>::sse_decode(deserializer);
        let mut var_send = <u32>::sse_decode(deserializer);
        let mut var_displayName = <String>::sse_decode(deserializer);
        let mut var_keys =
            <Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>>>::sse_decode(
                deserializer,
            );
        return crate::proton_api::proton_address::ProtonAddress {
            id: var_id,
            domain_id: var_domainId,
            email: var_email,
            status: var_status,
            r#type: var_type,
            receive: var_receive,
            send: var_send,
            display_name: var_displayName,
            keys: var_keys,
        };
    }
}

impl SseDecode for crate::proton_api::proton_address::ProtonAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        let mut var_privateKey = <Option<String>>::sse_decode(deserializer);
        let mut var_token = <Option<String>>::sse_decode(deserializer);
        let mut var_signature = <Option<String>>::sse_decode(deserializer);
        let mut var_primary = <u32>::sse_decode(deserializer);
        let mut var_active = <u32>::sse_decode(deserializer);
        let mut var_flags = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_address::ProtonAddressKey {
            id: var_id,
            version: var_version,
            public_key: var_publicKey,
            private_key: var_privateKey,
            token: var_token,
            signature: var_signature,
            primary: var_primary,
            active: var_active,
            flags: var_flags,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::ProtonEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <u16>::sse_decode(deserializer);
        let mut var_eventId = <String>::sse_decode(deserializer);
        let mut var_refresh = <u32>::sse_decode(deserializer);
        let mut var_more = <u32>::sse_decode(deserializer);
        let mut var_contactEmailEvents = <Option<
            Vec<crate::proton_api::event_routes::ContactEmailEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletEvents =
            <Option<Vec<crate::proton_api::event_routes::WalletEvent>>>::sse_decode(deserializer);
        let mut var_walletAccountEvents = <Option<
            Vec<crate::proton_api::event_routes::WalletAccountEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletKeyEvents =
            <Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>>>::sse_decode(
                deserializer,
            );
        let mut var_walletSettingEvents = <Option<
            Vec<crate::proton_api::event_routes::WalletSettingsEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletTransactionEvents = <Option<
            Vec<crate::proton_api::event_routes::WalletTransactionEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletUserSettings = <Option<
            crate::proton_api::user_settings::ApiWalletUserSettings,
        >>::sse_decode(deserializer);
        return crate::proton_api::event_routes::ProtonEvent {
            code: var_code,
            event_id: var_eventId,
            refresh: var_refresh,
            more: var_more,
            contact_email_events: var_contactEmailEvents,
            wallet_events: var_walletEvents,
            wallet_account_events: var_walletAccountEvents,
            wallet_key_events: var_walletKeyEvents,
            wallet_setting_events: var_walletSettingEvents,
            wallet_transaction_events: var_walletTransactionEvents,
            wallet_user_settings: var_walletUserSettings,
        };
    }
}

impl SseDecode for crate::proton_api::exchange_rate::ProtonExchangeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_bitcoinUnit =
            <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(deserializer);
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_exchangeRateTime = <String>::sse_decode(deserializer);
        let mut var_exchangeRate = <u64>::sse_decode(deserializer);
        let mut var_cents = <u64>::sse_decode(deserializer);
        return crate::proton_api::exchange_rate::ProtonExchangeRate {
            id: var_id,
            bitcoin_unit: var_bitcoinUnit,
            fiat_currency: var_fiatCurrency,
            exchange_rate_time: var_exchangeRateTime,
            exchange_rate: var_exchangeRate,
            cents: var_cents,
        };
    }
}

impl SseDecode for crate::bdk::types::PsbtSigHashType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <u32>::sse_decode(deserializer);
        return crate::bdk::types::PsbtSigHashType { inner: var_inner };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::Quote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinAmount = <String>::sse_decode(deserializer);
        let mut var_fiatAmount = <String>::sse_decode(deserializer);
        let mut var_fiatCurrencySymbol =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_networkFee = <String>::sse_decode(deserializer);
        let mut var_paymentGatewayFee = <String>::sse_decode(deserializer);
        let mut var_paymentMethod =
            <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(deserializer);
        return crate::proton_api::payment_gateway::Quote {
            BitcoinAmount: var_bitcoinAmount,
            FiatAmount: var_fiatAmount,
            FiatCurrencySymbol: var_fiatCurrencySymbol,
            NetworkFee: var_networkFee,
            PaymentGatewayFee: var_paymentGatewayFee,
            PaymentMethod: var_paymentMethod,
        };
    }
}

impl SseDecode for crate::bdk::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::bdk::types::RbfValue::RbfDefault;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::bdk::types::RbfValue::Value(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::ApiCountry>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>>::sse_decode(
                deserializer,
            );
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::PaymentMethod>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::Quote>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (crate::bdk::types::OutPoint, String, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        let mut var_field2 = <usize>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (String, crate::bdk::types::Network) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::bdk::types::Network>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, crate::bdk::types::TransactionDetails) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::bdk::types::TransactionDetails>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::bdk::types::Script {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_internal = <Vec<u8>>::sse_decode(deserializer);
        return crate::bdk::types::Script {
            internal: var_internal,
        };
    }
}

impl SseDecode for crate::bdk::types::ScriptAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_script = <crate::bdk::types::Script>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        return crate::bdk::types::ScriptAmount {
            script: var_script,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::bdk::wallet::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isMultiSig = <bool>::sse_decode(deserializer);
        let mut var_trustWitnessUtxo = <bool>::sse_decode(deserializer);
        let mut var_assumeHeight = <Option<u32>>::sse_decode(deserializer);
        let mut var_allowAllSighashes = <bool>::sse_decode(deserializer);
        let mut var_removePartialSigs = <bool>::sse_decode(deserializer);
        let mut var_tryFinalize = <bool>::sse_decode(deserializer);
        let mut var_signWithTapInternalKey = <bool>::sse_decode(deserializer);
        let mut var_allowGrinding = <bool>::sse_decode(deserializer);
        return crate::bdk::wallet::SignOptions {
            is_multi_sig: var_isMultiSig,
            trust_witness_utxo: var_trustWitnessUtxo,
            assume_height: var_assumeHeight,
            allow_all_sighashes: var_allowAllSighashes,
            remove_partial_sigs: var_removePartialSigs,
            try_finalize: var_tryFinalize,
            sign_with_tap_internal_key: var_signWithTapInternalKey,
            allow_grinding: var_allowGrinding,
        };
    }
}

impl SseDecode for crate::bdk::wallet::SqliteDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <String>::sse_decode(deserializer);
        return crate::bdk::wallet::SqliteDbConfiguration { path: var_path };
    }
}

impl SseDecode for crate::bdk::types::TransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_serializedTx = <Option<String>>::sse_decode(deserializer);
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_received = <u64>::sse_decode(deserializer);
        let mut var_sent = <u64>::sse_decode(deserializer);
        let mut var_fee = <Option<u64>>::sse_decode(deserializer);
        let mut var_confirmationTime =
            <Option<crate::bdk::types::BlockTime>>::sse_decode(deserializer);
        return crate::bdk::types::TransactionDetails {
            serialized_tx: var_serializedTx,
            txid: var_txid,
            received: var_received,
            sent: var_sent,
            fee: var_fee,
            confirmation_time: var_confirmationTime,
        };
    }
}

impl SseDecode for crate::bdk::types::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <crate::bdk::types::Script>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return crate::bdk::types::TxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for crate::bdk::types::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <crate::bdk::types::Script>::sse_decode(deserializer);
        return crate::bdk::types::TxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletAccountEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletAccount =
            <Option<crate::proton_api::wallet_account::ApiWalletAccount>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletAccountEvent {
            id: var_id,
            action: var_action,
            wallet_account: var_walletAccount,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_wallet =
            <Option<crate::proton_api::wallet::ApiWallet>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletEvent {
            id: var_id,
            action: var_action,
            wallet: var_wallet,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletKeyEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletKey =
            <Option<crate::proton_api::wallet::ApiWalletKey>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletKeyEvent {
            id: var_id,
            action: var_action,
            wallet_key: var_walletKey,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletSettingsEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletSettings =
            <Option<crate::proton_api::wallet_settings::ApiWalletSettings>>::sse_decode(
                deserializer,
            );
        return crate::proton_api::event_routes::WalletSettingsEvent {
            id: var_id,
            action: var_action,
            wallet_settings: var_walletSettings,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::WalletTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_walletAccountId = <Option<String>>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_transactionId = <String>::sse_decode(deserializer);
        let mut var_transactionTime = <String>::sse_decode(deserializer);
        let mut var_exchangeRate =
            <Option<crate::proton_api::exchange_rate::ProtonExchangeRate>>::sse_decode(
                deserializer,
            );
        let mut var_hashedTransactionId = <Option<String>>::sse_decode(deserializer);
        let mut var_subject = <Option<String>>::sse_decode(deserializer);
        let mut var_body = <Option<String>>::sse_decode(deserializer);
        let mut var_sender = <Option<String>>::sse_decode(deserializer);
        let mut var_tolist = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::wallet::WalletTransaction {
            id: var_id,
            wallet_id: var_walletId,
            wallet_account_id: var_walletAccountId,
            label: var_label,
            transaction_id: var_transactionId,
            transaction_time: var_transactionTime,
            exchange_rate: var_exchangeRate,
            hashed_transaction_id: var_hashedTransactionId,
            subject: var_subject,
            body: var_body,
            sender: var_sender,
            tolist: var_tolist,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletTransactionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletTransaction =
            <Option<crate::proton_api::wallet::WalletTransaction>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletTransactionEvent {
            id: var_id,
            action: var_action,
            wallet_transaction: var_walletTransaction,
        };
    }
}

impl SseDecode for crate::bdk::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::WordCount::Words12,
            1 => crate::bdk::types::WordCount::Words18,
            2 => crate::bdk::types::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", inner),
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire_add_one_impl(port, ptr, rust_vec_len, data_len),
        2 => wire_add_three_impl(port, ptr, rust_vec_len, data_len),
        4 => wire_init_app_impl(port, ptr, rust_vec_len, data_len),
        7 => wire_AddressClient_get_address_balance_impl(port, ptr, rust_vec_len, data_len),
        8 => wire_AddressClient_get_scripthash_transactions_impl(port, ptr, rust_vec_len, data_len),
        9 => wire_AddressClient_get_scripthash_transactions_at_transaction_id_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire_AddressClient_new_impl(port, ptr, rust_vec_len, data_len),
        12 => {
            wire_BitcoinAddressClient_add_bitcoin_addresses_impl(port, ptr, rust_vec_len, data_len)
        }
        14 => wire_BitcoinAddressClient_get_bitcoin_address_latest_index_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        13 => wire_BitcoinAddressClient_get_wallet_bitcoin_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire_BitcoinAddressClient_new_impl(port, ptr, rust_vec_len, data_len),
        11 => {
            wire_BitcoinAddressClient_update_bitcoin_address_impl(port, ptr, rust_vec_len, data_len)
        }
        16 => wire_EmailIntegrationClient_lookup_bitcoin_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        15 => wire_EmailIntegrationClient_new_impl(port, ptr, rust_vec_len, data_len),
        19 => wire_EventClient_collect_events_impl(port, ptr, rust_vec_len, data_len),
        18 => wire_EventClient_get_latest_event_id_impl(port, ptr, rust_vec_len, data_len),
        20 => wire_EventClient_is_valid_token_impl(port, ptr, rust_vec_len, data_len),
        17 => wire_EventClient_new_impl(port, ptr, rust_vec_len, data_len),
        22 => wire_ExchangeRateClient_get_exchange_rate_impl(port, ptr, rust_vec_len, data_len),
        21 => wire_ExchangeRateClient_new_impl(port, ptr, rust_vec_len, data_len),
        23 => wire_InviteClient_new_impl(port, ptr, rust_vec_len, data_len),
        25 => {
            wire_InviteClient_send_email_integration_invite_impl(port, ptr, rust_vec_len, data_len)
        }
        24 => wire_InviteClient_send_newcomer_invite_impl(port, ptr, rust_vec_len, data_len),
        31 => {
            wire_OnRampGatewayClient_create_on_ramp_checkout_impl(port, ptr, rust_vec_len, data_len)
        }
        27 => wire_OnRampGatewayClient_get_countries_impl(port, ptr, rust_vec_len, data_len),
        28 => wire_OnRampGatewayClient_get_fiat_currencies_impl(port, ptr, rust_vec_len, data_len),
        29 => wire_OnRampGatewayClient_get_payment_methods_impl(port, ptr, rust_vec_len, data_len),
        30 => wire_OnRampGatewayClient_get_quotes_impl(port, ptr, rust_vec_len, data_len),
        26 => wire_OnRampGatewayClient_new_impl(port, ptr, rust_vec_len, data_len),
        37 => wire_ProtonApiService_get_wallets_impl(port, ptr, rust_vec_len, data_len),
        33 => wire_ProtonApiService_login_impl(port, ptr, rust_vec_len, data_len),
        36 => wire_ProtonApiService_logout_impl(port, ptr, rust_vec_len, data_len),
        35 => wire_ProtonApiService_set_proton_api_impl(port, ptr, rust_vec_len, data_len),
        34 => wire_ProtonApiService_update_auth_impl(port, ptr, rust_vec_len, data_len),
        51 => wire_ContactsClient_get_contacts_impl(port, ptr, rust_vec_len, data_len),
        50 => wire_ContactsClient_new_impl(port, ptr, rust_vec_len, data_len),
        53 => wire_ProtonEmailAddressClient_get_all_public_keys_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        54 => {
            wire_ProtonEmailAddressClient_get_proton_address_impl(port, ptr, rust_vec_len, data_len)
        }
        52 => wire_ProtonEmailAddressClient_new_impl(port, ptr, rust_vec_len, data_len),
        55 => wire_ProtonUsersClient_new_impl(port, ptr, rust_vec_len, data_len),
        58 => wire_SettingsClient_bitcoin_unit_impl(port, ptr, rust_vec_len, data_len),
        59 => wire_SettingsClient_fiat_currency_impl(port, ptr, rust_vec_len, data_len),
        57 => wire_SettingsClient_get_user_settings_impl(port, ptr, rust_vec_len, data_len),
        61 => wire_SettingsClient_hide_empty_used_addresses_impl(port, ptr, rust_vec_len, data_len),
        56 => wire_SettingsClient_new_impl(port, ptr, rust_vec_len, data_len),
        60 => wire_SettingsClient_two_fa_threshold_impl(port, ptr, rust_vec_len, data_len),
        63 => {
            wire_TransactionClient_broadcast_raw_transaction_impl(port, ptr, rust_vec_len, data_len)
        }
        64 => wire_TransactionClient_get_raw_transaction_impl(port, ptr, rust_vec_len, data_len),
        62 => wire_TransactionClient_new_impl(port, ptr, rust_vec_len, data_len),
        69 => wire_ProtonWalletAuthStore_clear_auth_dart_callback_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        70 => wire_ProtonWalletAuthStore_logout_impl(port, ptr, rust_vec_len, data_len),
        68 => wire_ProtonWalletAuthStore_set_auth_dart_callback_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        80 => wire_WalletClient_add_email_address_impl(port, ptr, rust_vec_len, data_len),
        73 => wire_WalletClient_create_wallet_impl(port, ptr, rust_vec_len, data_len),
        77 => wire_WalletClient_create_wallet_account_impl(port, ptr, rust_vec_len, data_len),
        83 => wire_WalletClient_create_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
        75 => wire_WalletClient_delete_wallet_impl(port, ptr, rust_vec_len, data_len),
        79 => wire_WalletClient_delete_wallet_account_impl(port, ptr, rust_vec_len, data_len),
        85 => wire_WalletClient_delete_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
        76 => wire_WalletClient_get_wallet_accounts_impl(port, ptr, rust_vec_len, data_len),
        82 => wire_WalletClient_get_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
        72 => wire_WalletClient_get_wallets_impl(port, ptr, rust_vec_len, data_len),
        71 => wire_WalletClient_new_impl(port, ptr, rust_vec_len, data_len),
        81 => wire_WalletClient_remove_email_address_impl(port, ptr, rust_vec_len, data_len),
        78 => wire_WalletClient_update_wallet_account_label_impl(port, ptr, rust_vec_len, data_len),
        74 => wire_WalletClient_update_wallet_name_impl(port, ptr, rust_vec_len, data_len),
        84 => wire_WalletClient_update_wallet_transaction_label_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        86 => wire_BdkWalletManager_new_impl(port, ptr, rust_vec_len, data_len),
        90 => wire_info_logger_impl(port, ptr, rust_vec_len, data_len),
        89 => wire_panic_impl(port, ptr, rust_vec_len, data_len),
        88 => wire_test_impl(port, ptr, rust_vec_len, data_len),
        91 => wire_add_two_impl(port, ptr, rust_vec_len, data_len),
        92 => wire_test_one_impl(port, ptr, rust_vec_len, data_len),
        115 => wire_add_bitcoin_addresses_impl(port, ptr, rust_vec_len, data_len),
        112 => wire_add_email_address_impl(port, ptr, rust_vec_len, data_len),
        103 => wire_bitcoin_unit_impl(port, ptr, rust_vec_len, data_len),
        123 => wire_broadcast_raw_transaction_impl(port, ptr, rust_vec_len, data_len),
        109 => wire_collect_events_impl(port, ptr, rust_vec_len, data_len),
        94 => wire_create_wallet_impl(port, ptr, rust_vec_len, data_len),
        98 => wire_create_wallet_account_impl(port, ptr, rust_vec_len, data_len),
        120 => wire_create_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
        96 => wire_delete_wallet_impl(port, ptr, rust_vec_len, data_len),
        101 => wire_delete_wallet_account_impl(port, ptr, rust_vec_len, data_len),
        122 => wire_delete_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
        104 => wire_fiat_currency_impl(port, ptr, rust_vec_len, data_len),
        126 => wire_fork_impl(port, ptr, rust_vec_len, data_len),
        124 => wire_get_all_public_keys_impl(port, ptr, rust_vec_len, data_len),
        118 => wire_get_bitcoin_address_latest_index_impl(port, ptr, rust_vec_len, data_len),
        110 => wire_get_contacts_impl(port, ptr, rust_vec_len, data_len),
        107 => wire_get_exchange_rate_impl(port, ptr, rust_vec_len, data_len),
        108 => wire_get_latest_event_id_impl(port, ptr, rust_vec_len, data_len),
        111 => wire_get_proton_address_impl(port, ptr, rust_vec_len, data_len),
        102 => wire_get_user_settings_impl(port, ptr, rust_vec_len, data_len),
        97 => wire_get_wallet_accounts_impl(port, ptr, rust_vec_len, data_len),
        117 => wire_get_wallet_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
        119 => wire_get_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
        93 => wire_get_wallets_impl(port, ptr, rust_vec_len, data_len),
        106 => wire_hide_empty_used_addresses_impl(port, ptr, rust_vec_len, data_len),
        125 => wire_is_valid_token_impl(port, ptr, rust_vec_len, data_len),
        116 => wire_lookup_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
        113 => wire_remove_email_address_impl(port, ptr, rust_vec_len, data_len),
        105 => wire_two_fa_threshold_impl(port, ptr, rust_vec_len, data_len),
        114 => wire_update_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
        100 => wire_update_wallet_account_fiat_currency_impl(port, ptr, rust_vec_len, data_len),
        99 => wire_update_wallet_account_label_impl(port, ptr, rust_vec_len, data_len),
        95 => wire_update_wallet_name_impl(port, ptr, rust_vec_len, data_len),
        121 => wire_update_wallet_transaction_label_impl(port, ptr, rust_vec_len, data_len),
        173 => wire_api_address_from_script_impl(port, ptr, rust_vec_len, data_len),
        175 => wire_api_address_network_impl(port, ptr, rust_vec_len, data_len),
        174 => wire_api_address_to_script_pubkey_impl(port, ptr, rust_vec_len, data_len),
        131 => wire_api_broadcast_impl(port, ptr, rust_vec_len, data_len),
        152 => wire_api_bump_fee_tx_builder_finish_impl(port, ptr, rust_vec_len, data_len),
        149 => wire_api_combine_psbt_impl(port, ptr, rust_vec_len, data_len),
        172 => wire_api_create_address_impl(port, ptr, rust_vec_len, data_len),
        169 => wire_api_create_derivation_path_impl(port, ptr, rust_vec_len, data_len),
        153 => wire_api_create_descriptor_impl(port, ptr, rust_vec_len, data_len),
        171 => wire_api_create_descriptor_public_impl(port, ptr, rust_vec_len, data_len),
        163 => wire_api_create_descriptor_secret_impl(port, ptr, rust_vec_len, data_len),
        127 => wire_api_create_esplora_blockchain_with_api_impl(port, ptr, rust_vec_len, data_len),
        132 => wire_api_create_transaction_impl(port, ptr, rust_vec_len, data_len),
        176 => wire_api_create_wallet_impl(port, ptr, rust_vec_len, data_len),
        166 => wire_api_derive_descriptor_secret_impl(port, ptr, rust_vec_len, data_len),
        161 => wire_api_descriptor_as_string_impl(port, ptr, rust_vec_len, data_len),
        160 => wire_api_descriptor_as_string_private_impl(port, ptr, rust_vec_len, data_len),
        170 => wire_api_descriptor_public_from_string_impl(port, ptr, rust_vec_len, data_len),
        168 => wire_api_descriptor_secret_as_public_impl(port, ptr, rust_vec_len, data_len),
        167 => wire_api_descriptor_secret_as_secret_bytes_impl(port, ptr, rust_vec_len, data_len),
        164 => wire_api_descriptor_secret_from_string_impl(port, ptr, rust_vec_len, data_len),
        130 => wire_api_estimate_fee_impl(port, ptr, rust_vec_len, data_len),
        165 => wire_api_extend_descriptor_secret_impl(port, ptr, rust_vec_len, data_len),
        146 => wire_api_extract_tx_impl(port, ptr, rust_vec_len, data_len),
        191 => wire_api_generate_seed_from_entropy_impl(port, ptr, rust_vec_len, data_len),
        190 => wire_api_generate_seed_from_string_impl(port, ptr, rust_vec_len, data_len),
        189 => wire_api_generate_seed_from_word_count_impl(port, ptr, rust_vec_len, data_len),
        177 => wire_api_get_address_impl(port, ptr, rust_vec_len, data_len),
        181 => wire_api_get_balance_impl(port, ptr, rust_vec_len, data_len),
        129 => wire_api_get_blockchain_hash_impl(port, ptr, rust_vec_len, data_len),
        188 => wire_api_get_descriptor_for_keychain_impl(port, ptr, rust_vec_len, data_len),
        128 => wire_api_get_height_impl(port, ptr, rust_vec_len, data_len),
        179 => wire_api_get_internal_address_impl(port, ptr, rust_vec_len, data_len),
        187 => wire_api_get_psbt_input_impl(port, ptr, rust_vec_len, data_len),
        183 => wire_api_get_transactions_impl(port, ptr, rust_vec_len, data_len),
        142 => wire_api_input_impl(port, ptr, rust_vec_len, data_len),
        137 => wire_api_is_coin_base_impl(port, ptr, rust_vec_len, data_len),
        138 => wire_api_is_explicitly_rbf_impl(port, ptr, rust_vec_len, data_len),
        139 => wire_api_is_lock_time_enabled_impl(port, ptr, rust_vec_len, data_len),
        178 => wire_api_is_mine_impl(port, ptr, rust_vec_len, data_len),
        150 => wire_api_json_serialize_impl(port, ptr, rust_vec_len, data_len),
        186 => wire_api_list_unspent_impl(port, ptr, rust_vec_len, data_len),
        182 => wire_api_list_unspent_outputs_impl(port, ptr, rust_vec_len, data_len),
        141 => wire_api_lock_time_impl(port, ptr, rust_vec_len, data_len),
        162 => wire_api_max_satisfaction_weight_impl(port, ptr, rust_vec_len, data_len),
        154 => wire_api_new_bip44_descriptor_impl(port, ptr, rust_vec_len, data_len),
        155 => wire_api_new_bip44_public_impl(port, ptr, rust_vec_len, data_len),
        156 => wire_api_new_bip49_descriptor_impl(port, ptr, rust_vec_len, data_len),
        157 => wire_api_new_bip49_public_impl(port, ptr, rust_vec_len, data_len),
        158 => wire_api_new_bip84_descriptor_impl(port, ptr, rust_vec_len, data_len),
        159 => wire_api_new_bip84_public_impl(port, ptr, rust_vec_len, data_len),
        143 => wire_api_output_impl(port, ptr, rust_vec_len, data_len),
        148 => wire_api_psbt_fee_amount_impl(port, ptr, rust_vec_len, data_len),
        147 => wire_api_psbt_fee_rate_impl(port, ptr, rust_vec_len, data_len),
        145 => wire_api_psbt_txid_impl(port, ptr, rust_vec_len, data_len),
        144 => wire_api_serialize_psbt_impl(port, ptr, rust_vec_len, data_len),
        184 => wire_api_sign_impl(port, ptr, rust_vec_len, data_len),
        135 => wire_api_size_impl(port, ptr, rust_vec_len, data_len),
        180 => wire_api_sync_wallet_impl(port, ptr, rust_vec_len, data_len),
        151 => wire_api_tx_builder_finish_impl(port, ptr, rust_vec_len, data_len),
        133 => wire_api_tx_txid_impl(port, ptr, rust_vec_len, data_len),
        140 => wire_api_version_impl(port, ptr, rust_vec_len, data_len),
        136 => wire_api_vsize_impl(port, ptr, rust_vec_len, data_len),
        185 => wire_api_wallet_network_impl(port, ptr, rust_vec_len, data_len),
        134 => wire_api_weight_impl(port, ptr, rust_vec_len, data_len),
        192 => wire_my_test_object_new_impl(port, ptr, rust_vec_len, data_len),
        193 => wire_my_test_object_read_text_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        3 => wire_greet_impl(ptr, rust_vec_len, data_len),
        5 => wire_helloworld_impl(ptr, rust_vec_len, data_len),
        48 => wire_ProtonApiService_get_address_client_impl(ptr, rust_vec_len, data_len),
        47 => wire_ProtonApiService_get_bitcoin_addr_client_impl(ptr, rust_vec_len, data_len),
        44 => wire_ProtonApiService_get_email_integration_client_impl(ptr, rust_vec_len, data_len),
        45 => wire_ProtonApiService_get_event_client_impl(ptr, rust_vec_len, data_len),
        39 => wire_ProtonApiService_get_exchange_rate_client_impl(ptr, rust_vec_len, data_len),
        42 => wire_ProtonApiService_get_invite_client_impl(ptr, rust_vec_len, data_len),
        49 => wire_ProtonApiService_get_on_ramp_gateway_client_impl(ptr, rust_vec_len, data_len),
        43 => wire_ProtonApiService_get_proton_contacts_client_impl(ptr, rust_vec_len, data_len),
        41 => wire_ProtonApiService_get_proton_email_addr_client_impl(ptr, rust_vec_len, data_len),
        40 => wire_ProtonApiService_get_settings_client_impl(ptr, rust_vec_len, data_len),
        46 => wire_ProtonApiService_get_transaction_client_impl(ptr, rust_vec_len, data_len),
        38 => wire_ProtonApiService_get_wallet_client_impl(ptr, rust_vec_len, data_len),
        32 => wire_ProtonApiService_new_impl(ptr, rust_vec_len, data_len),
        66 => wire_ProtonWalletAuthStore_from_session_impl(ptr, rust_vec_len, data_len),
        65 => wire_ProtonWalletAuthStore_new_impl(ptr, rust_vec_len, data_len),
        67 => wire_ProtonWalletAuthStore_set_auth_sync_impl(ptr, rust_vec_len, data_len),
        87 => wire_BdkWalletManager_fingerprint_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressBalance> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressBalance>> for AddressBalance {
    fn into_into_dart(self) -> FrbWrapper<AddressBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressClient>> for AddressClient {
    fn into_into_dart(self) -> FrbWrapper<AddressClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ApiTx> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ApiTx> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ApiTx>> for ApiTx {
    fn into_into_dart(self) -> FrbWrapper<ApiTx> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<ProtonAPIService>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Arc<ProtonAPIService>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<ProtonAPIService>>>
    for Arc<ProtonAPIService>
{
    fn into_into_dart(self) -> FrbWrapper<Arc<ProtonAPIService>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BdkWalletManager> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BdkWalletManager> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BdkWalletManager>> for BdkWalletManager {
    fn into_into_dart(self) -> FrbWrapper<BdkWalletManager> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddressClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinAddressClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddressClient>> for BitcoinAddressClient {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddressClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ContactsClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ContactsClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ContactsClient>> for ContactsClient {
    fn into_into_dart(self) -> FrbWrapper<ContactsClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EmailIntegrationClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<EmailIntegrationClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EmailIntegrationClient>>
    for EmailIntegrationClient
{
    fn into_into_dart(self) -> FrbWrapper<EmailIntegrationClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EventClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EventClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EventClient>> for EventClient {
    fn into_into_dart(self) -> FrbWrapper<EventClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ExchangeRateClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ExchangeRateClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ExchangeRateClient>> for ExchangeRateClient {
    fn into_into_dart(self) -> FrbWrapper<ExchangeRateClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<InviteClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<InviteClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<InviteClient>> for InviteClient {
    fn into_into_dart(self) -> FrbWrapper<InviteClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OnRampGatewayClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<OnRampGatewayClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OnRampGatewayClient>> for OnRampGatewayClient {
    fn into_into_dart(self) -> FrbWrapper<OnRampGatewayClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonAPIService> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ProtonAPIService> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonAPIService>> for ProtonAPIService {
    fn into_into_dart(self) -> FrbWrapper<ProtonAPIService> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonEmailAddressClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ProtonEmailAddressClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonEmailAddressClient>>
    for ProtonEmailAddressClient
{
    fn into_into_dart(self) -> FrbWrapper<ProtonEmailAddressClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonUsersClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ProtonUsersClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonUsersClient>> for ProtonUsersClient {
    fn into_into_dart(self) -> FrbWrapper<ProtonUsersClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonWalletAuthStore> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ProtonWalletAuthStore>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonWalletAuthStore>>
    for ProtonWalletAuthStore
{
    fn into_into_dart(self) -> FrbWrapper<ProtonWalletAuthStore> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SettingsClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SettingsClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SettingsClient>> for SettingsClient {
    fn into_into_dart(self) -> FrbWrapper<SettingsClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TransactionClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TransactionClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TransactionClient>> for TransactionClient {
    fn into_into_dart(self) -> FrbWrapper<TransactionClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<WalletClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<WalletClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<WalletClient>> for WalletClient {
    fn into_into_dart(self) -> FrbWrapper<WalletClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<bdkTransaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<bdkTransaction> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<bdkTransaction>> for bdkTransaction {
    fn into_into_dart(self) -> FrbWrapper<bdkTransaction> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::AddressIndex {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::types::AddressIndex::New => [0.into_dart()].into_dart(),
            crate::bdk::types::AddressIndex::LastUnused => [1.into_dart()].into_dart(),
            crate::bdk::types::AddressIndex::Peek { index } => {
                [2.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::types::AddressIndex::Reset { index } => {
                [3.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::AddressIndex
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::AddressIndex>
    for crate::bdk::types::AddressIndex
{
    fn into_into_dart(self) -> crate::bdk::types::AddressIndex {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::AddressInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.index.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::AddressInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::AddressInfo>
    for crate::bdk::types::AddressInfo
{
    fn into_into_dart(self) -> crate::bdk::types::AddressInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::proton_address::AllKeyAddressKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.flags.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::proton_address::AllKeyAddressKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::proton_address::AllKeyAddressKey>
    for crate::proton_api::proton_address::AllKeyAddressKey
{
    fn into_into_dart(self) -> crate::proton_api::proton_address::AllKeyAddressKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::rust_api::Api {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::rust_api::Api {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::rust_api::Api> for crate::api::rust_api::Api {
    fn into_into_dart(self) -> crate::api::rust_api::Api {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::contacts::ApiContactEmails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
            self.0.Email.into_into_dart().into_dart(),
            self.0.CanonicalEmail.into_into_dart().into_dart(),
            self.0.IsProton.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::contacts::ApiContactEmails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::contacts::ApiContactEmails>>
    for crate::proton_api::contacts::ApiContactEmails
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::contacts::ApiContactEmails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::payment_gateway::ApiCountry> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Code.into_into_dart().into_dart(),
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::ApiCountry>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::payment_gateway::ApiCountry>>
    for crate::proton_api::payment_gateway::ApiCountry
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::ApiCountry> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Name.into_into_dart().into_dart(),
            self.0.Symbol.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    > for crate::proton_api::payment_gateway::ApiCountryFiatCurrency
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::payment_gateway::ApiCountryFiatCurrency> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Email.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress>,
    > for crate::proton_api::wallet_account::ApiEmailAddress
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::ApiWallet> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
            self.0.IsImported.into_into_dart().into_dart(),
            self.0.Priority.into_into_dart().into_dart(),
            self.0.Type.into_into_dart().into_dart(),
            self.0.HasPassphrase.into_into_dart().into_dart(),
            self.0.Status.into_into_dart().into_dart(),
            self.0.Mnemonic.into_into_dart().into_dart(),
            self.0.Fingerprint.into_into_dart().into_dart(),
            self.0.PublicKey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWallet>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::ApiWallet>>
    for crate::proton_api::wallet::ApiWallet
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWallet> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.DerivationPath.into_into_dart().into_dart(),
            self.0.Label.into_into_dart().into_dart(),
            self.0.ScriptType.into_into_dart().into_dart(),
            self.0.Addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount>,
    > for crate::proton_api::wallet_account::ApiWalletAccount
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.WalletAccountID.into_into_dart().into_dart(),
            self.0.Fetched.into_into_dart().into_dart(),
            self.0.Used.into_into_dart().into_dart(),
            self.0.BitcoinAddress.into_into_dart().into_dart(),
            self.0.BitcoinAddressSignature.into_into_dart().into_dart(),
            self.0.BitcoinAddressIndex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress>,
    > for crate::proton_api::wallet::ApiWalletBitcoinAddress
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::ApiWalletData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Wallet.into_into_dart().into_dart(),
            self.0.WalletKey.into_into_dart().into_dart(),
            self.0.WalletSettings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWalletData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::ApiWalletData>>
    for crate::proton_api::wallet::ApiWalletData
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWalletData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::ApiWalletKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.UserKeyID.into_into_dart().into_dart(),
            self.0.WalletKey.into_into_dart().into_dart(),
            self.0.WalletKeySignature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWalletKey>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::ApiWalletKey>>
    for crate::proton_api::wallet::ApiWalletKey
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWalletKey> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.HideAccounts.into_into_dart().into_dart(),
            self.0
                .InvoiceDefaultDescription
                .into_into_dart()
                .into_dart(),
            self.0.InvoiceExpirationTime.into_into_dart().into_dart(),
            self.0.MaxChannelOpeningFee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings>,
    > for crate::proton_api::wallet_settings::ApiWalletSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.BitcoinUnit.into_into_dart().into_dart(),
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.HideEmptyUsedAddresses.into_into_dart().into_dart(),
            self.0.ShowWalletRecovery.into_into_dart().into_dart(),
            self.0.TwoFactorAmountThreshold.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings>,
    > for crate::proton_api::user_settings::ApiWalletUserSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::auth_credential::AuthCredential {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.session_id.into_into_dart().into_dart(),
            self.user_id.into_into_dart().into_dart(),
            self.access_token.into_into_dart().into_dart(),
            self.refresh_token.into_into_dart().into_dart(),
            self.event_id.into_into_dart().into_dart(),
            self.user_mail.into_into_dart().into_dart(),
            self.user_name.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.scops.into_into_dart().into_dart(),
            self.user_key_id.into_into_dart().into_dart(),
            self.user_private_key.into_into_dart().into_dart(),
            self.user_passphrase.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::auth_credential::AuthCredential
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::auth_credential::AuthCredential>
    for crate::proton_api::auth_credential::AuthCredential
{
    fn into_into_dart(self) -> crate::proton_api::auth_credential::AuthCredential {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.immature.into_into_dart().into_dart(),
            self.trusted_pending.into_into_dart().into_dart(),
            self.untrusted_pending.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Balance> for crate::bdk::types::Balance {
    fn into_into_dart(self) -> crate::bdk::types::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::BitcoinAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.bitcoin_address.into_into_dart().into_dart(),
            self.bitcoin_address_signature.into_into_dart().into_dart(),
            self.bitcoin_address_index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::BitcoinAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::BitcoinAddress>
    for crate::proton_api::wallet::BitcoinAddress
{
    fn into_into_dart(self) -> crate::proton_api::wallet::BitcoinAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::user_settings::BitcoinUnit> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::user_settings::BitcoinUnit::BTC => 0.into_dart(),
            crate::proton_api::user_settings::BitcoinUnit::MBTC => 1.into_dart(),
            crate::proton_api::user_settings::BitcoinUnit::SATS => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::BitcoinUnit>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::user_settings::BitcoinUnit>>
    for crate::proton_api::user_settings::BitcoinUnit
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::user_settings::BitcoinUnit> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::BlockTime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::BlockTime {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::BlockTime>
    for crate::bdk::types::BlockTime
{
    fn into_into_dart(self) -> crate::bdk::types::BlockTime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::errors::BridgeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::proton_api::errors::BridgeError::AndromedaApi(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::proton_api::errors::BridgeError::Generic(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::proton_api::errors::BridgeError::MuonSession(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::errors::BridgeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::errors::BridgeError>
    for crate::proton_api::errors::BridgeError
{
    fn into_into_dart(self) -> crate::proton_api::errors::BridgeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::ChangeSpendPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ChangeAllowed => 0.into_dart(),
            Self::OnlyChange => 1.into_dart(),
            Self::ChangeForbidden => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::ChangeSpendPolicy
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::ChangeSpendPolicy>
    for crate::bdk::types::ChangeSpendPolicy
{
    fn into_into_dart(self) -> crate::bdk::types::ChangeSpendPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::auth_credential::ChildSession>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.session_id.into_into_dart().into_dart(),
            self.0.access_token.into_into_dart().into_dart(),
            self.0.refresh_token.into_into_dart().into_dart(),
            self.0.scopes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::auth_credential::ChildSession>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::auth_credential::ChildSession>>
    for crate::proton_api::auth_credential::ChildSession
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::auth_credential::ChildSession> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::ContactEmailEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.contact_email.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::ContactEmailEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::ContactEmailEvent>
    for crate::proton_api::event_routes::ContactEmailEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::ContactEmailEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet_account::CreateWalletAccountReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.label.into_into_dart().into_dart(),
            self.derivation_path.into_into_dart().into_dart(),
            self.script_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet_account::CreateWalletAccountReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet_account::CreateWalletAccountReq>
    for crate::proton_api::wallet_account::CreateWalletAccountReq
{
    fn into_into_dart(self) -> crate::proton_api::wallet_account::CreateWalletAccountReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::CreateWalletReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.is_imported.into_into_dart().into_dart(),
            self.r#type.into_into_dart().into_dart(),
            self.has_passphrase.into_into_dart().into_dart(),
            self.user_key_id.into_into_dart().into_dart(),
            self.wallet_key.into_into_dart().into_dart(),
            self.mnemonic.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.fingerprint.into_into_dart().into_dart(),
            self.wallet_key_signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::CreateWalletReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::CreateWalletReq>
    for crate::proton_api::wallet::CreateWalletReq
{
    fn into_into_dart(self) -> crate::proton_api::wallet::CreateWalletReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::DatabaseConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::wallet::DatabaseConfig::Memory => [0.into_dart()].into_dart(),
            crate::bdk::wallet::DatabaseConfig::Sqlite { config } => {
                [1.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::DatabaseConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::DatabaseConfig>
    for crate::bdk::wallet::DatabaseConfig
{
    fn into_into_dart(self) -> crate::bdk::wallet::DatabaseConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.bitcoin_address.into_into_dart().into_dart(),
            self.bitcoin_address_signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::EmailIntegrationBitcoinAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::EmailIntegrationBitcoinAddress>
    for crate::proton_api::wallet::EmailIntegrationBitcoinAddress
{
    fn into_into_dart(self) -> crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::error::Error {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::error::Error::InvalidU32Bytes(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Generic(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::ScriptDoesntHaveAddressForm => [2.into_dart()].into_dart(),
            crate::bdk::error::Error::NoRecipients => [3.into_dart()].into_dart(),
            crate::bdk::error::Error::NoUtxosSelected => [4.into_dart()].into_dart(),
            crate::bdk::error::Error::OutputBelowDustLimit(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::InsufficientFunds { needed, available } => [
                6.into_dart(),
                needed.into_into_dart().into_dart(),
                available.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::bdk::error::Error::BnBTotalTriesExceeded => [7.into_dart()].into_dart(),
            crate::bdk::error::Error::BnBNoExactMatch => [8.into_dart()].into_dart(),
            crate::bdk::error::Error::UnknownUtxo => [9.into_dart()].into_dart(),
            crate::bdk::error::Error::TransactionNotFound => [10.into_dart()].into_dart(),
            crate::bdk::error::Error::TransactionConfirmed => [11.into_dart()].into_dart(),
            crate::bdk::error::Error::IrreplaceableTransaction => [12.into_dart()].into_dart(),
            crate::bdk::error::Error::FeeRateTooLow { required } => {
                [13.into_dart(), required.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::FeeTooLow { required } => {
                [14.into_dart(), required.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::FeeRateUnavailable => [15.into_dart()].into_dart(),
            crate::bdk::error::Error::MissingKeyOrigin(field0) => {
                [16.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Key(field0) => {
                [17.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::ChecksumMismatch => [18.into_dart()].into_dart(),
            crate::bdk::error::Error::SpendingPolicyRequired(field0) => {
                [19.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::InvalidPolicyPathError(field0) => {
                [20.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Signer(field0) => {
                [21.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::InvalidNetwork { requested, found } => [
                22.into_dart(),
                requested.into_into_dart().into_dart(),
                found.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::bdk::error::Error::InvalidOutpoint(field0) => {
                [23.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Descriptor(field0) => {
                [24.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Encode(field0) => {
                [25.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Miniscript(field0) => {
                [26.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::MiniscriptPsbt(field0) => {
                [27.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Bip32(field0) => {
                [28.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Secp256k1(field0) => {
                [29.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Json(field0) => {
                [30.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Hex(field0) => {
                [31.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Psbt(field0) => {
                [32.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::PsbtParse(field0) => {
                [33.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::MissingCachedScripts(field0, field1) => [
                34.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::bdk::error::Error::Electrum(field0) => {
                [35.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Esplora(field0) => {
                [36.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Sled(field0) => {
                [37.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Rpc(field0) => {
                [38.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::error::Error::Rusqlite(field0) => {
                [39.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::error::Error {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::error::Error> for crate::bdk::error::Error {
    fn into_into_dart(self) -> crate::bdk::error::Error {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::EsploraConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base_url.into_into_dart().into_dart(),
            self.proxy.into_into_dart().into_dart(),
            self.concurrency.into_into_dart().into_dart(),
            self.stop_gap.into_into_dart().into_dart(),
            self.timeout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::EsploraConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::EsploraConfig>
    for crate::bdk::blockchain::EsploraConfig
{
    fn into_into_dart(self) -> crate::bdk::blockchain::EsploraConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::user_settings::FiatCurrency> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::user_settings::FiatCurrency::ALL => 0.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::DZD => 1.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ARS => 2.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AMD => 3.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AUD => 4.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AZN => 5.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BHD => 6.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BDT => 7.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BYN => 8.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BMD => 9.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BOB => 10.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BAM => 11.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BRL => 12.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BGN => 13.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KHR => 14.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CAD => 15.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CLP => 16.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CNY => 17.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::COP => 18.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CRC => 19.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HRK => 20.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CUP => 21.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CZK => 22.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::DKK => 23.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::DOP => 24.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::EGP => 25.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::EUR => 26.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GEL => 27.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GHS => 28.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GTQ => 29.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HNL => 30.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HKD => 31.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HUF => 32.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ISK => 33.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::INR => 34.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::IDR => 35.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::IRR => 36.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::IQD => 37.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ILS => 38.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::JMD => 39.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::JPY => 40.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::JOD => 41.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KZT => 42.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KES => 43.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KWD => 44.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KGS => 45.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::LBP => 46.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MKD => 47.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MYR => 48.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MUR => 49.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MXN => 50.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MDL => 51.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MNT => 52.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MAD => 53.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MMK => 54.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NAD => 55.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NPR => 56.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TWD => 57.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NZD => 58.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NIO => 59.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NGN => 60.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NOK => 61.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::OMR => 62.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PKR => 63.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PAB => 64.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PEN => 65.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PHP => 66.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PLN => 67.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GBP => 68.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::QAR => 69.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::RON => 70.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::RUB => 71.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SAR => 72.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::RSD => 73.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SGD => 74.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ZAR => 75.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KRW => 76.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SSP => 77.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::VES => 78.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::LKR => 79.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SEK => 80.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CHF => 81.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::THB => 82.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TTD => 83.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TND => 84.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TRY => 85.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UGX => 86.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UAH => 87.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AED => 88.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::USD => 89.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UYU => 90.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UZS => 91.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::VND => 92.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::FiatCurrency>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::user_settings::FiatCurrency>>
    for crate::proton_api::user_settings::FiatCurrency
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::user_settings::FiatCurrency> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::payment_gateway::GatewayProvider::Banxa => 0.into_dart(),
            crate::proton_api::payment_gateway::GatewayProvider::Ramp => 1.into_dart(),
            crate::proton_api::payment_gateway::GatewayProvider::MoonPay => 2.into_dart(),
            crate::proton_api::payment_gateway::GatewayProvider::Unsupported => 3.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider>,
    > for crate::proton_api::payment_gateway::GatewayProvider
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::KeychainKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::External => 0.into_dart(),
            Self::Internal => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::KeychainKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::KeychainKind>
    for crate::bdk::types::KeychainKind
{
    fn into_into_dart(self) -> crate::bdk::types::KeychainKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::flutter_logger::Level> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::flutter_logger::Level::Error => 0.into_dart(),
            crate::api::flutter_logger::Level::Warn => 1.into_dart(),
            crate::api::flutter_logger::Level::Info => 2.into_dart(),
            crate::api::flutter_logger::Level::Debug => 3.into_dart(),
            crate::api::flutter_logger::Level::Trace => 4.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::flutter_logger::Level>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::flutter_logger::Level>>
    for crate::api::flutter_logger::Level
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::flutter_logger::Level> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::LocalUtxo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.outpoint.into_into_dart().into_dart(),
            self.txout.into_into_dart().into_dart(),
            self.is_spent.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::wallet::LocalUtxo {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::LocalUtxo>
    for crate::bdk::wallet::LocalUtxo
{
    fn into_into_dart(self) -> crate::bdk::wallet::LocalUtxo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::flutter_logger::LogEntry> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.time_millis.into_into_dart().into_dart(),
            self.0.msg.into_into_dart().into_dart(),
            self.0.log_level.into_into_dart().into_dart(),
            self.0.lbl.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::flutter_logger::LogEntry>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::flutter_logger::LogEntry>>
    for crate::api::flutter_logger::LogEntry
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::flutter_logger::LogEntry> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::rust_objects::MyTestObject {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::rust_objects::MyTestObject
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::rust_objects::MyTestObject>
    for crate::api::rust_objects::MyTestObject
{
    fn into_into_dart(self) -> crate::api::rust_objects::MyTestObject {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Testnet => 0.into_dart(),
            Self::Regtest => 1.into_dart(),
            Self::Bitcoin => 2.into_dart(),
            Self::Signet => 3.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Network> for crate::bdk::types::Network {
    fn into_into_dart(self) -> crate::bdk::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::OutPoint>
    for crate::bdk::types::OutPoint
{
    fn into_into_dart(self) -> crate::bdk::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::payment_gateway::PaymentMethod::ApplePay => 0.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::BankTransfer => 1.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::Card => 2.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::GooglePay => 3.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::InstantPayment => 4.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::Unsupported => 5.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod>>
    for crate::proton_api::payment_gateway::PaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::proton_address::ProtonAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.domain_id.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.r#type.into_into_dart().into_dart(),
            self.receive.into_into_dart().into_dart(),
            self.send.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::proton_address::ProtonAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::proton_address::ProtonAddress>
    for crate::proton_api::proton_address::ProtonAddress
{
    fn into_into_dart(self) -> crate::proton_api::proton_address::ProtonAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::proton_address::ProtonAddressKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.private_key.into_into_dart().into_dart(),
            self.token.into_into_dart().into_dart(),
            self.signature.into_into_dart().into_dart(),
            self.primary.into_into_dart().into_dart(),
            self.active.into_into_dart().into_dart(),
            self.flags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::proton_address::ProtonAddressKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::proton_address::ProtonAddressKey>
    for crate::proton_api::proton_address::ProtonAddressKey
{
    fn into_into_dart(self) -> crate::proton_api::proton_address::ProtonAddressKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::ProtonEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.code.into_into_dart().into_dart(),
            self.event_id.into_into_dart().into_dart(),
            self.refresh.into_into_dart().into_dart(),
            self.more.into_into_dart().into_dart(),
            self.contact_email_events.into_into_dart().into_dart(),
            self.wallet_events.into_into_dart().into_dart(),
            self.wallet_account_events.into_into_dart().into_dart(),
            self.wallet_key_events.into_into_dart().into_dart(),
            self.wallet_setting_events.into_into_dart().into_dart(),
            self.wallet_transaction_events.into_into_dart().into_dart(),
            self.wallet_user_settings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::ProtonEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::ProtonEvent>
    for crate::proton_api::event_routes::ProtonEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::ProtonEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::exchange_rate::ProtonExchangeRate {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.bitcoin_unit.into_into_dart().into_dart(),
            self.fiat_currency.into_into_dart().into_dart(),
            self.exchange_rate_time.into_into_dart().into_dart(),
            self.exchange_rate.into_into_dart().into_dart(),
            self.cents.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::exchange_rate::ProtonExchangeRate
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::exchange_rate::ProtonExchangeRate>
    for crate::proton_api::exchange_rate::ProtonExchangeRate
{
    fn into_into_dart(self) -> crate::proton_api::exchange_rate::ProtonExchangeRate {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::PsbtSigHashType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::PsbtSigHashType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::PsbtSigHashType>
    for crate::bdk::types::PsbtSigHashType
{
    fn into_into_dart(self) -> crate::bdk::types::PsbtSigHashType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::payment_gateway::Quote> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.BitcoinAmount.into_into_dart().into_dart(),
            self.0.FiatAmount.into_into_dart().into_dart(),
            self.0.FiatCurrencySymbol.into_into_dart().into_dart(),
            self.0.NetworkFee.into_into_dart().into_dart(),
            self.0.PaymentGatewayFee.into_into_dart().into_dart(),
            self.0.PaymentMethod.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::Quote>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::payment_gateway::Quote>>
    for crate::proton_api::payment_gateway::Quote
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::Quote> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::RbfValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::types::RbfValue::RbfDefault => [0.into_dart()].into_dart(),
            crate::bdk::types::RbfValue::Value(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::RbfValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::RbfValue>
    for crate::bdk::types::RbfValue
{
    fn into_into_dart(self) -> crate::bdk::types::RbfValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Script {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.internal.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Script {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Script> for crate::bdk::types::Script {
    fn into_into_dart(self) -> crate::bdk::types::Script {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::ScriptAmount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.script.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::ScriptAmount
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::ScriptAmount>
    for crate::bdk::types::ScriptAmount
{
    fn into_into_dart(self) -> crate::bdk::types::ScriptAmount {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::SignOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_multi_sig.into_into_dart().into_dart(),
            self.trust_witness_utxo.into_into_dart().into_dart(),
            self.assume_height.into_into_dart().into_dart(),
            self.allow_all_sighashes.into_into_dart().into_dart(),
            self.remove_partial_sigs.into_into_dart().into_dart(),
            self.try_finalize.into_into_dart().into_dart(),
            self.sign_with_tap_internal_key.into_into_dart().into_dart(),
            self.allow_grinding.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::SignOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::SignOptions>
    for crate::bdk::wallet::SignOptions
{
    fn into_into_dart(self) -> crate::bdk::wallet::SignOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::SqliteDbConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.path.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::SqliteDbConfiguration
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::SqliteDbConfiguration>
    for crate::bdk::wallet::SqliteDbConfiguration
{
    fn into_into_dart(self) -> crate::bdk::wallet::SqliteDbConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TransactionDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.serialized_tx.into_into_dart().into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.received.into_into_dart().into_dart(),
            self.sent.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.confirmation_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::TransactionDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TransactionDetails>
    for crate::bdk::types::TransactionDetails
{
    fn into_into_dart(self) -> crate::bdk::types::TransactionDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TxIn {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.previous_output.into_into_dart().into_dart(),
            self.script_sig.into_into_dart().into_dart(),
            self.sequence.into_into_dart().into_dart(),
            self.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::TxIn {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TxIn> for crate::bdk::types::TxIn {
    fn into_into_dart(self) -> crate::bdk::types::TxIn {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TxOut {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::TxOut {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TxOut> for crate::bdk::types::TxOut {
    fn into_into_dart(self) -> crate::bdk::types::TxOut {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletAccountEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_account.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletAccountEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletAccountEvent>
    for crate::proton_api::event_routes::WalletAccountEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletAccountEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletEvent>
    for crate::proton_api::event_routes::WalletEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletKeyEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletKeyEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletKeyEvent>
    for crate::proton_api::event_routes::WalletKeyEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletKeyEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletSettingsEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_settings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletSettingsEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletSettingsEvent>
    for crate::proton_api::event_routes::WalletSettingsEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletSettingsEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::WalletTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.wallet_id.into_into_dart().into_dart(),
            self.wallet_account_id.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.transaction_id.into_into_dart().into_dart(),
            self.transaction_time.into_into_dart().into_dart(),
            self.exchange_rate.into_into_dart().into_dart(),
            self.hashed_transaction_id.into_into_dart().into_dart(),
            self.subject.into_into_dart().into_dart(),
            self.body.into_into_dart().into_dart(),
            self.sender.into_into_dart().into_dart(),
            self.tolist.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::WalletTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::WalletTransaction>
    for crate::proton_api::wallet::WalletTransaction
{
    fn into_into_dart(self) -> crate::proton_api::wallet::WalletTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletTransactionEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_transaction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletTransactionEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletTransactionEvent>
    for crate::proton_api::event_routes::WalletTransactionEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletTransactionEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::WordCount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Words12 => 0.into_dart(),
            Self::Words18 => 1.into_dart(),
            Self::Words24 => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::WordCount {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::WordCount>
    for crate::bdk::types::WordCount
{
    fn into_into_dart(self) -> crate::bdk::types::WordCount {
        self
    }
}

impl SseEncode for AddressBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ApiTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Arc<ProtonAPIService> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for BdkWalletManager {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BdkWalletManager>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ContactsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EmailIntegrationClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for EventClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ExchangeRateClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for InviteClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for OnRampGatewayClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ProtonAPIService {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ProtonEmailAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ProtonUsersClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ProtonWalletAuthStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for SettingsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for TransactionClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for WalletClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for bdkTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.encode(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiCountry>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::PaymentMethod>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::Quote>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BdkWalletManager>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for StreamSink<
        crate::api::flutter_logger::LogEntry,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::bdk::types::AddressIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::types::AddressIndex::New => {
                <i32>::sse_encode(0, serializer);
            }
            crate::bdk::types::AddressIndex::LastUnused => {
                <i32>::sse_encode(1, serializer);
            }
            crate::bdk::types::AddressIndex::Peek { index } => {
                <i32>::sse_encode(2, serializer);
                <u32>::sse_encode(index, serializer);
            }
            crate::bdk::types::AddressIndex::Reset { index } => {
                <i32>::sse_encode(3, serializer);
                <u32>::sse_encode(index, serializer);
            }
        }
    }
}

impl SseEncode for crate::bdk::types::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.index, serializer);
        <String>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_address::AllKeyAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.flags, serializer);
        <String>::sse_encode(self.public_key, serializer);
        <u32>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::api::rust_api::Api {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::proton_api::contacts::ApiContactEmails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Name, serializer);
        <String>::sse_encode(self.Email, serializer);
        <String>::sse_encode(self.CanonicalEmail, serializer);
        <u32>::sse_encode(self.IsProton, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::ApiCountry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.Code, serializer);
        <String>::sse_encode(self.FiatCurrency, serializer);
        <String>::sse_encode(self.Name, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::ApiCountryFiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.Name, serializer);
        <String>::sse_encode(self.Symbol, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_account::ApiEmailAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Email, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Name, serializer);
        <u8>::sse_encode(self.IsImported, serializer);
        <u8>::sse_encode(self.Priority, serializer);
        <u8>::sse_encode(self.Type, serializer);
        <u8>::sse_encode(self.HasPassphrase, serializer);
        <u8>::sse_encode(self.Status, serializer);
        <Option<String>>::sse_encode(self.Mnemonic, serializer);
        <Option<String>>::sse_encode(self.Fingerprint, serializer);
        <Option<String>>::sse_encode(self.PublicKey, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_account::ApiWalletAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.WalletID, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(self.FiatCurrency, serializer);
        <String>::sse_encode(self.DerivationPath, serializer);
        <String>::sse_encode(self.Label, serializer);
        <u8>::sse_encode(self.ScriptType, serializer);
        <Vec<crate::proton_api::wallet_account::ApiEmailAddress>>::sse_encode(
            self.Addresses,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWalletBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.WalletID, serializer);
        <String>::sse_encode(self.WalletAccountID, serializer);
        <u8>::sse_encode(self.Fetched, serializer);
        <u8>::sse_encode(self.Used, serializer);
        <Option<String>>::sse_encode(self.BitcoinAddress, serializer);
        <Option<String>>::sse_encode(self.BitcoinAddressSignature, serializer);
        <Option<u64>>::sse_encode(self.BitcoinAddressIndex, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWalletData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::wallet::ApiWallet>::sse_encode(self.Wallet, serializer);
        <crate::proton_api::wallet::ApiWalletKey>::sse_encode(self.WalletKey, serializer);
        <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_encode(
            self.WalletSettings,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.WalletID, serializer);
        <String>::sse_encode(self.UserKeyID, serializer);
        <String>::sse_encode(self.WalletKey, serializer);
        <String>::sse_encode(self.WalletKeySignature, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_settings::ApiWalletSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.WalletID, serializer);
        <u8>::sse_encode(self.HideAccounts, serializer);
        <Option<String>>::sse_encode(self.InvoiceDefaultDescription, serializer);
        <u64>::sse_encode(self.InvoiceExpirationTime, serializer);
        <u64>::sse_encode(self.MaxChannelOpeningFee, serializer);
    }
}

impl SseEncode for crate::proton_api::user_settings::ApiWalletUserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::user_settings::BitcoinUnit>::sse_encode(self.BitcoinUnit, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(self.FiatCurrency, serializer);
        <u8>::sse_encode(self.HideEmptyUsedAddresses, serializer);
        <u8>::sse_encode(self.ShowWalletRecovery, serializer);
        <Option<u64>>::sse_encode(self.TwoFactorAmountThreshold, serializer);
    }
}

impl SseEncode for crate::proton_api::auth_credential::AuthCredential {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.session_id, serializer);
        <String>::sse_encode(self.user_id, serializer);
        <String>::sse_encode(self.access_token, serializer);
        <String>::sse_encode(self.refresh_token, serializer);
        <String>::sse_encode(self.event_id, serializer);
        <String>::sse_encode(self.user_mail, serializer);
        <String>::sse_encode(self.user_name, serializer);
        <String>::sse_encode(self.display_name, serializer);
        <Vec<String>>::sse_encode(self.scops, serializer);
        <String>::sse_encode(self.user_key_id, serializer);
        <String>::sse_encode(self.user_private_key, serializer);
        <String>::sse_encode(self.user_passphrase, serializer);
    }
}

impl SseEncode for crate::bdk::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.immature, serializer);
        <u64>::sse_encode(self.trusted_pending, serializer);
        <u64>::sse_encode(self.untrusted_pending, serializer);
        <u64>::sse_encode(self.confirmed, serializer);
        <u64>::sse_encode(self.spendable, serializer);
        <u64>::sse_encode(self.total, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.bitcoin_address, serializer);
        <String>::sse_encode(self.bitcoin_address_signature, serializer);
        <u64>::sse_encode(self.bitcoin_address_index, serializer);
    }
}

impl SseEncode for crate::proton_api::user_settings::BitcoinUnit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::user_settings::BitcoinUnit::BTC => 0,
                crate::proton_api::user_settings::BitcoinUnit::MBTC => 1,
                crate::proton_api::user_settings::BitcoinUnit::SATS => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::bdk::types::BlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.height, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::proton_api::errors::BridgeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::proton_api::errors::BridgeError::AndromedaApi(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::proton_api::errors::BridgeError::Generic(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::proton_api::errors::BridgeError::MuonSession(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::bdk::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::ChangeSpendPolicy::ChangeAllowed => 0,
                crate::bdk::types::ChangeSpendPolicy::OnlyChange => 1,
                crate::bdk::types::ChangeSpendPolicy::ChangeForbidden => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::auth_credential::ChildSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.session_id, serializer);
        <String>::sse_encode(self.access_token, serializer);
        <String>::sse_encode(self.refresh_token, serializer);
        <Vec<String>>::sse_encode(self.scopes, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::ContactEmailEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::contacts::ApiContactEmails>>::sse_encode(
            self.contact_email,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet_account::CreateWalletAccountReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.label, serializer);
        <String>::sse_encode(self.derivation_path, serializer);
        <u8>::sse_encode(self.script_type, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::CreateWalletReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <u8>::sse_encode(self.is_imported, serializer);
        <u8>::sse_encode(self.r#type, serializer);
        <u8>::sse_encode(self.has_passphrase, serializer);
        <String>::sse_encode(self.user_key_id, serializer);
        <String>::sse_encode(self.wallet_key, serializer);
        <Option<String>>::sse_encode(self.mnemonic, serializer);
        <Option<String>>::sse_encode(self.public_key, serializer);
        <Option<String>>::sse_encode(self.fingerprint, serializer);
        <String>::sse_encode(self.wallet_key_signature, serializer);
    }
}

impl SseEncode for crate::bdk::wallet::DatabaseConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::wallet::DatabaseConfig::Memory => {
                <i32>::sse_encode(0, serializer);
            }
            crate::bdk::wallet::DatabaseConfig::Sqlite { config } => {
                <i32>::sse_encode(1, serializer);
                <crate::bdk::wallet::SqliteDbConfiguration>::sse_encode(config, serializer);
            }
        }
    }
}

impl SseEncode for crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.bitcoin_address, serializer);
        <Option<String>>::sse_encode(self.bitcoin_address_signature, serializer);
    }
}

impl SseEncode for crate::bdk::error::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::error::Error::InvalidU32Bytes(field0) => {
                <i32>::sse_encode(0, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Generic(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::ScriptDoesntHaveAddressForm => {
                <i32>::sse_encode(2, serializer);
            }
            crate::bdk::error::Error::NoRecipients => {
                <i32>::sse_encode(3, serializer);
            }
            crate::bdk::error::Error::NoUtxosSelected => {
                <i32>::sse_encode(4, serializer);
            }
            crate::bdk::error::Error::OutputBelowDustLimit(field0) => {
                <i32>::sse_encode(5, serializer);
                <usize>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::InsufficientFunds { needed, available } => {
                <i32>::sse_encode(6, serializer);
                <u64>::sse_encode(needed, serializer);
                <u64>::sse_encode(available, serializer);
            }
            crate::bdk::error::Error::BnBTotalTriesExceeded => {
                <i32>::sse_encode(7, serializer);
            }
            crate::bdk::error::Error::BnBNoExactMatch => {
                <i32>::sse_encode(8, serializer);
            }
            crate::bdk::error::Error::UnknownUtxo => {
                <i32>::sse_encode(9, serializer);
            }
            crate::bdk::error::Error::TransactionNotFound => {
                <i32>::sse_encode(10, serializer);
            }
            crate::bdk::error::Error::TransactionConfirmed => {
                <i32>::sse_encode(11, serializer);
            }
            crate::bdk::error::Error::IrreplaceableTransaction => {
                <i32>::sse_encode(12, serializer);
            }
            crate::bdk::error::Error::FeeRateTooLow { required } => {
                <i32>::sse_encode(13, serializer);
                <f32>::sse_encode(required, serializer);
            }
            crate::bdk::error::Error::FeeTooLow { required } => {
                <i32>::sse_encode(14, serializer);
                <u64>::sse_encode(required, serializer);
            }
            crate::bdk::error::Error::FeeRateUnavailable => {
                <i32>::sse_encode(15, serializer);
            }
            crate::bdk::error::Error::MissingKeyOrigin(field0) => {
                <i32>::sse_encode(16, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Key(field0) => {
                <i32>::sse_encode(17, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::ChecksumMismatch => {
                <i32>::sse_encode(18, serializer);
            }
            crate::bdk::error::Error::SpendingPolicyRequired(field0) => {
                <i32>::sse_encode(19, serializer);
                <crate::bdk::types::KeychainKind>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::InvalidPolicyPathError(field0) => {
                <i32>::sse_encode(20, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Signer(field0) => {
                <i32>::sse_encode(21, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::InvalidNetwork { requested, found } => {
                <i32>::sse_encode(22, serializer);
                <crate::bdk::types::Network>::sse_encode(requested, serializer);
                <crate::bdk::types::Network>::sse_encode(found, serializer);
            }
            crate::bdk::error::Error::InvalidOutpoint(field0) => {
                <i32>::sse_encode(23, serializer);
                <crate::bdk::types::OutPoint>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Descriptor(field0) => {
                <i32>::sse_encode(24, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Encode(field0) => {
                <i32>::sse_encode(25, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Miniscript(field0) => {
                <i32>::sse_encode(26, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::MiniscriptPsbt(field0) => {
                <i32>::sse_encode(27, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Bip32(field0) => {
                <i32>::sse_encode(28, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Secp256k1(field0) => {
                <i32>::sse_encode(29, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Json(field0) => {
                <i32>::sse_encode(30, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Hex(field0) => {
                <i32>::sse_encode(31, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Psbt(field0) => {
                <i32>::sse_encode(32, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::PsbtParse(field0) => {
                <i32>::sse_encode(33, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::MissingCachedScripts(field0, field1) => {
                <i32>::sse_encode(34, serializer);
                <usize>::sse_encode(field0, serializer);
                <usize>::sse_encode(field1, serializer);
            }
            crate::bdk::error::Error::Electrum(field0) => {
                <i32>::sse_encode(35, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Esplora(field0) => {
                <i32>::sse_encode(36, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Sled(field0) => {
                <i32>::sse_encode(37, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Rpc(field0) => {
                <i32>::sse_encode(38, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::bdk::error::Error::Rusqlite(field0) => {
                <i32>::sse_encode(39, serializer);
                <String>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::bdk::blockchain::EsploraConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.base_url, serializer);
        <Option<String>>::sse_encode(self.proxy, serializer);
        <Option<u8>>::sse_encode(self.concurrency, serializer);
        <u64>::sse_encode(self.stop_gap, serializer);
        <Option<u64>>::sse_encode(self.timeout, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::proton_api::user_settings::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::user_settings::FiatCurrency::ALL => 0,
                crate::proton_api::user_settings::FiatCurrency::DZD => 1,
                crate::proton_api::user_settings::FiatCurrency::ARS => 2,
                crate::proton_api::user_settings::FiatCurrency::AMD => 3,
                crate::proton_api::user_settings::FiatCurrency::AUD => 4,
                crate::proton_api::user_settings::FiatCurrency::AZN => 5,
                crate::proton_api::user_settings::FiatCurrency::BHD => 6,
                crate::proton_api::user_settings::FiatCurrency::BDT => 7,
                crate::proton_api::user_settings::FiatCurrency::BYN => 8,
                crate::proton_api::user_settings::FiatCurrency::BMD => 9,
                crate::proton_api::user_settings::FiatCurrency::BOB => 10,
                crate::proton_api::user_settings::FiatCurrency::BAM => 11,
                crate::proton_api::user_settings::FiatCurrency::BRL => 12,
                crate::proton_api::user_settings::FiatCurrency::BGN => 13,
                crate::proton_api::user_settings::FiatCurrency::KHR => 14,
                crate::proton_api::user_settings::FiatCurrency::CAD => 15,
                crate::proton_api::user_settings::FiatCurrency::CLP => 16,
                crate::proton_api::user_settings::FiatCurrency::CNY => 17,
                crate::proton_api::user_settings::FiatCurrency::COP => 18,
                crate::proton_api::user_settings::FiatCurrency::CRC => 19,
                crate::proton_api::user_settings::FiatCurrency::HRK => 20,
                crate::proton_api::user_settings::FiatCurrency::CUP => 21,
                crate::proton_api::user_settings::FiatCurrency::CZK => 22,
                crate::proton_api::user_settings::FiatCurrency::DKK => 23,
                crate::proton_api::user_settings::FiatCurrency::DOP => 24,
                crate::proton_api::user_settings::FiatCurrency::EGP => 25,
                crate::proton_api::user_settings::FiatCurrency::EUR => 26,
                crate::proton_api::user_settings::FiatCurrency::GEL => 27,
                crate::proton_api::user_settings::FiatCurrency::GHS => 28,
                crate::proton_api::user_settings::FiatCurrency::GTQ => 29,
                crate::proton_api::user_settings::FiatCurrency::HNL => 30,
                crate::proton_api::user_settings::FiatCurrency::HKD => 31,
                crate::proton_api::user_settings::FiatCurrency::HUF => 32,
                crate::proton_api::user_settings::FiatCurrency::ISK => 33,
                crate::proton_api::user_settings::FiatCurrency::INR => 34,
                crate::proton_api::user_settings::FiatCurrency::IDR => 35,
                crate::proton_api::user_settings::FiatCurrency::IRR => 36,
                crate::proton_api::user_settings::FiatCurrency::IQD => 37,
                crate::proton_api::user_settings::FiatCurrency::ILS => 38,
                crate::proton_api::user_settings::FiatCurrency::JMD => 39,
                crate::proton_api::user_settings::FiatCurrency::JPY => 40,
                crate::proton_api::user_settings::FiatCurrency::JOD => 41,
                crate::proton_api::user_settings::FiatCurrency::KZT => 42,
                crate::proton_api::user_settings::FiatCurrency::KES => 43,
                crate::proton_api::user_settings::FiatCurrency::KWD => 44,
                crate::proton_api::user_settings::FiatCurrency::KGS => 45,
                crate::proton_api::user_settings::FiatCurrency::LBP => 46,
                crate::proton_api::user_settings::FiatCurrency::MKD => 47,
                crate::proton_api::user_settings::FiatCurrency::MYR => 48,
                crate::proton_api::user_settings::FiatCurrency::MUR => 49,
                crate::proton_api::user_settings::FiatCurrency::MXN => 50,
                crate::proton_api::user_settings::FiatCurrency::MDL => 51,
                crate::proton_api::user_settings::FiatCurrency::MNT => 52,
                crate::proton_api::user_settings::FiatCurrency::MAD => 53,
                crate::proton_api::user_settings::FiatCurrency::MMK => 54,
                crate::proton_api::user_settings::FiatCurrency::NAD => 55,
                crate::proton_api::user_settings::FiatCurrency::NPR => 56,
                crate::proton_api::user_settings::FiatCurrency::TWD => 57,
                crate::proton_api::user_settings::FiatCurrency::NZD => 58,
                crate::proton_api::user_settings::FiatCurrency::NIO => 59,
                crate::proton_api::user_settings::FiatCurrency::NGN => 60,
                crate::proton_api::user_settings::FiatCurrency::NOK => 61,
                crate::proton_api::user_settings::FiatCurrency::OMR => 62,
                crate::proton_api::user_settings::FiatCurrency::PKR => 63,
                crate::proton_api::user_settings::FiatCurrency::PAB => 64,
                crate::proton_api::user_settings::FiatCurrency::PEN => 65,
                crate::proton_api::user_settings::FiatCurrency::PHP => 66,
                crate::proton_api::user_settings::FiatCurrency::PLN => 67,
                crate::proton_api::user_settings::FiatCurrency::GBP => 68,
                crate::proton_api::user_settings::FiatCurrency::QAR => 69,
                crate::proton_api::user_settings::FiatCurrency::RON => 70,
                crate::proton_api::user_settings::FiatCurrency::RUB => 71,
                crate::proton_api::user_settings::FiatCurrency::SAR => 72,
                crate::proton_api::user_settings::FiatCurrency::RSD => 73,
                crate::proton_api::user_settings::FiatCurrency::SGD => 74,
                crate::proton_api::user_settings::FiatCurrency::ZAR => 75,
                crate::proton_api::user_settings::FiatCurrency::KRW => 76,
                crate::proton_api::user_settings::FiatCurrency::SSP => 77,
                crate::proton_api::user_settings::FiatCurrency::VES => 78,
                crate::proton_api::user_settings::FiatCurrency::LKR => 79,
                crate::proton_api::user_settings::FiatCurrency::SEK => 80,
                crate::proton_api::user_settings::FiatCurrency::CHF => 81,
                crate::proton_api::user_settings::FiatCurrency::THB => 82,
                crate::proton_api::user_settings::FiatCurrency::TTD => 83,
                crate::proton_api::user_settings::FiatCurrency::TND => 84,
                crate::proton_api::user_settings::FiatCurrency::TRY => 85,
                crate::proton_api::user_settings::FiatCurrency::UGX => 86,
                crate::proton_api::user_settings::FiatCurrency::UAH => 87,
                crate::proton_api::user_settings::FiatCurrency::AED => 88,
                crate::proton_api::user_settings::FiatCurrency::USD => 89,
                crate::proton_api::user_settings::FiatCurrency::UYU => 90,
                crate::proton_api::user_settings::FiatCurrency::UZS => 91,
                crate::proton_api::user_settings::FiatCurrency::VND => 92,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::payment_gateway::GatewayProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::payment_gateway::GatewayProvider::Banxa => 0,
                crate::proton_api::payment_gateway::GatewayProvider::Ramp => 1,
                crate::proton_api::payment_gateway::GatewayProvider::MoonPay => 2,
                crate::proton_api::payment_gateway::GatewayProvider::Unsupported => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::bdk::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::KeychainKind::External => 0,
                crate::bdk::types::KeychainKind::Internal => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::flutter_logger::Level {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::flutter_logger::Level::Error => 0,
                crate::api::flutter_logger::Level::Warn => 1,
                crate::api::flutter_logger::Level::Info => 2,
                crate::api::flutter_logger::Level::Debug => 3,
                crate::api::flutter_logger::Level::Trace => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<ApiTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ApiTx>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_address::AllKeyAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_address::AllKeyAddressKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::contacts::ApiContactEmails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::ApiCountry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::ApiCountry>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::ApiCountryFiatCurrency>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet_account::ApiEmailAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet_account::ApiEmailAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet_account::ApiWalletAccount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::ApiWalletBitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::ApiWalletBitcoinAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::ApiWalletData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::ApiWalletData>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::BitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::BitcoinAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::ContactEmailEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::ContactEmailEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::wallet::LocalUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::wallet::LocalUtxo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::OutPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::PaymentMethod>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_address::ProtonAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_address::ProtonAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_address::ProtonAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_address::ProtonAddressKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::ProtonEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::ProtonEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::Quote> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::Quote>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiCountry>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::PaymentMethod>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::Quote>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::ScriptAmount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::ScriptAmount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TransactionDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletAccountEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletAccountEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletKeyEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletKeyEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletSettingsEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletSettingsEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::WalletTransaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletTransactionEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletTransactionEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::bdk::wallet::LocalUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::OutPoint>::sse_encode(self.outpoint, serializer);
        <crate::bdk::types::TxOut>::sse_encode(self.txout, serializer);
        <bool>::sse_encode(self.is_spent, serializer);
        <crate::bdk::types::KeychainKind>::sse_encode(self.keychain, serializer);
    }
}

impl SseEncode for crate::api::flutter_logger::LogEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.time_millis, serializer);
        <String>::sse_encode(self.msg, serializer);
        <crate::api::flutter_logger::Level>::sse_encode(self.log_level, serializer);
        <String>::sse_encode(self.lbl, serializer);
    }
}

impl SseEncode for crate::api::rust_objects::MyTestObject {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::bdk::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::Network::Testnet => 0,
                crate::bdk::types::Network::Regtest => 1,
                crate::bdk::types::Network::Bitcoin => 2,
                crate::bdk::types::Network::Signet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::contacts::ApiContactEmails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::ApiWallet> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::ApiWallet>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet_account::ApiWalletAccount>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::ApiWalletKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::ApiWalletKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet_settings::ApiWalletSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::user_settings::ApiWalletUserSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::user_settings::ApiWalletUserSettings>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::bdk::types::BlockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::BlockTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::payment_gateway::GatewayProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::payment_gateway::PaymentMethod>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::exchange_rate::ProtonExchangeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::exchange_rate::ProtonExchangeRate>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::types::PsbtSigHashType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::PsbtSigHashType>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::RbfValue>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(crate::bdk::types::OutPoint, String, usize)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(crate::bdk::types::OutPoint, String, usize)>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::types::Script> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::Script>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::wallet::SignOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::wallet::SignOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::WalletTransaction>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::ContactEmailEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::ContactEmailEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletAccountEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletAccountEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletEvent>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletKeyEvent>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletSettingsEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletSettingsEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletTransactionEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletTransactionEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for crate::bdk::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::payment_gateway::PaymentMethod::ApplePay => 0,
                crate::proton_api::payment_gateway::PaymentMethod::BankTransfer => 1,
                crate::proton_api::payment_gateway::PaymentMethod::Card => 2,
                crate::proton_api::payment_gateway::PaymentMethod::GooglePay => 3,
                crate::proton_api::payment_gateway::PaymentMethod::InstantPayment => 4,
                crate::proton_api::payment_gateway::PaymentMethod::Unsupported => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_address::ProtonAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.domain_id, serializer);
        <String>::sse_encode(self.email, serializer);
        <u32>::sse_encode(self.status, serializer);
        <u32>::sse_encode(self.r#type, serializer);
        <u32>::sse_encode(self.receive, serializer);
        <u32>::sse_encode(self.send, serializer);
        <String>::sse_encode(self.display_name, serializer);
        <Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>>>::sse_encode(
            self.keys, serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_address::ProtonAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.version, serializer);
        <String>::sse_encode(self.public_key, serializer);
        <Option<String>>::sse_encode(self.private_key, serializer);
        <Option<String>>::sse_encode(self.token, serializer);
        <Option<String>>::sse_encode(self.signature, serializer);
        <u32>::sse_encode(self.primary, serializer);
        <u32>::sse_encode(self.active, serializer);
        <u32>::sse_encode(self.flags, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::ProtonEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.event_id, serializer);
        <u32>::sse_encode(self.refresh, serializer);
        <u32>::sse_encode(self.more, serializer);
        <Option<Vec<crate::proton_api::event_routes::ContactEmailEvent>>>::sse_encode(
            self.contact_email_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletEvent>>>::sse_encode(
            self.wallet_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletAccountEvent>>>::sse_encode(
            self.wallet_account_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>>>::sse_encode(
            self.wallet_key_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletSettingsEvent>>>::sse_encode(
            self.wallet_setting_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletTransactionEvent>>>::sse_encode(
            self.wallet_transaction_events,
            serializer,
        );
        <Option<crate::proton_api::user_settings::ApiWalletUserSettings>>::sse_encode(
            self.wallet_user_settings,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::exchange_rate::ProtonExchangeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::proton_api::user_settings::BitcoinUnit>::sse_encode(self.bitcoin_unit, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(
            self.fiat_currency,
            serializer,
        );
        <String>::sse_encode(self.exchange_rate_time, serializer);
        <u64>::sse_encode(self.exchange_rate, serializer);
        <u64>::sse_encode(self.cents, serializer);
    }
}

impl SseEncode for crate::bdk::types::PsbtSigHashType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::Quote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.BitcoinAmount, serializer);
        <String>::sse_encode(self.FiatAmount, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(
            self.FiatCurrencySymbol,
            serializer,
        );
        <String>::sse_encode(self.NetworkFee, serializer);
        <String>::sse_encode(self.PaymentGatewayFee, serializer);
        <crate::proton_api::payment_gateway::PaymentMethod>::sse_encode(
            self.PaymentMethod,
            serializer,
        );
    }
}

impl SseEncode for crate::bdk::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::types::RbfValue::RbfDefault => {
                <i32>::sse_encode(0, serializer);
            }
            crate::bdk::types::RbfValue::Value(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::ApiCountry>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::ApiCountryFiatCurrency>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::PaymentMethod>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::Quote>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (crate::bdk::types::OutPoint, String, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::OutPoint>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
        <usize>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (String, crate::bdk::types::Network) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::bdk::types::Network>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, crate::bdk::types::TransactionDetails) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::bdk::types::TransactionDetails>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::bdk::types::Script {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.internal, serializer);
    }
}

impl SseEncode for crate::bdk::types::ScriptAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::Script>::sse_encode(self.script, serializer);
        <u64>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::bdk::wallet::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_multi_sig, serializer);
        <bool>::sse_encode(self.trust_witness_utxo, serializer);
        <Option<u32>>::sse_encode(self.assume_height, serializer);
        <bool>::sse_encode(self.allow_all_sighashes, serializer);
        <bool>::sse_encode(self.remove_partial_sigs, serializer);
        <bool>::sse_encode(self.try_finalize, serializer);
        <bool>::sse_encode(self.sign_with_tap_internal_key, serializer);
        <bool>::sse_encode(self.allow_grinding, serializer);
    }
}

impl SseEncode for crate::bdk::wallet::SqliteDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path, serializer);
    }
}

impl SseEncode for crate::bdk::types::TransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.serialized_tx, serializer);
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.received, serializer);
        <u64>::sse_encode(self.sent, serializer);
        <Option<u64>>::sse_encode(self.fee, serializer);
        <Option<crate::bdk::types::BlockTime>>::sse_encode(self.confirmation_time, serializer);
    }
}

impl SseEncode for crate::bdk::types::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::OutPoint>::sse_encode(self.previous_output, serializer);
        <crate::bdk::types::Script>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for crate::bdk::types::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <crate::bdk::types::Script>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletAccountEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet_account::ApiWalletAccount>>::sse_encode(
            self.wallet_account,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet::ApiWallet>>::sse_encode(self.wallet, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletKeyEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet::ApiWalletKey>>::sse_encode(self.wallet_key, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletSettingsEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet_settings::ApiWalletSettings>>::sse_encode(
            self.wallet_settings,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet::WalletTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.wallet_id, serializer);
        <Option<String>>::sse_encode(self.wallet_account_id, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <String>::sse_encode(self.transaction_id, serializer);
        <String>::sse_encode(self.transaction_time, serializer);
        <Option<crate::proton_api::exchange_rate::ProtonExchangeRate>>::sse_encode(
            self.exchange_rate,
            serializer,
        );
        <Option<String>>::sse_encode(self.hashed_transaction_id, serializer);
        <Option<String>>::sse_encode(self.subject, serializer);
        <Option<String>>::sse_encode(self.body, serializer);
        <Option<String>>::sse_encode(self.sender, serializer);
        <Option<String>>::sse_encode(self.tolist, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletTransactionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet::WalletTransaction>>::sse_encode(
            self.wallet_transaction,
            serializer,
        );
    }
}

impl SseEncode for crate::bdk::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::WordCount::Words12 => 0,
                crate::bdk::types::WordCount::Words18 => 1,
                crate::bdk::types::WordCount::Words24 => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
