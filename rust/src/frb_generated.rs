// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::api_service::address_client::*;
use crate::api::api_service::bitcoin_address_client::*;
use crate::api::api_service::block_client::*;
use crate::api::api_service::discovery_content_client::*;
use crate::api::api_service::email_integration_client::*;
use crate::api::api_service::event_client::*;
use crate::api::api_service::exchange_rate_client::*;
use crate::api::api_service::invite_client::*;
use crate::api::api_service::onramp_gateway_client::*;
use crate::api::api_service::price_graph_client::*;
use crate::api::api_service::proton_api_service::*;
use crate::api::api_service::proton_contacts_client::*;
use crate::api::api_service::proton_email_addr_client::*;
use crate::api::api_service::proton_settings_client::*;
use crate::api::api_service::proton_users_client::*;
use crate::api::api_service::settings_client::*;
use crate::api::api_service::transaction_client::*;
use crate::api::api_service::unleash_client::*;
use crate::api::api_service::wallet_auth_store::*;
use crate::api::api_service::wallet_client::*;
use crate::api::bdk_wallet::account::*;
use crate::api::bdk_wallet::address::*;
use crate::api::bdk_wallet::amount::*;
use crate::api::bdk_wallet::balance::*;
use crate::api::bdk_wallet::blockchain::*;
use crate::api::bdk_wallet::derivation_path::*;
use crate::api::bdk_wallet::discovered_account::*;
use crate::api::bdk_wallet::local_output::*;
use crate::api::bdk_wallet::mnemonic::*;
use crate::api::bdk_wallet::payment_link::*;
use crate::api::bdk_wallet::psbt::*;
use crate::api::bdk_wallet::script_buf::*;
use crate::api::bdk_wallet::sequence::*;
use crate::api::bdk_wallet::transaction_builder::*;
use crate::api::bdk_wallet::transaction_details::*;
use crate::api::bdk_wallet::transaction_details_txin::*;
use crate::api::bdk_wallet::transaction_details_txop::*;
use crate::api::bdk_wallet::transactions::*;
use crate::api::bdk_wallet::wallet::*;
use crate::api::proton_wallet::crypto::wallet_key::*;
use crate::api::proton_wallet::db::app_database_helper::*;
use crate::api::proton_wallet::features::backup_mnemonic::*;
use crate::api::proton_wallet::features::proton_recovery::*;
use crate::api::proton_wallet::storage::user_key_store::*;
use crate::api::proton_wallet::storage::wallet_key_store::*;
use crate::api::proton_wallet::storage::wallet_mnemonic_store::*;
use crate::api::proton_wallet::wallet::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.6.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1136566313;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__api_service__address_client__AddressClient_get_address_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AddressClient_get_address_balance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_decode(&mut deserializer);
let api_address = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::address_client::AddressClient::get_address_balance(&*api_that_guard, api_address).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__address_client__AddressClient_get_scripthash_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AddressClient_get_scripthash_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_decode(&mut deserializer);
let api_script_hash = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::address_client::AddressClient::get_scripthash_transactions(&*api_that_guard, api_script_hash).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__address_client__AddressClient_get_scripthash_transactions_at_transaction_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AddressClient_get_scripthash_transactions_at_transaction_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_decode(&mut deserializer);
let api_script_hash = <String>::sse_decode(&mut deserializer);
let api_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::address_client::AddressClient::get_scripthash_transactions_at_transaction_id(&*api_that_guard, api_script_hash, api_transaction_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__address_client__AddressClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AddressClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::address_client::AddressClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_add_bitcoin_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_add_bitcoin_addresses", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_bitcoin_addresses = <Vec<crate::proton_api::wallet::BitcoinAddress>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::add_bitcoin_addresses(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_bitcoin_addresses).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_get_bitcoin_address_latest_index_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_get_bitcoin_address_latest_index", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::get_bitcoin_address_latest_index(&*api_that_guard, api_wallet_id, api_wallet_account_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_get_wallet_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_get_wallet_bitcoin_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_only_request = <Option<u8>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::get_wallet_bitcoin_address(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_only_request).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddressClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_update_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BitcoinAddressClient_update_bitcoin_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_bitcoin_address_id = <String>::sse_decode(&mut deserializer);
let api_bitcoin_address = <crate::proton_api::wallet::BitcoinAddress>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::bitcoin_address_client::BitcoinAddressClient::update_bitcoin_address(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_account_bitcoin_address_id, api_bitcoin_address).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__block_client__BlockClient_get_tip_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BlockClient_get_tip_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::block_client::BlockClient::get_tip_height(
                                &*api_that_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__block_client__BlockClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BlockClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::block_client::BlockClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__proton_contacts_client__ContactsClient_get_contacts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ContactsClient_get_contacts", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_contacts_client::ContactsClient::get_contacts(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_contacts_client__ContactsClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ContactsClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::proton_contacts_client::ContactsClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_derivation_path_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DiscoveredAccount_derivation_path",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::discovered_account::DiscoveredAccount::derivation_path(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_index_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DiscoveredAccount_index",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::discovered_account::DiscoveredAccount::index(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DiscoveredAccount_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_script_type =
                <crate::common::script_type::ScriptType>::sse_decode(&mut deserializer);
            let api_index = <u32>::sse_decode(&mut deserializer);
            let api_derivation_path = <FrbDerivationPath>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::discovered_account::DiscoveredAccount::new(
                        api_script_type,
                        api_index,
                        api_derivation_path,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_script_type_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DiscoveredAccount_script_type",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::discovered_account::DiscoveredAccount::script_type(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__discovery_content_client__DiscoveryContentClient_get_discovery_contents_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DiscoveryContentClient_get_discovery_contents", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::discovery_content_client::DiscoveryContentClient::get_discovery_contents(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__discovery_content_client__DiscoveryContentClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DiscoveryContentClient_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                        let mut api_service_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_service, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_service_guard = api_service_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::discovery_content_client::DiscoveryContentClient::new(&*api_service_guard))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__api_service__email_integration_client__EmailIntegrationClient_lookup_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EmailIntegrationClient_lookup_bitcoin_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>>>::sse_decode(&mut deserializer);
let api_email = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::email_integration_client::EmailIntegrationClient::lookup_bitcoin_address(&*api_that_guard, api_email).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__email_integration_client__EmailIntegrationClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EmailIntegrationClient_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                        let mut api_service_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_service, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_service_guard = api_service_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::email_integration_client::EmailIntegrationClient::new(&*api_service_guard))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__api_service__event_client__EventClient_collect_events_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventClient_collect_events",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>,
            >>::sse_decode(&mut deserializer);
            let api_latest_event_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::event_client::EventClient::collect_events(
                                &*api_that_guard,
                                api_latest_event_id,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__event_client__EventClient_get_latest_event_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventClient_get_latest_event_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::event_client::EventClient::get_latest_event_id(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__event_client__EventClient_is_valid_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventClient_is_valid_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::event_client::EventClient::is_valid_token(
                                &*api_that_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__event_client__EventClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::event_client::EventClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__exchange_rate_client__ExchangeRateClient_get_exchange_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ExchangeRateClient_get_exchange_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>>::sse_decode(&mut deserializer);
let api_fiat_currency = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
let api_time = <Option<u64>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::exchange_rate_client::ExchangeRateClient::get_exchange_rate(&*api_that_guard, api_fiat_currency, api_time).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__exchange_rate_client__ExchangeRateClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ExchangeRateClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::exchange_rate_client::ExchangeRateClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_build_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_build_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::build_tx(&*api_that_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_bump_transactions_fees_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_bump_transactions_fees",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_txid = <String>::sse_decode(&mut deserializer);
            let api_fees = <u64>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::bump_transactions_fees(
                                &*api_that_guard,
                                api_txid,
                                api_fees,
                                api_network,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_index = <Option<u32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::bdk_wallet::account::FrbAccount::get_address(
                            &*api_that_guard,
                            api_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_address_from_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_address_from_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            let api_address_str = <String>::sse_decode(&mut deserializer);
            let api_client = <FrbBlockchainClient>::sse_decode(&mut deserializer);
            let api_sync = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::get_address_from_graph(
                                &*api_that_guard,
                                api_network,
                                api_address_str,
                                api_client,
                                api_sync,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_addresses_from_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_addresses_from_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_pagination =
                <crate::common::pagination::Pagination>::sse_decode(&mut deserializer);
            let api_client = <FrbBlockchainClient>::sse_decode(&mut deserializer);
            let api_keychain =
                <crate::common::keychain_kind::KeychainKind>::sse_decode(&mut deserializer);
            let api_sync = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::get_addresses_from_graph(
                                &*api_that_guard,
                                api_pagination,
                                api_client,
                                api_keychain,
                                api_sync,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::bdk_wallet::account::FrbAccount::get_balance(
                                &*api_that_guard,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_derivation_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_derivation_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::bdk_wallet::account::FrbAccount::get_derivation_path(
                            &*api_that_guard,
                        )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_highest_used_address_index_in_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAccount_get_highest_used_address_index_in_output", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>>::sse_decode(&mut deserializer);
let api_keychain = <crate::common::keychain_kind::KeychainKind>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::account::FrbAccount::get_highest_used_address_index_in_output(&*api_that_guard, api_keychain).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_maximum_gap_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_maximum_gap_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_keychain =
                <crate::common::keychain_kind::KeychainKind>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::get_maximum_gap_size(
                                &*api_that_guard,
                                api_keychain,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_next_receive_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_next_receive_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::get_next_receive_address(
                                &*api_that_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_txid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::get_transaction(
                                &*api_that_guard,
                                api_txid,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_sort =
                <Option<crate::common::pagination::SortOrder>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::get_transactions(
                                &*api_that_guard,
                                api_sort,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_get_utxos_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_get_utxos",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::bdk_wallet::account::FrbAccount::get_utxos(
                            &*api_that_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_has_sync_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_has_sync_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::bdk_wallet::account::FrbAccount::has_sync_data(
                                &*api_that_guard,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_insert_unconfirmed_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_insert_unconfirmed_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_psbt = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_psbt_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_psbt, 1, false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_psbt_guard =
                                        Some(api_psbt.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_psbt_guard = api_psbt_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::account::FrbAccount::insert_unconfirmed_tx(
                                &*api_that_guard,
                                &*api_psbt_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_is_mine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_is_mine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_address = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_address_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_address,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_address_guard =
                                        Some(api_address.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_address_guard = api_address_guard.unwrap();
                        let output_ok = crate::api::bdk_wallet::account::FrbAccount::is_mine(
                            &*api_that_guard,
                            &*api_address_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_mark_receive_addresses_used_to_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAccount_mark_receive_addresses_used_to", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>>::sse_decode(&mut deserializer);
let api_from = <u32>::sse_decode(&mut deserializer);
let api_to = <Option<u32>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::account::FrbAccount::mark_receive_addresses_used_to(&*api_that_guard, api_from, api_to).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            let api_script_type =
                <crate::common::script_type::ScriptType>::sse_decode(&mut deserializer);
            let api_derivation_path = <FrbDerivationPath>::sse_decode(&mut deserializer);
            let api_storage_factory =
                <crate::api::bdk_wallet::storage::WalletMobileConnectorFactory>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let mut api_wallet_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wallet,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wallet_guard = Some(api_wallet.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wallet_guard = api_wallet_guard.unwrap();
                let output_ok = crate::api::bdk_wallet::account::FrbAccount::new(
                    &*api_wallet_guard,
                    api_script_type,
                    api_derivation_path,
                    api_storage_factory,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__account__FrbAccount_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAccount_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_psbt = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_psbt_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_psbt, 1, true,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_psbt_guard =
                                        Some(api_psbt.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let mut api_psbt_guard = api_psbt_guard.unwrap();
                        let output_ok = crate::api::bdk_wallet::account::FrbAccount::sign(
                            &*api_that_guard,
                            &mut *api_psbt_guard,
                            api_network,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddressDetails_address_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddressDetails_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::address::FrbAddressDetails::address(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddressDetails_balance_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddressDetails_balance",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::address::FrbAddressDetails::balance(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddressDetails_index_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddressDetails_index",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::address::FrbAddressDetails::index(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddressDetails_transactions_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddressDetails_transactions",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::address::FrbAddressDetails::transactions(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddress_from_script_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddress_from_script",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_script = <FrbScriptBuf>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok = crate::api::bdk_wallet::address::FrbAddress::from_script(
                    api_script,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddress_into_script_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddress_into_script",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::address::FrbAddress::into_script(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddress_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddress_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::bdk_wallet::address::FrbAddress::new(api_address, api_network)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__address__FrbAddress_to_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAddress_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::address::FrbAddress::to_string(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__amount__FrbAmount_to_btc_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAmount_to_btc",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <FrbAmount>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::amount::FrbAmount::to_btc(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__amount__FrbAmount_to_sat_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAmount_to_sat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <FrbAmount>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::amount::FrbAmount::to_sat(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_build_database_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_build_database", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_old_version = <u32>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::build_database(&mut *api_that_guard, api_old_version).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_delete_wallet", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::delete_wallet(&*api_that_guard, &api_wallet_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_delete_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_delete_wallet_account", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::delete_wallet_account(&*api_that_guard, &api_account_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallet_accounts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_all_wallet_accounts", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_all_wallet_accounts(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallet_accounts_by_wallet_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_all_wallet_accounts_by_wallet_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_all_wallet_accounts_by_wallet_id(&*api_that_guard, &api_wallet_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_all_wallets", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_all_wallets(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallets_by_user_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_all_wallets_by_user_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_user_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_all_wallets_by_user_id(&*api_that_guard, &api_user_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_default_wallet_by_user_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_default_wallet_by_user_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_user_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_default_wallet_by_user_id(&*api_that_guard, &api_user_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_wallet_account_by_account_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_wallet_account_by_account_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_wallet_account_by_account_id(&*api_that_guard, &api_account_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_wallet_by_wallet_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_get_wallet_by_wallet_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::get_wallet_by_wallet_id(&*api_that_guard, &api_wallet_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbAppDatabase_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_database_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::new(
                        &api_database_url,
                    )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_upsert_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_upsert_wallet", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_wallet = <crate::proton_wallet::db::model::wallet_model::WalletModel>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::upsert_wallet(&*api_that_guard, api_wallet).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_upsert_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbAppDatabase_upsert_wallet_account", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_decode(&mut deserializer);
let api_account = <crate::proton_wallet::db::model::account_model::AccountModel>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::db::app_database_helper::FrbAppDatabase::upsert_wallet_account(&*api_that_guard, api_account).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__features__backup_mnemonic__FrbBackupMnemonic_two_fa_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbBackupMnemonic_two_fa_status", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::backup_mnemonic::FrbBackupMnemonic::two_fa_status(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__features__backup_mnemonic__FrbBackupMnemonic_view_seed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbBackupMnemonic_view_seed", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_login_password = <String>::sse_decode(&mut deserializer);
let api_twofa = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::backup_mnemonic::FrbBackupMnemonic::view_seed(&*api_that_guard, api_wallet_id, api_login_password, api_twofa).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__balance__FrbBalance_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBalance_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::bdk_wallet::balance::FrbBalance::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__balance__FrbBalance_total_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBalance_total",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::balance::FrbBalance::total(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__balance__FrbBalance_trusted_spendable_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBalance_trusted_spendable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::balance::FrbBalance::trusted_spendable(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_broadcast_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbBlockchainClient_broadcast_psbt", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>>::sse_decode(&mut deserializer);
let api_psbt = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_label = <Option<String>>::sse_decode(&mut deserializer);
let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);
let api_address_id = <Option<String>>::sse_decode(&mut deserializer);
let api_body = <Option<String>>::sse_decode(&mut deserializer);
let api_message = <Option<crate::common::broadcast_message::BroadcastMessage>>::sse_decode(&mut deserializer);
let api_recipients = <Option<std::collections::HashMap<String, String>>>::sse_decode(&mut deserializer);
let api_is_anonymous = <Option<u8>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let mut api_psbt_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false), flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_psbt, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
1 => api_psbt_guard = Some(api_psbt.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
let api_psbt_guard = api_psbt_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::blockchain::FrbBlockchainClient::broadcast_psbt(&*api_that_guard, &*api_psbt_guard, api_wallet_id, api_wallet_account_id, api_label, api_exchange_rate_id, api_transaction_time, api_address_id, api_body, api_message, api_recipients, api_is_anonymous).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_create_esplora_blockchain_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbBlockchainClient_create_esplora_blockchain", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                     let output_ok = crate::api::bdk_wallet::blockchain::FrbBlockchainClient::create_esplora_blockchain()?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_full_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBlockchainClient_full_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>,
            >>::sse_decode(&mut deserializer);
            let api_account = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            let api_stop_gap = <Option<usize>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_account_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_account,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_account_guard =
                                        Some(api_account.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_account_guard = api_account_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::blockchain::FrbBlockchainClient::full_sync(
                                &*api_that_guard,
                                &*api_account_guard,
                                api_stop_gap,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_get_fees_estimation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbBlockchainClient_get_fees_estimation", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::blockchain::FrbBlockchainClient::get_fees_estimation(&mut *api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_get_recommended_fees_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbBlockchainClient_get_recommended_fees", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::blockchain::FrbBlockchainClient::get_recommended_fees(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBlockchainClient_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_api_service = <Arc<ProtonAPIService>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::bdk_wallet::blockchain::FrbBlockchainClient::new(api_api_service)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_partial_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBlockchainClient_partial_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>,
            >>::sse_decode(&mut deserializer);
            let api_account = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_account_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_account,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_account_guard =
                                        Some(api_account.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_account_guard = api_account_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::blockchain::FrbBlockchainClient::partial_sync(
                                &*api_that_guard,
                                &*api_account_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_should_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbBlockchainClient_should_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>,
            >>::sse_decode(&mut deserializer);
            let api_account = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_account_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_account,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_account_guard =
                                        Some(api_account.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_account_guard = api_account_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::blockchain::FrbBlockchainClient::should_sync(
                                &*api_that_guard,
                                &*api_account_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__derivation_path__FrbDerivationPath_from_parts_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDerivationPath_from_parts",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_script_type =
                <crate::common::script_type::ScriptType>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            let api_account_index = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::derivation_path::FrbDerivationPath::from_parts(
                        api_script_type,
                        api_network,
                        api_account_index,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__derivation_path__FrbDerivationPath_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDerivationPath_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::bdk_wallet::derivation_path::FrbDerivationPath::new(&api_path)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details_txin__FrbDetailledTxIn_previous_output_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbDetailledTxIn_previous_output", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::bdk_wallet::transaction_details_txin::FrbDetailledTxIn::previous_output(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__bdk_wallet__transaction_details_txin__FrbDetailledTxIn_script_sig_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDetailledTxIn_script_sig",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details_txin::FrbDetailledTxIn::script_sig(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details_txin__FrbDetailledTxIn_sequence_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDetailledTxIn_sequence",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details_txin::FrbDetailledTxIn::sequence(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_address_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDetailledTxOutput_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details_txop::FrbDetailledTxOutput::address(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_is_mine_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDetailledTxOutput_is_mine",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details_txop::FrbDetailledTxOutput::is_mine(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_script_pubkey_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbDetailledTxOutput_script_pubkey", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::bdk_wallet::transaction_details_txop::FrbDetailledTxOutput::script_pubkey(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_value_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbDetailledTxOutput_value",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details_txop::FrbDetailledTxOutput::value(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_confirmation_time_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbLocalOutput_confirmation_time",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbLocalOutput::confirmation_time(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_derivation_index_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbLocalOutput_derivation_index",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbLocalOutput::derivation_index(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_is_spent_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbLocalOutput_is_spent",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbLocalOutput::is_spent(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_keychain_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbLocalOutput_keychain",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbLocalOutput::keychain(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_outpoint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbLocalOutput_outpoint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbLocalOutput::outpoint(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_txout_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbLocalOutput_txout",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbLocalOutput::txout(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_as_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbMnemonic_as_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::mnemonic::FrbMnemonic::as_string(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_as_words_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbMnemonic_as_words",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::mnemonic::FrbMnemonic::as_words(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_from_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbMnemonic_from_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mnemonic = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::bdk_wallet::mnemonic::FrbMnemonic::from_string(api_mnemonic)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_get_words_autocomplete_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbMnemonic_get_words_autocomplete",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_word_start = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::mnemonic::FrbMnemonic::get_words_autocomplete(
                        api_word_start,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbMnemonic_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_word_count =
                <crate::common::word_count::WordCount>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok = crate::api::bdk_wallet::mnemonic::FrbMnemonic::new(api_word_count)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_new_with_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbMnemonic_new_with",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entropy = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::bdk_wallet::mnemonic::FrbMnemonic::new_with(api_entropy)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_to_address_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPaymentLink_to_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::payment_link::FrbPaymentLink::to_address(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_to_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPaymentLink_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::payment_link::FrbPaymentLink::to_string(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_to_uri_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPaymentLink_to_uri",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::payment_link::FrbPaymentLink::to_uri(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_try_parse_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPaymentLink_try_parse",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_str = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok = crate::api::bdk_wallet::payment_link::FrbPaymentLink::try_parse(
                    api_str,
                    api_network,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_disable_recovery_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonRecovery_disable_recovery", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>>::sse_decode(&mut deserializer);
let api_login_password = <String>::sse_decode(&mut deserializer);
let api_twofa = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::proton_recovery::FrbProtonRecovery::disable_recovery(&*api_that_guard, &api_login_password, &api_twofa).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_enable_recovery_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonRecovery_enable_recovery", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>>::sse_decode(&mut deserializer);
let api_login_password = <String>::sse_decode(&mut deserializer);
let api_twofa = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::proton_recovery::FrbProtonRecovery::enable_recovery(&*api_that_guard, &api_login_password, &api_twofa).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_reactive_recovery_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonRecovery_reactive_recovery", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>>::sse_decode(&mut deserializer);
let api_login_password = <Option<String>>::sse_decode(&mut deserializer);
let api_twofa = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::proton_recovery::FrbProtonRecovery::reactive_recovery(&*api_that_guard, api_login_password, &api_twofa).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_recovery_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonRecovery_recovery_status", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::proton_recovery::FrbProtonRecovery::recovery_status(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_two_fa_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonRecovery_two_fa_status", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::features::proton_recovery::FrbProtonRecovery::two_fa_status(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__wallet__FrbProtonWallet_get_backup_mnemonic_feature_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonWallet_get_backup_mnemonic_feature", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::wallet::FrbProtonWallet::get_backup_mnemonic_feature(&*api_that_guard)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__wallet__FrbProtonWallet_get_proton_recovery_feature_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbProtonWallet_get_proton_recovery_feature", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::proton_wallet::wallet::FrbProtonWallet::get_proton_recovery_feature(&*api_that_guard)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__wallet__FrbProtonWallet_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbProtonWallet_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_db_path = <String>::sse_decode(&mut deserializer);
            let api_user_key_tore = <FrbUserKeyStore>::sse_decode(&mut deserializer);
            let api_wallet_key_store = <FrbWalletKeyStore>::sse_decode(&mut deserializer);
            let api_wallet_mnemonic_store = <FrbWalletMnemonicStore>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_wallet::wallet::FrbProtonWallet::new(
                            api_db_path,
                            api_user_key_tore,
                            api_wallet_key_store,
                            api_wallet_mnemonic_store,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__psbt__FrbPsbt_compute_tx_vbytes_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPsbt_compute_tx_vbytes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    crate::api::bdk_wallet::psbt::FrbPsbt::compute_tx_vbytes(&*api_that_guard)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__psbt__FrbPsbt_extract_tx_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPsbt_extract_tx",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    crate::api::bdk_wallet::psbt::FrbPsbt::extract_tx(&*api_that_guard)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__psbt__FrbPsbt_fee_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPsbt_fee",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = crate::api::bdk_wallet::psbt::FrbPsbt::fee(&*api_that_guard)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__psbt__FrbPsbt_recipients_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPsbt_recipients",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::psbt::FrbPsbt::recipients(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__psbt__FrbPsbt_total_fees_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbPsbt_total_fees",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::psbt::FrbPsbt::total_fees(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__script_buf__FrbScriptBuf_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbScriptBuf_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_raw_output_script = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::script_buf::FrbScriptBuf::new(api_raw_output_script),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__script_buf__FrbScriptBuf_to_bytes_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbScriptBuf_to_bytes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::script_buf::FrbScriptBuf::to_bytes(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__sequence__FrbSequence_is_final_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbSequence_is_final",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::sequence::FrbSequence::is_final(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__sequence__FrbSequence_is_height_locked_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbSequence_is_height_locked",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::sequence::FrbSequence::is_height_locked(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__sequence__FrbSequence_is_rbf_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbSequence_is_rbf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::sequence::FrbSequence::is_rbf(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__sequence__FrbSequence_is_relative_lock_time_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbSequence_is_relative_lock_time",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::sequence::FrbSequence::is_relative_lock_time(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__sequence__FrbSequence_is_time_locked_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbSequence_is_time_locked",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::sequence::FrbSequence::is_time_locked(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_account_derivation_path_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbTransactionDetails_account_derivation_path", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::account_derivation_path(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_fees_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_fees",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::fees(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_inputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_inputs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::inputs(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_outputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_outputs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::outputs(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_received_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_received",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::received(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_sent_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_sent",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::sent(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_time_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_time",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::time(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_txid_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_txid",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::txid(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_vbytes_size_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransactionDetails_vbytes_size",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_details::FrbTransactionDetails::vbytes_size(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transactions__FrbTransaction_compute_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransaction_compute_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::bdk_wallet::transactions::FrbTransaction::compute_txid(
                            &*api_that_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__transactions__FrbTransaction_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTransaction_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transaction_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok = crate::api::bdk_wallet::transactions::FrbTransaction::new(
                    api_transaction_bytes,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_add_recipient_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_add_recipient",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            let api_address_str = <Option<String>>::sse_decode(&mut deserializer);
            let api_amount = <Option<u64>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::add_recipient(
                        &*api_that_guard,
                        api_address_str,
                        api_amount,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_clear_recipients_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_clear_recipients",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::clear_recipients(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_clear_utxos_to_spend_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_clear_utxos_to_spend",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::clear_utxos_to_spend(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_constrain_recipient_amounts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbTxBuilder_constrain_recipient_amounts", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::constrain_recipient_amounts(&mut *api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_create_draft_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbTxBuilder_create_draft_psbt", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>>::sse_decode(&mut deserializer);
let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
let api_allow_dust = <Option<bool>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::create_draft_psbt(&mut *api_that_guard, api_network, api_allow_dust).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_create_pbst_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_create_pbst",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, true,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let mut api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::create_pbst(
                                &mut *api_that_guard,
                                api_network,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_disable_rbf_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_disable_rbf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::disable_rbf(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_enable_rbf_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_enable_rbf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::enable_rbf(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_change_policy_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_get_change_policy",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::get_change_policy(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_coin_selection_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_get_coin_selection",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::get_coin_selection(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_fee_rate_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_get_fee_rate",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::get_fee_rate(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_rbf_enabled_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_get_rbf_enabled",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::get_rbf_enabled(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_utxos_to_spend_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_get_utxos_to_spend",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::get_utxos_to_spend(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_remove_locktime_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_remove_locktime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::remove_locktime(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_remove_recipient_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_remove_recipient",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            let api_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::remove_recipient(
                        &*api_that_guard,
                        api_index,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_set_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            let api_account = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_account_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_account,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_account_guard =
                                        Some(api_account.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_account_guard = api_account_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::set_account(
                                &*api_that_guard,
                                &*api_account_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_change_policy_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_set_change_policy",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            let api_change_policy =
                <crate::common::change_spend_policy::ChangeSpendPolicy>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::set_change_policy(
                        &*api_that_guard,
                        api_change_policy,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_coin_selection_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxBuilder_set_coin_selection",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
            >>::sse_decode(&mut deserializer);
            let api_coin_selection =
                <crate::common::coin_selection::CoinSelection>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::set_coin_selection(
                        &*api_that_guard,
                        api_coin_selection,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_fee_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbTxBuilder_set_fee_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>>::sse_decode(&mut deserializer);
let api_sat_per_vb = <u64>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::set_fee_rate(&*api_that_guard, api_sat_per_vb).await)?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_update_recipient_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbTxBuilder_update_recipient", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>>::sse_decode(&mut deserializer);
let api_index = <usize>::sse_decode(&mut deserializer);
let api_address_str = <Option<String>>::sse_decode(&mut deserializer);
let api_amount = <Option<u64>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::update_recipient(&*api_that_guard, api_index, api_address_str, api_amount).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_update_recipient_amount_to_max_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbTxBuilder_update_recipient_amount_to_max", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>>::sse_decode(&mut deserializer);
let api_index = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::bdk_wallet::transaction_builder::FrbTxBuilder::update_recipient_amount_to_max(&*api_that_guard, api_index).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__local_output__FrbTxOut_script_pubkey_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxOut_script_pubkey",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbTxOut::script_pubkey(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__local_output__FrbTxOut_value_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbTxOut_value",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::local_output::FrbTxOut::value(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__unleash_client__FrbUnleashClient_fetch_toggles_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbUnleashClient_fetch_toggles", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::unleash_client::FrbUnleashClient::fetch_toggles(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__unleash_client__FrbUnleashClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbUnleashClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::unleash_client::FrbUnleashClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__proton_wallet__crypto__wallet_key__FrbUnlockedWalletKey_to_base64_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbUnlockedWalletKey_to_base64",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::proton_wallet::crypto::wallet_key::FrbUnlockedWalletKey::to_base64(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__crypto__wallet_key__FrbUnlockedWalletKey_to_entropy_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbUnlockedWalletKey_to_entropy",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::proton_wallet::crypto::wallet_key::FrbUnlockedWalletKey::to_entropy(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_clear_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbUserKeyStore_clear_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::user_key_store::FrbUserKeyStore::clear_auth_dart_callback(&*api_that_guard).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbUserKeyStore_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::proton_wallet::storage::user_key_store::FrbUserKeyStore::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_set_get_default_user_key_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbUserKeyStore_set_get_default_user_key_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs_String_Output_proton_user_key_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::user_key_store::FrbUserKeyStore::set_get_default_user_key_callback(&mut *api_that_guard, api_callback).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_set_get_passphrase_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbUserKeyStore_set_get_passphrase_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs_String_Output_String_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::user_key_store::FrbUserKeyStore::set_get_passphrase_callback(&mut *api_that_guard, api_callback).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_clear_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletKeyStore_clear_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::wallet_key_store::FrbWalletKeyStore::clear_auth_dart_callback(&*api_that_guard).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWalletKeyStore_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::proton_wallet::storage::wallet_key_store::FrbWalletKeyStore::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_set_get_wallet_keys_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletKeyStore_set_get_wallet_keys_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs__Output_list_api_wallet_key_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::wallet_key_store::FrbWalletKeyStore::set_get_wallet_keys_callback(&mut *api_that_guard, api_callback).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_set_save_wallet_keys_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletKeyStore_set_save_wallet_keys_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs_list_api_wallet_key_Output_unit_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::wallet_key_store::FrbWalletKeyStore::set_save_wallet_keys_callback(&mut *api_that_guard, api_callback).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_clear_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletMnemonicStore_clear_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::wallet_mnemonic_store::FrbWalletMnemonicStore::clear_auth_dart_callback(&*api_that_guard).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletMnemonicStore_new", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::proton_wallet::storage::wallet_mnemonic_store::FrbWalletMnemonicStore::new())?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_set_get_wallet_keys_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletMnemonicStore_set_get_wallet_keys_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs__Output_list_mnemonic_data_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::wallet_mnemonic_store::FrbWalletMnemonicStore::set_get_wallet_keys_callback(&mut *api_that_guard, api_callback).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_set_save_wallet_keys_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "FrbWalletMnemonicStore_set_save_wallet_keys_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs_list_mnemonic_data_Output_unit_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, ()>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ crate::api::proton_wallet::storage::wallet_mnemonic_store::FrbWalletMnemonicStore::set_save_wallet_keys_callback(&mut *api_that_guard, api_callback).await; })?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_add_account_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_add_account",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            let api_script_type =
                <crate::common::script_type::ScriptType>::sse_decode(&mut deserializer);
            let api_derivation_path = <String>::sse_decode(&mut deserializer);
            let api_connector_factory =
                <crate::api::bdk_wallet::storage::WalletMobileConnectorFactory>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = crate::api::bdk_wallet::wallet::FrbWallet::add_account(
                    &mut *api_that_guard,
                    api_script_type,
                    api_derivation_path,
                    api_connector_factory,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_discover_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_discover_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            let api_api_service = <Arc<ProtonAPIService>>::sse_decode(&mut deserializer);
            let api_connector_factory =
                <crate::api::bdk_wallet::storage::WalletMobileConnectorFactory>::sse_decode(
                    &mut deserializer,
                );
            let api_account_stop_gap = <u32>::sse_decode(&mut deserializer);
            let api_address_stop_gap = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::wallet::FrbWallet::discover_account(
                                &*api_that_guard,
                                api_api_service,
                                api_connector_factory,
                                api_account_stop_gap,
                                api_address_stop_gap,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_get_account_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_get_account",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            let api_derivation_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::bdk_wallet::wallet::FrbWallet::get_account(
                        &mut *api_that_guard,
                        api_derivation_path,
                    ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::bdk_wallet::wallet::FrbWallet::get_balance(
                            &*api_that_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_get_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_get_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::wallet::FrbWallet::get_fingerprint(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_get_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_get_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            let api_account_key = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>,
            >>::sse_decode(&mut deserializer);
            let api_txid = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let mut api_account_key_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_that, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_account_key,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_account_key_guard =
                                        Some(api_account_key.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let api_account_key_guard = api_account_key_guard.unwrap();
                        let output_ok = crate::api::bdk_wallet::wallet::FrbWallet::get_transaction(
                            &*api_that_guard,
                            &*api_account_key_guard,
                            api_txid,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_get_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_get_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
            >>::sse_decode(&mut deserializer);
            let api_pagination =
                <Option<crate::common::pagination::Pagination>>::sse_decode(&mut deserializer);
            let api_sort =
                <Option<crate::common::pagination::SortOrder>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::bdk_wallet::wallet::FrbWallet::get_transactions(
                                &*api_that_guard,
                                api_pagination,
                                api_sort,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__wallet__FrbWallet_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FrbWallet_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::common::network::Network>::sse_decode(&mut deserializer);
            let api_bip39_mnemonic = <String>::sse_decode(&mut deserializer);
            let api_bip38_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok = crate::api::bdk_wallet::wallet::FrbWallet::new(
                    api_network,
                    api_bip39_mnemonic,
                    api_bip38_passphrase,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__invite_client__InviteClient_check_invite_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "InviteClient_check_invite_status", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_decode(&mut deserializer);
let api_invitee_email = <String>::sse_decode(&mut deserializer);
let api_invite_notification_type = <crate::proton_api::invite::InviteNotificationType>::sse_decode(&mut deserializer);
let api_inviter_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::invite_client::InviteClient::check_invite_status(&*api_that_guard, api_invitee_email, api_invite_notification_type, api_inviter_address_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__invite_client__InviteClient_get_remaining_monthly_invitation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "InviteClient_get_remaining_monthly_invitation", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::invite_client::InviteClient::get_remaining_monthly_invitation(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__invite_client__InviteClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "InviteClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::invite_client::InviteClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__invite_client__InviteClient_send_email_integration_invite_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "InviteClient_send_email_integration_invite", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_decode(&mut deserializer);
let api_invitee_email = <String>::sse_decode(&mut deserializer);
let api_inviter_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::invite_client::InviteClient::send_email_integration_invite(&*api_that_guard, api_invitee_email, api_inviter_address_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__invite_client__InviteClient_send_newcomer_invite_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "InviteClient_send_newcomer_invite", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_decode(&mut deserializer);
let api_invitee_email = <String>::sse_decode(&mut deserializer);
let api_inviter_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::invite_client::InviteClient::send_newcomer_invite(&*api_that_guard, api_invitee_email, api_inviter_address_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_create_on_ramp_checkout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_create_on_ramp_checkout", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_amount = <String>::sse_decode(&mut deserializer);
let api_btc_address = <String>::sse_decode(&mut deserializer);
let api_fiat_currency = <String>::sse_decode(&mut deserializer);
let api_payment_method = <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(&mut deserializer);
let api_provider = <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::create_on_ramp_checkout(&*api_that_guard, api_amount, api_btc_address, api_fiat_currency, api_payment_method, api_provider).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_countries_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_countries", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_countries(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_fiat_currencies_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_fiat_currencies", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_fiat_currencies(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_payment_methods_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_payment_methods", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_fiat_symbol = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_payment_methods(&*api_that_guard, api_fiat_symbol).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_public_api_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_public_api_key", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_provider = <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_public_api_key(&*api_that_guard, api_provider).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_quotes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OnRampGatewayClient_get_quotes", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_decode(&mut deserializer);
let api_amount = <f64>::sse_decode(&mut deserializer);
let api_fiat_currency = <String>::sse_decode(&mut deserializer);
let api_pay_method = <Option<crate::proton_api::payment_gateway::PaymentMethod>>::sse_decode(&mut deserializer);
let api_provider = <Option<crate::proton_api::payment_gateway::GatewayProvider>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::get_quotes(&*api_that_guard, api_amount, api_fiat_currency, api_pay_method, api_provider).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnRampGatewayClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::onramp_gateway_client::OnRampGatewayClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__price_graph_client__PriceGraphClient_get_graph_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PriceGraphClient_get_graph_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>>>::sse_decode(&mut deserializer);
let api_fiat_currency = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
let api_timeframe = <crate::proton_api::price_graph::Timeframe>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::price_graph_client::PriceGraphClient::get_graph_data(&*api_that_guard, api_fiat_currency, api_timeframe).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__price_graph_client__PriceGraphClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PriceGraphClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::price_graph_client::PriceGraphClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_address_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_address_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_address_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_arc_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_get_arc",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::api_service::proton_api_service::ProtonAPIService::get_arc(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_bitcoin_addr_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_bitcoin_addr_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_bitcoin_addr_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_block_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_get_block_client",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::api_service::proton_api_service::ProtonAPIService::get_block_client(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_discovery_content_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_discovery_content_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_discovery_content_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_email_integration_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_email_integration_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_email_integration_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_event_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_get_event_client",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::api_service::proton_api_service::ProtonAPIService::get_event_client(
                        &*api_that_guard,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_exchange_rate_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_exchange_rate_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_exchange_rate_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_invite_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_invite_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_invite_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_on_ramp_gateway_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_on_ramp_gateway_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_on_ramp_gateway_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_price_graph_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_price_graph_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_price_graph_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_contacts_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_proton_contacts_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_proton_contacts_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_email_addr_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_proton_email_addr_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_proton_email_addr_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_settings_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_proton_settings_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_proton_settings_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_user_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_proton_user_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_proton_user_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_settings_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_settings_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_settings_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_transaction_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_transaction_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_transaction_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_unleash_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_unleash_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_unleash_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_wallet_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_wallet_client", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_api_service::ProtonAPIService::get_wallet_client(&*api_that_guard))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_get_wallets", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_api_service::ProtonAPIService::get_wallets(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            let api_username = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::proton_api_service::ProtonAPIService::login(
                                &*api_that_guard,
                                api_username,
                                api_password,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_logout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_logout",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, true,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let mut api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::proton_api_service::ProtonAPIService::logout(
                                &mut *api_that_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_env = <String>::sse_decode(&mut deserializer);
            let api_app_version = <String>::sse_decode(&mut deserializer);
            let api_user_agent = <String>::sse_decode(&mut deserializer);
            let api_store = <ProtonWalletAuthStore>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok = crate::api::api_service::proton_api_service::ProtonAPIService::new(
                    api_env,
                    api_app_version,
                    api_user_agent,
                    api_store,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_set_proton_api_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonApiService_set_proton_api", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_api_service::ProtonAPIService::set_proton_api(&mut *api_that_guard)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__api_service__proton_api_service__ProtonApiService_update_auth_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonApiService_update_auth",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            let api_uid = <String>::sse_decode(&mut deserializer);
            let api_access = <String>::sse_decode(&mut deserializer);
            let api_refresh = <String>::sse_decode(&mut deserializer);
            let api_scopes = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::api_service::proton_api_service::ProtonAPIService::update_auth(
                            &mut *api_that_guard,
                            api_uid,
                            api_access,
                            api_refresh,
                            api_scopes,
                        )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__proton_email_addr_client__ProtonEmailAddressClient_get_all_public_keys_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonEmailAddressClient_get_all_public_keys", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>>>::sse_decode(&mut deserializer);
let api_email = <String>::sse_decode(&mut deserializer);
let api_internal_only = <u8>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_email_addr_client::ProtonEmailAddressClient::get_all_public_keys(&*api_that_guard, api_email, api_internal_only).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_email_addr_client__ProtonEmailAddressClient_get_proton_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonEmailAddressClient_get_proton_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_email_addr_client::ProtonEmailAddressClient::get_proton_address(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_email_addr_client__ProtonEmailAddressClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonEmailAddressClient_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                        let mut api_service_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_service, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_service_guard = api_service_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(crate::api::api_service::proton_email_addr_client::ProtonEmailAddressClient::new(&*api_service_guard))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_disable_2fa_totp_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonSettingsClient_disable_2fa_totp", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>>::sse_decode(&mut deserializer);
let api_req = <crate::proton_api::proton_users::ProtonSrpClientProofs>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_settings_client::ProtonSettingsClient::disable_2fa_totp(&*api_that_guard, api_req).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_disable_mnemonic_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonSettingsClient_disable_mnemonic_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>>::sse_decode(&mut deserializer);
let api_proofs = <crate::proton_api::proton_users::ProtonSrpClientProofs>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_settings_client::ProtonSettingsClient::disable_mnemonic_settings(&*api_that_guard, api_proofs).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_enable_2fa_totp_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonSettingsClient_enable_2fa_totp", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>>::sse_decode(&mut deserializer);
let api_req = <crate::proton_api::proton_users::SetTwoFaTOTPRequestBody>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_settings_client::ProtonSettingsClient::enable_2fa_totp(&*api_that_guard, api_req).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_get_mnemonic_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonSettingsClient_get_mnemonic_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_settings_client::ProtonSettingsClient::get_mnemonic_settings(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonSettingsClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_client_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_client,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_client_guard = Some(api_client.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_client_guard = api_client_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::proton_settings_client::ProtonSettingsClient::new(
                            &*api_client_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_reactive_mnemonic_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonSettingsClient_reactive_mnemonic_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>>::sse_decode(&mut deserializer);
let api_req = <crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_settings_client::ProtonSettingsClient::reactive_mnemonic_settings(&*api_that_guard, api_req).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_set_mnemonic_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonSettingsClient_set_mnemonic_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>>::sse_decode(&mut deserializer);
let api_req = <crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_settings_client::ProtonSettingsClient::set_mnemonic_settings(&*api_that_guard, api_req).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_auth_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_get_auth_info", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);
let api_intent = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::get_auth_info(&*api_that_guard, api_intent).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_auth_module_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_get_auth_module", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::get_auth_module(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_user_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_get_user_info", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::get_user_info(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_user_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_get_user_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::get_user_settings(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_lock_sensitive_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_lock_sensitive_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::lock_sensitive_settings(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonUsersClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_client_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_client,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_client_guard = Some(api_client.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_client_guard = api_client_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::proton_users_client::ProtonUsersClient::new(
                            &*api_client_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_unlock_password_change_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_unlock_password_change", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);
let api_proofs = <crate::proton_api::proton_users::ProtonSrpClientProofs>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::unlock_password_change(&*api_that_guard, api_proofs).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__proton_users_client__ProtonUsersClient_unlock_sensitive_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonUsersClient_unlock_sensitive_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_decode(&mut deserializer);
let api_proofs = <crate::proton_api::proton_users::ProtonSrpClientProofs>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::proton_users_client::ProtonUsersClient::unlock_sensitive_settings(&*api_that_guard, api_proofs).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_clear_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_clear_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::clear_auth_dart_callback(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_from_session_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_from_session", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_env = <String>::sse_decode(&mut deserializer);
let api_uid = <String>::sse_decode(&mut deserializer);
let api_access = <String>::sse_decode(&mut deserializer);
let api_refresh = <String>::sse_decode(&mut deserializer);
let api_scopes = <Vec<String>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                     let output_ok = crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::from_session(&api_env, api_uid, api_access, api_refresh, api_scopes)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_logout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_logout", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::logout(&mut *api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ProtonWalletAuthStore_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_env = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                let output_ok =
                    crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::new(
                        &api_env,
                    )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_set_auth_dart_callback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_set_auth_dart_callback", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);
let api_callback = decode_DartFn_Inputs_child_session_Output_String_AnyhowException(<flutter_rust_bridge::DartOpaque>::sse_decode(&mut deserializer));deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref_mut().await),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::set_auth_dart_callback(&mut *api_that_guard, api_callback).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_set_auth_sync_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ProtonWalletAuthStore_set_auth_sync", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>>::sse_decode(&mut deserializer);
let api_uid = <String>::sse_decode(&mut deserializer);
let api_access = <String>::sse_decode(&mut deserializer);
let api_refresh = <String>::sse_decode(&mut deserializer);
let api_scopes = <Vec<String>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_auth_store::ProtonWalletAuthStore::set_auth_sync(&mut *api_that_guard, api_uid, api_access, api_refresh, api_scopes)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_accept_terms_and_conditions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_accept_terms_and_conditions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::accept_terms_and_conditions(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_bitcoin_unit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SettingsClient_bitcoin_unit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>,
            >>::sse_decode(&mut deserializer);
            let api_symbol =
                <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::settings_client::SettingsClient::bitcoin_unit(
                                &*api_that_guard,
                                api_symbol,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__settings_client__SettingsClient_fiat_currency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_fiat_currency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_symbol = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::fiat_currency(&*api_that_guard, api_symbol).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_get_user_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_get_user_settings", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::get_user_settings(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_get_user_wallet_eligibility_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_get_user_wallet_eligibility", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::get_user_wallet_eligibility(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_hide_empty_used_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_hide_empty_used_addresses", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_hide_empty_used_addresses = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::hide_empty_used_addresses(&*api_that_guard, api_hide_empty_used_addresses).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SettingsClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::settings_client::SettingsClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__settings_client__SettingsClient_receive_notification_email_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_receive_notification_email", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_email_type = <crate::proton_api::user_settings::UserReceiveNotificationEmailTypes>::sse_decode(&mut deserializer);
let api_is_enable = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::receive_notification_email(&*api_that_guard, api_email_type, api_is_enable).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__settings_client__SettingsClient_two_fa_threshold_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SettingsClient_two_fa_threshold", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_decode(&mut deserializer);
let api_amount = <u64>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::settings_client::SettingsClient::two_fa_threshold(&*api_that_guard, api_amount).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__transaction_client__TransactionClient_get_mempool_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "TransactionClient_get_mempool_info", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::transaction_client::TransactionClient::get_mempool_info(&*api_that_guard).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__transaction_client__TransactionClient_get_raw_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "TransactionClient_get_raw_transaction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>>::sse_decode(&mut deserializer);
let api_txid = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::transaction_client::TransactionClient::get_raw_transaction(&*api_that_guard, api_txid).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__transaction_client__TransactionClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TransactionClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::transaction_client::TransactionClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__wallet_client__WalletClient_add_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_add_email_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::add_email_address(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_address_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_create_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "WalletClient_create_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>,
            >>::sse_decode(&mut deserializer);
            let api_wallet_req =
                <crate::proton_api::wallet::CreateWalletReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::wallet_client::WalletClient::create_wallet(
                                &*api_that_guard,
                                api_wallet_req,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__wallet_client__WalletClient_create_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_create_wallet_account", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_req = <crate::proton_api::wallet_account::CreateWalletAccountReq>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::create_wallet_account(&*api_that_guard, api_wallet_id, api_req).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_create_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_create_wallet_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_transaction_id = <String>::sse_decode(&mut deserializer);
let api_hashed_transaction_id = <String>::sse_decode(&mut deserializer);
let api_label = <Option<String>>::sse_decode(&mut deserializer);
let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::create_wallet_transactions(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_transaction_id, api_hashed_transaction_id, api_label, api_exchange_rate_id, api_transaction_time).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "WalletClient_delete_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>,
            >>::sse_decode(&mut deserializer);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::wallet_client::WalletClient::delete_wallet(
                                &*api_that_guard,
                                api_wallet_id,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet_account", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::delete_wallet_account(&*api_that_guard, api_wallet_id, api_wallet_account_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet_transaction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::delete_wallet_transaction(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_transaction_private_flag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet_transaction_private_flag", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::delete_wallet_transaction_private_flag(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_transaction_suspicious_flag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_delete_wallet_transaction_suspicious_flag", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::delete_wallet_transaction_suspicious_flag(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_disable_show_wallet_recovery_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_disable_show_wallet_recovery", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::disable_show_wallet_recovery(&*api_that_guard, api_wallet_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_get_wallet_account_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_get_wallet_account_addresses", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::get_wallet_account_addresses(&*api_that_guard, api_wallet_id, api_wallet_account_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_get_wallet_accounts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_get_wallet_accounts", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::get_wallet_accounts(&*api_that_guard, api_wallet_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_get_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_get_wallet_transactions", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <Option<String>>::sse_decode(&mut deserializer);
let api_hashed_txids = <Option<Vec<String>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::get_wallet_transactions(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_hashed_txids).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "WalletClient_get_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::wallet_client::WalletClient::get_wallets(
                                &*api_that_guard,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__wallet_client__WalletClient_migrate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "WalletClient_migrate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>,
            >>::sse_decode(&mut deserializer);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_migrated_wallet =
                <crate::proton_api::wallet::MigratedWallet>::sse_decode(&mut deserializer);
            let api_migrated_wallet_accounts = <Vec<
                crate::proton_api::wallet::MigratedWalletAccount,
            >>::sse_decode(&mut deserializer);
            let api_migrated_wallet_transactions = <Vec<
                crate::proton_api::wallet::MigratedWalletTransaction,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::api_service::wallet_client::WalletClient::migrate(
                                &*api_that_guard,
                                api_wallet_id,
                                api_migrated_wallet,
                                api_migrated_wallet_accounts,
                                api_migrated_wallet_transactions,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__api_service__wallet_client__WalletClient_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "WalletClient_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_service = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_service_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_service,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_service_guard = Some(api_service.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_service_guard = api_service_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::api_service::wallet_client::WalletClient::new(
                            &*api_service_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_service__wallet_client__WalletClient_remove_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_remove_email_address", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_address_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::remove_email_address(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_address_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_set_wallet_transaction_private_flag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_set_wallet_transaction_private_flag", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::set_wallet_transaction_private_flag(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_set_wallet_transaction_suspicious_flag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_set_wallet_transaction_suspicious_flag", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::set_wallet_transaction_suspicious_flag(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_external_wallet_transaction_sender_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_external_wallet_transaction_sender", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);
let api_sender = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_external_wallet_transaction_sender(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id, api_sender).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_account_fiat_currency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_account_fiat_currency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_new_fiat_currency = <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_wallet_account_fiat_currency(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_new_fiat_currency).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_account_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_account_label", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_new_label = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_wallet_account_label(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_new_label).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_account_last_used_index_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_account_last_used_index", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_last_used_index = <u32>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_wallet_account_last_used_index(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_last_used_index).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_accounts_order_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_accounts_order", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_ids = <Vec<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_wallet_accounts_order(&*api_that_guard, api_wallet_id, api_wallet_account_ids).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_name", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_new_name = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_wallet_name(&*api_that_guard, api_wallet_id, api_new_name).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_transaction_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WalletClient_update_wallet_transaction_label", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_decode(&mut deserializer);
let api_wallet_id = <String>::sse_decode(&mut deserializer);
let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
let api_wallet_transaction_id = <String>::sse_decode(&mut deserializer);
let api_label = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move || async move {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = crate::api::api_service::wallet_client::WalletClient::update_wallet_transaction_label(&*api_that_guard, api_wallet_id, api_wallet_account_id, api_wallet_transaction_id, api_label).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__proton_api__add_bitcoin_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_bitcoin_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_bitcoin_addresses =
                <Vec<crate::proton_api::wallet::BitcoinAddress>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::add_bitcoin_addresses(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_bitcoin_addresses,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__add_email_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_email_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_address_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::add_email_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_address_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__create_wallet_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_wallet_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_transaction_id = <String>::sse_decode(&mut deserializer);
            let api_hashed_transaction_id = <String>::sse_decode(&mut deserializer);
            let api_label = <Option<String>>::sse_decode(&mut deserializer);
            let api_exchange_rate_id = <Option<String>>::sse_decode(&mut deserializer);
            let api_transaction_time = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::create_wallet_transactions(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_transaction_id,
                            api_hashed_transaction_id,
                            api_label,
                            api_exchange_rate_id,
                            api_transaction_time,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__fork_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fork",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_app_version = <String>::sse_decode(&mut deserializer);
            let api_user_agent = <String>::sse_decode(&mut deserializer);
            let api_client_child = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::fork(
                            &api_app_version,
                            &api_user_agent,
                            &api_client_child,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__fork_selector_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fork_selector",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client_child = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok =
                            crate::api::proton_api::fork_selector(&api_client_child).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_wallet__crypto__wallet_key__frb_locked_wallet_key_get_armored_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "frb_locked_wallet_key_get_armored",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey::get_armored(
                        &api_that,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__crypto__wallet_key__frb_locked_wallet_key_get_signature_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_locked_wallet_key_get_signature", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey::get_signature(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_sender_body_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_sender_body_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::proton_wallet::features::transition_layer::FrbSenderBody::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__srp__srp_client__frb_srp_client_generate_proofs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "frb_srp_client_generate_proofs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_login_password = <String>::sse_decode(&mut deserializer);
            let api_version = <u8>::sse_decode(&mut deserializer);
            let api_salt = <String>::sse_decode(&mut deserializer);
            let api_modulus = <String>::sse_decode(&mut deserializer);
            let api_server_ephemeral = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                    let output_ok =
                        crate::api::proton_wallet::srp::srp_client::FrbSrpClient::generate_proofs(
                            api_login_password,
                            api_version,
                            api_salt,
                            api_modulus,
                            api_server_ephemeral,
                        )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__proton_wallet__srp__srp_client__frb_srp_client_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "frb_srp_client_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::proton_wallet::srp::srp_client::FrbSrpClient::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_messages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_decrypt_messages", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user_keys = <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_decode(&mut deserializer);
let api_addr_keys = <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_decode(&mut deserializer);
let api_user_key_password = <String>::sse_decode(&mut deserializer);
let api_enc_to_list = <Option<String>>::sse_decode(&mut deserializer);
let api_enc_sender = <Option<String>>::sse_decode(&mut deserializer);
let api_enc_body = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::decrypt_messages(api_user_keys, api_addr_keys, api_user_key_password, api_enc_to_list, api_enc_sender, api_enc_body)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_transaction_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_decrypt_transaction_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user_keys = <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_decode(&mut deserializer);
let api_addr_keys = <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_decode(&mut deserializer);
let api_user_key_password = <String>::sse_decode(&mut deserializer);
let api_enc_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::decrypt_transaction_id(api_user_keys, api_addr_keys, api_user_key_password, api_enc_transaction_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_transaction_ids_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_decrypt_transaction_ids", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user_keys = <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_decode(&mut deserializer);
let api_addr_keys = <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_decode(&mut deserializer);
let api_user_key_password = <String>::sse_decode(&mut deserializer);
let api_enc_transaction_ids = <Vec<crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::decrypt_transaction_ids(api_user_keys, api_addr_keys, api_user_key_password, api_enc_transaction_ids)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_wallet_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_decrypt_wallet_key", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_key = <crate::proton_api::wallet::ApiWalletKey>::sse_decode(&mut deserializer);
let api_user_key = <crate::proton_api::proton_users::ProtonUserKey>::sse_decode(&mut deserializer);
let api_user_key_passphrase = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::decrypt_wallet_key(api_wallet_key, api_user_key, api_user_key_passphrase)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_wallet_key_legacy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_decrypt_wallet_key_legacy", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_encrypted_mnemonic_text = <String>::sse_decode(&mut deserializer);
let api_user_keys = <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_decode(&mut deserializer);
let api_user_key_password = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::decrypt_wallet_key_legacy(api_encrypted_mnemonic_text, api_user_keys, api_user_key_password)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_encrypt_messages_with_keys_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_encrypt_messages_with_keys", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_private_keys = <Vec<String>>::sse_decode(&mut deserializer);
let api_message = <String>::sse_decode(&mut deserializer);
let api_user_keys = <Option<Vec<crate::proton_api::proton_users::ProtonUserKey>>>::sse_decode(&mut deserializer);
let api_addr_keys = <Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>>>::sse_decode(&mut deserializer);
let api_user_key_password = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::encrypt_messages_with_keys(api_private_keys, api_message, api_user_keys, api_addr_keys, api_user_key_password)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_encrypt_messages_with_userkey_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_encrypt_messages_with_userkey", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user_key = <crate::proton_api::proton_users::ProtonUserKey>::sse_decode(&mut deserializer);
let api_message = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::encrypt_messages_with_userkey(api_user_key, api_message)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_encrypt_wallet_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_encrypt_wallet_key", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_key = <FrbUnlockedWalletKey>::sse_decode(&mut deserializer);
let api_user_key = <crate::proton_api::proton_users::ProtonUserKey>::sse_decode(&mut deserializer);
let api_user_key_passphrase = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::encrypt_wallet_key(api_wallet_key, api_user_key, api_user_key_passphrase)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_get_hmac_hashed_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_get_hmac_hashed_string", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base64_secure_key = <String>::sse_decode(&mut deserializer);
let api_transaction_id = <String>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                     let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::get_hmac_hashed_string(&api_base64_secure_key, &api_transaction_id)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_sign", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_user_keys = <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_decode(&mut deserializer);
let api_addr_keys = <crate::proton_api::proton_address::ProtonAddressKey>::sse_decode(&mut deserializer);
let api_user_key_password = <String>::sse_decode(&mut deserializer);
let api_message = <String>::sse_decode(&mut deserializer);
let api_context = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::sign(api_user_keys, api_addr_keys, api_user_key_password, api_message, api_context)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_transition_layer_verify_signature", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_verifier = <Vec<String>>::sse_decode(&mut deserializer);
let api_message = <String>::sse_decode(&mut deserializer);
let api_signature = <String>::sse_decode(&mut deserializer);
let api_context = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, crate::api::errors::BridgeError>((move ||  {
                         let output_ok = crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer::verify_signature(api_verifier, api_message, api_signature, api_context)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_decrypt_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_wallet_key_helper_decrypt", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base64_secure_key = <String>::sse_decode(&mut deserializer);
let api_encrypt_text = <String>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                     let output_ok = crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper::decrypt(api_base64_secure_key, api_encrypt_text)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_encrypt_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_wallet_key_helper_encrypt", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base64_secure_key = <String>::sse_decode(&mut deserializer);
let api_plaintext = <String>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                     let output_ok = crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper::encrypt(api_base64_secure_key, api_plaintext)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_generate_secret_key_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_wallet_key_helper_generate_secret_key", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper::generate_secret_key())?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_generate_secret_key_as_base64_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_wallet_key_helper_generate_secret_key_as_base64", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper::generate_secret_key_as_base64())?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_get_secure_random_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_wallet_key_helper_get_secure_random", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_length = <usize>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper::get_secure_random(api_length))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_restore_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "frb_wallet_key_helper_restore", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base64_secure_key = <String>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, crate::api::errors::BridgeError>((move || {
                     let output_ok = crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper::restore(&api_base64_secure_key)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__proton_api__get_exchange_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_exchange_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_fiat_currency =
                <crate::proton_api::user_settings::FiatCurrency>::sse_decode(&mut deserializer);
            let api_time = <Option<u64>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok =
                            crate::api::proton_api::get_exchange_rate(api_fiat_currency, api_time)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__get_proton_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_proton_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::get_proton_address().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__get_wallet_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallet_bitcoin_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_only_request = <Option<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::get_wallet_bitcoin_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_only_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__init__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__logger__init_rust_logging_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_rust_logging",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);
            let api_file_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::logger::init_rust_logging(&api_file_path, &api_file_name);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__panic_hook__initialize_panic_hook_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "initialize_panic_hook",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_stream_sink =
                <StreamSink<String, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::panic_hook::initialize_panic_hook(api_stream_sink);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__proton_api__lookup_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lookup_bitcoin_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_email = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok =
                            crate::api::proton_api::lookup_bitcoin_address(api_email).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__proton_api__update_bitcoin_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_bitcoin_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_id = <String>::sse_decode(&mut deserializer);
            let api_wallet_account_bitcoin_address_id = <String>::sse_decode(&mut deserializer);
            let api_bitcoin_address =
                <crate::proton_api::wallet::BitcoinAddress>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::errors::BridgeError>(
                    (move || async move {
                        let output_ok = crate::api::proton_api::update_bitcoin_address(
                            api_wallet_id,
                            api_wallet_account_id,
                            api_wallet_account_bitcoin_address_id,
                            api_bitcoin_address,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__bdk_wallet__storage__wallet_mobile_connector_factory_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_mobile_connector_factory_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_folder_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::bdk_wallet::storage::WalletMobileConnectorFactory::new(
                        api_folder_path,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let ApiContactEmails = None::<crate::proton_api::contacts::ApiContactEmails>.unwrap();
        let _: String = ApiContactEmails.ID;
        let _: String = ApiContactEmails.Name;
        let _: String = ApiContactEmails.Email;
        let _: String = ApiContactEmails.CanonicalEmail;
        let _: u32 = ApiContactEmails.IsProton;
    }
    {
        let ApiCountry = None::<crate::proton_api::payment_gateway::ApiCountry>.unwrap();
        let _: String = ApiCountry.Code;
        let _: String = ApiCountry.FiatCurrency;
        let _: String = ApiCountry.Name;
    }
    {
        let ApiEmailAddress = None::<crate::proton_api::wallet_account::ApiEmailAddress>.unwrap();
        let _: String = ApiEmailAddress.ID;
        let _: String = ApiEmailAddress.Email;
    }
    {
        let ApiMnemonicUserKey =
            None::<crate::proton_api::proton_users::ApiMnemonicUserKey>.unwrap();
        let _: String = ApiMnemonicUserKey.ID;
        let _: String = ApiMnemonicUserKey.PrivateKey;
        let _: String = ApiMnemonicUserKey.Salt;
    }
    {
        let ApiSimpleFiatCurrency =
            None::<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>.unwrap();
        let _: String = ApiSimpleFiatCurrency.Name;
        let _: String = ApiSimpleFiatCurrency.Symbol;
        let _: Option<String> = ApiSimpleFiatCurrency.MinimumAmount;
    }
    {
        let ApiWallet = None::<crate::proton_api::wallet::ApiWallet>.unwrap();
        let _: String = ApiWallet.ID;
        let _: String = ApiWallet.Name;
        let _: u8 = ApiWallet.IsImported;
        let _: u8 = ApiWallet.Priority;
        let _: u8 = ApiWallet.Type;
        let _: u8 = ApiWallet.HasPassphrase;
        let _: u8 = ApiWallet.Status;
        let _: Option<String> = ApiWallet.Mnemonic;
        let _: Option<String> = ApiWallet.Fingerprint;
        let _: Option<String> = ApiWallet.PublicKey;
        let _: Option<u8> = ApiWallet.MigrationRequired;
        let _: Option<u8> = ApiWallet.Legacy;
    }
    {
        let ApiWalletAccount = None::<crate::proton_api::wallet_account::ApiWalletAccount>.unwrap();
        let _: String = ApiWalletAccount.ID;
        let _: String = ApiWalletAccount.WalletID;
        let _: crate::proton_api::user_settings::FiatCurrency = ApiWalletAccount.FiatCurrency;
        let _: String = ApiWalletAccount.DerivationPath;
        let _: String = ApiWalletAccount.Label;
        let _: u32 = ApiWalletAccount.LastUsedIndex;
        let _: u32 = ApiWalletAccount.PoolSize;
        let _: u32 = ApiWalletAccount.Priority;
        let _: u8 = ApiWalletAccount.ScriptType;
        let _: Option<u32> = ApiWalletAccount.StopGap;
        let _: Vec<crate::proton_api::wallet_account::ApiEmailAddress> = ApiWalletAccount.Addresses;
    }
    {
        let ApiWalletBitcoinAddress =
            None::<crate::proton_api::wallet::ApiWalletBitcoinAddress>.unwrap();
        let _: String = ApiWalletBitcoinAddress.ID;
        let _: String = ApiWalletBitcoinAddress.WalletID;
        let _: String = ApiWalletBitcoinAddress.WalletAccountID;
        let _: u8 = ApiWalletBitcoinAddress.Fetched;
        let _: u8 = ApiWalletBitcoinAddress.Used;
        let _: Option<String> = ApiWalletBitcoinAddress.BitcoinAddress;
        let _: Option<String> = ApiWalletBitcoinAddress.BitcoinAddressSignature;
        let _: Option<u64> = ApiWalletBitcoinAddress.BitcoinAddressIndex;
    }
    {
        let ApiWalletData = None::<crate::proton_api::wallet::ApiWalletData>.unwrap();
        let _: crate::proton_api::wallet::ApiWallet = ApiWalletData.Wallet;
        let _: crate::proton_api::wallet::ApiWalletKey = ApiWalletData.WalletKey;
        let _: crate::proton_api::wallet_settings::ApiWalletSettings = ApiWalletData.WalletSettings;
    }
    {
        let ApiWalletKey = None::<crate::proton_api::wallet::ApiWalletKey>.unwrap();
        let _: String = ApiWalletKey.WalletID;
        let _: String = ApiWalletKey.UserKeyID;
        let _: String = ApiWalletKey.WalletKey;
        let _: String = ApiWalletKey.WalletKeySignature;
    }
    {
        let ApiWalletSettings =
            None::<crate::proton_api::wallet_settings::ApiWalletSettings>.unwrap();
        let _: String = ApiWalletSettings.WalletID;
        let _: u8 = ApiWalletSettings.HideAccounts;
        let _: Option<String> = ApiWalletSettings.InvoiceDefaultDescription;
        let _: u64 = ApiWalletSettings.InvoiceExpirationTime;
        let _: u64 = ApiWalletSettings.MaxChannelOpeningFee;
        let _: Option<bool> = ApiWalletSettings.ShowWalletRecovery;
    }
    {
        let ApiWalletUserSettings =
            None::<crate::proton_api::user_settings::ApiWalletUserSettings>.unwrap();
        let _: crate::proton_api::user_settings::BitcoinUnit = ApiWalletUserSettings.BitcoinUnit;
        let _: crate::proton_api::user_settings::FiatCurrency = ApiWalletUserSettings.FiatCurrency;
        let _: u8 = ApiWalletUserSettings.HideEmptyUsedAddresses;
        let _: Option<u64> = ApiWalletUserSettings.TwoFactorAmountThreshold;
        let _: Option<u8> = ApiWalletUserSettings.ReceiveInviterNotification;
        let _: Option<u8> = ApiWalletUserSettings.ReceiveEmailIntegrationNotification;
        let _: Option<u8> = ApiWalletUserSettings.ReceiveTransactionNotification;
        let _: Option<u8> = ApiWalletUserSettings.WalletCreated;
        let _: Option<u8> = ApiWalletUserSettings.AcceptTermsAndConditions;
    }
    {
        let BroadcastMessage = None::<crate::common::broadcast_message::BroadcastMessage>.unwrap();
        let _: String = BroadcastMessage.DataPacket;
        let _: std::collections::HashMap<String, String> = BroadcastMessage.KeyPackets;
    }
    {
        let ChildSession = None::<crate::proton_api::auth_credential::ChildSession>.unwrap();
        let _: String = ChildSession.session_id;
        let _: String = ChildSession.access_token;
        let _: String = ChildSession.refresh_token;
        let _: Vec<String> = ChildSession.scopes;
    }
    match None::<crate::common::confirmation_time::ConfirmationTime>.unwrap() {
        crate::common::confirmation_time::ConfirmationTime::Confirmed { height, time } => {
            let _: u32 = height;
            let _: u64 = time;
        }
        crate::common::confirmation_time::ConfirmationTime::Unconfirmed { last_seen } => {
            let _: u64 = last_seen;
        }
    }
    {
        let Content = None::<crate::proton_api::discovery_content::Content>.unwrap();
        let _: String = Content.Title;
        let _: String = Content.Link;
        let _: String = Content.Description;
        let _: i64 = Content.PubDate;
        let _: String = Content.Author;
        let _: String = Content.Category;
    }
    {
        let DataPoint = None::<crate::proton_api::price_graph::DataPoint>.unwrap();
        let _: u64 = DataPoint.ExchangeRate;
        let _: u8 = DataPoint.Cents;
        let _: u64 = DataPoint.Timestamp;
    }
    {
        let EmailSettings = None::<crate::proton_api::proton_users::EmailSettings>.unwrap();
        let _: Option<String> = EmailSettings.Value;
        let _: u32 = EmailSettings.Status;
        let _: u32 = EmailSettings.Notify;
        let _: u32 = EmailSettings.Reset;
    }
    {
        let FlagsSettings = None::<crate::proton_api::proton_users::FlagsSettings>.unwrap();
    }
    {
        let GetAuthInfoResponseBody =
            None::<crate::proton_api::proton_users::GetAuthInfoResponseBody>.unwrap();
        let _: u32 = GetAuthInfoResponseBody.Code;
        let _: String = GetAuthInfoResponseBody.Modulus;
        let _: String = GetAuthInfoResponseBody.ServerEphemeral;
        let _: u8 = GetAuthInfoResponseBody.Version;
        let _: String = GetAuthInfoResponseBody.Salt;
        let _: String = GetAuthInfoResponseBody.SRPSession;
        let _: crate::proton_api::proton_users::TwoFA = GetAuthInfoResponseBody.two_fa;
    }
    {
        let GetAuthModulusResponse =
            None::<crate::proton_api::proton_users::GetAuthModulusResponse>.unwrap();
        let _: u32 = GetAuthModulusResponse.Code;
        let _: String = GetAuthModulusResponse.Modulus;
        let _: String = GetAuthModulusResponse.ModulusID;
    }
    {
        let HighSecuritySettings =
            None::<crate::proton_api::proton_users::HighSecuritySettings>.unwrap();
        let _: u32 = HighSecuritySettings.Eligible;
        let _: u32 = HighSecuritySettings.Value;
    }
    {
        let MempoolInfo = None::<crate::proton_api::transaction::MempoolInfo>.unwrap();
        let _: u8 = MempoolInfo.Loaded;
        let _: u32 = MempoolInfo.Size;
        let _: u32 = MempoolInfo.Bytes;
        let _: u32 = MempoolInfo.Usage;
        let _: u32 = MempoolInfo.MaxMempool;
        let _: f32 = MempoolInfo.MempoolMinFee;
        let _: f32 = MempoolInfo.MinRelayTxFee;
        let _: f32 = MempoolInfo.IncrementalRelayFee;
        let _: u8 = MempoolInfo.UnbroadcastCount;
        let _: u8 = MempoolInfo.FullRbf;
    }
    {
        let MigratedWallet = None::<crate::proton_api::wallet::MigratedWallet>.unwrap();
        let _: String = MigratedWallet.Name;
        let _: String = MigratedWallet.UserKeyID;
        let _: String = MigratedWallet.WalletKey;
        let _: String = MigratedWallet.WalletKeySignature;
        let _: String = MigratedWallet.Mnemonic;
        let _: String = MigratedWallet.Fingerprint;
    }
    {
        let MigratedWalletAccount =
            None::<crate::proton_api::wallet::MigratedWalletAccount>.unwrap();
        let _: String = MigratedWalletAccount.ID;
        let _: String = MigratedWalletAccount.Label;
    }
    {
        let MigratedWalletTransaction =
            None::<crate::proton_api::wallet::MigratedWalletTransaction>.unwrap();
        let _: String = MigratedWalletTransaction.ID;
        let _: String = MigratedWalletTransaction.WalletAccountID;
        let _: Option<String> = MigratedWalletTransaction.HashedTransactionID;
        let _: Option<String> = MigratedWalletTransaction.Label;
    }
    {
        let MnemonicAuth = None::<crate::proton_api::proton_users::MnemonicAuth>.unwrap();
        let _: u32 = MnemonicAuth.Version;
        let _: String = MnemonicAuth.ModulusID;
        let _: String = MnemonicAuth.Salt;
        let _: String = MnemonicAuth.Verifier;
    }
    {
        let MnemonicUserKey = None::<crate::proton_api::proton_users::MnemonicUserKey>.unwrap();
        let _: String = MnemonicUserKey.ID;
        let _: String = MnemonicUserKey.PrivateKey;
    }
    {
        let Pagination = None::<crate::common::pagination::Pagination>.unwrap();
        let _: usize = Pagination.skip;
        let _: usize = Pagination.take;
    }
    {
        let PasswordSettings = None::<crate::proton_api::proton_users::PasswordSettings>.unwrap();
    }
    {
        let PhoneSettings = None::<crate::proton_api::proton_users::PhoneSettings>.unwrap();
    }
    {
        let PriceGraph = None::<crate::proton_api::price_graph::PriceGraph>.unwrap();
        let _: crate::proton_api::user_settings::FiatCurrency = PriceGraph.FiatCurrency;
        let _: crate::proton_api::user_settings::BitcoinUnit = PriceGraph.BitcoinUnit;
        let _: Vec<crate::proton_api::price_graph::DataPoint> = PriceGraph.GraphData;
    }
    {
        let ProtonSrpClientProofs =
            None::<crate::proton_api::proton_users::ProtonSrpClientProofs>.unwrap();
        let _: String = ProtonSrpClientProofs.ClientEphemeral;
        let _: String = ProtonSrpClientProofs.ClientProof;
        let _: String = ProtonSrpClientProofs.SRPSession;
        let _: Option<String> = ProtonSrpClientProofs.TwoFactorCode;
    }
    {
        let ProtonUser = None::<crate::proton_api::proton_users::ProtonUser>.unwrap();
        let _: String = ProtonUser.ID;
        let _: Option<String> = ProtonUser.Name;
        let _: u64 = ProtonUser.UsedSpace;
        let _: String = ProtonUser.Currency;
        let _: u32 = ProtonUser.Credit;
        let _: u64 = ProtonUser.CreateTime;
        let _: u64 = ProtonUser.MaxSpace;
        let _: u64 = ProtonUser.MaxUpload;
        let _: u32 = ProtonUser.Role;
        let _: u32 = ProtonUser.Private;
        let _: u32 = ProtonUser.Subscribed;
        let _: u32 = ProtonUser.Services;
        let _: u32 = ProtonUser.Delinquent;
        let _: Option<String> = ProtonUser.OrganizationPrivateKey;
        let _: String = ProtonUser.Email;
        let _: Option<String> = ProtonUser.DisplayName;
        let _: Option<Vec<crate::proton_api::proton_users::ProtonUserKey>> = ProtonUser.Keys;
        let _: u32 = ProtonUser.MnemonicStatus;
    }
    {
        let ProtonUserKey = None::<crate::proton_api::proton_users::ProtonUserKey>.unwrap();
        let _: String = ProtonUserKey.ID;
        let _: u32 = ProtonUserKey.Version;
        let _: String = ProtonUserKey.PrivateKey;
        let _: Option<String> = ProtonUserKey.RecoverySecret;
        let _: Option<String> = ProtonUserKey.RecoverySecretSignature;
        let _: Option<String> = ProtonUserKey.Token;
        let _: String = ProtonUserKey.Fingerprint;
        let _: u32 = ProtonUserKey.Primary;
        let _: u32 = ProtonUserKey.Active;
    }
    {
        let ProtonUserSettings =
            None::<crate::proton_api::proton_users::ProtonUserSettings>.unwrap();
        let _: crate::proton_api::proton_users::EmailSettings = ProtonUserSettings.Email;
        let _: Option<crate::proton_api::proton_users::PasswordSettings> =
            ProtonUserSettings.Password;
        let _: Option<crate::proton_api::proton_users::PhoneSettings> = ProtonUserSettings.Phone;
        let _: Option<crate::proton_api::proton_users::TwoFASettings> = ProtonUserSettings.two_fa;
        let _: u32 = ProtonUserSettings.News;
        let _: String = ProtonUserSettings.Locale;
        let _: u32 = ProtonUserSettings.LogAuth;
        let _: String = ProtonUserSettings.InvoiceText;
        let _: u32 = ProtonUserSettings.Density;
        let _: u32 = ProtonUserSettings.WeekStart;
        let _: u32 = ProtonUserSettings.DateFormat;
        let _: u32 = ProtonUserSettings.TimeFormat;
        let _: u32 = ProtonUserSettings.Welcome;
        let _: u32 = ProtonUserSettings.WelcomeFlag;
        let _: u32 = ProtonUserSettings.EarlyAccess;
        let _: Option<crate::proton_api::proton_users::FlagsSettings> = ProtonUserSettings.Flags;
        let _: Option<crate::proton_api::proton_users::ReferralSettings> =
            ProtonUserSettings.Referral;
        let _: Option<u32> = ProtonUserSettings.DeviceRecovery;
        let _: u32 = ProtonUserSettings.Telemetry;
        let _: u32 = ProtonUserSettings.CrashReports;
        let _: u32 = ProtonUserSettings.HideSidePanel;
        let _: Option<crate::proton_api::proton_users::HighSecuritySettings> =
            ProtonUserSettings.HighSecurity;
        let _: u32 = ProtonUserSettings.SessionAccountRecovery;
    }
    {
        let Quote = None::<crate::proton_api::payment_gateway::Quote>.unwrap();
        let _: String = Quote.BitcoinAmount;
        let _: String = Quote.FiatAmount;
        let _: String = Quote.FiatCurrencySymbol;
        let _: String = Quote.NetworkFee;
        let _: String = Quote.PaymentGatewayFee;
        let _: crate::proton_api::payment_gateway::PaymentMethod = Quote.PaymentMethod;
        let _: Option<String> = Quote.PurchaseAmount;
        let _: Option<String> = Quote.PaymentProcessingFee;
        let _: Option<String> = Quote.OrderID;
    }
    {
        let RecommendedFees = None::<crate::common::blockchain::RecommendedFees>.unwrap();
        let _: u8 = RecommendedFees.FastestFee;
        let _: u8 = RecommendedFees.HalfHourFee;
        let _: u8 = RecommendedFees.HourFee;
        let _: u8 = RecommendedFees.EconomyFee;
        let _: u8 = RecommendedFees.MinimumFee;
    }
    {
        let ReferralSettings = None::<crate::proton_api::proton_users::ReferralSettings>.unwrap();
    }
    {
        let RemainingMonthlyInvitations =
            None::<crate::proton_api::invite::RemainingMonthlyInvitations>.unwrap();
        let _: u8 = RemainingMonthlyInvitations.Used;
        let _: u8 = RemainingMonthlyInvitations.Available;
    }
    {
        let SetTwoFaTOTPRequestBody =
            None::<crate::proton_api::proton_users::SetTwoFaTOTPRequestBody>.unwrap();
        let _: String = SetTwoFaTOTPRequestBody.TOTPConfirmation;
        let _: String = SetTwoFaTOTPRequestBody.TOTPSharedSecret;
    }
    {
        let SetTwoFaTOTPResponseBody =
            None::<crate::proton_api::proton_users::SetTwoFaTOTPResponseBody>.unwrap();
        let _: u32 = SetTwoFaTOTPResponseBody.Code;
        let _: Vec<String> = SetTwoFaTOTPResponseBody.TwoFactorRecoveryCodes;
        let _: crate::proton_api::proton_users::ProtonUserSettings =
            SetTwoFaTOTPResponseBody.UserSettings;
    }
    {
        let SRPProofB64 = None::<crate::srp::proofs::SRPProofB64>.unwrap();
        let _: String = SRPProofB64.client_ephemeral;
        let _: String = SRPProofB64.client_proof;
        let _: String = SRPProofB64.expected_server_proof;
    }
    match None::<crate::common::transaction_time::TransactionTime>.unwrap() {
        crate::common::transaction_time::TransactionTime::Confirmed { confirmation_time } => {
            let _: u64 = confirmation_time;
        }
        crate::common::transaction_time::TransactionTime::Unconfirmed { last_seen } => {
            let _: u64 = last_seen;
        }
    }
    {
        let TwoFA = None::<crate::proton_api::proton_users::TwoFA>.unwrap();
        let _: u8 = TwoFA.Enabled;
    }
    {
        let TwoFASettings = None::<crate::proton_api::proton_users::TwoFASettings>.unwrap();
        let _: u32 = TwoFASettings.Enabled;
        let _: u32 = TwoFASettings.Allowed;
    }
    {
        let UnleashResponse = None::<crate::proton_api::unleash::UnleashResponse>.unwrap();
        let _: u16 = UnleashResponse.status_code;
        let _: Vec<u8> = UnleashResponse.body;
    }
    {
        let UpdateMnemonicSettingsRequestBody =
            None::<crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody>.unwrap();
        let _: Vec<crate::proton_api::proton_users::MnemonicUserKey> =
            UpdateMnemonicSettingsRequestBody.MnemonicUserKeys;
        let _: String = UpdateMnemonicSettingsRequestBody.MnemonicSalt;
        let _: crate::proton_api::proton_users::MnemonicAuth =
            UpdateMnemonicSettingsRequestBody.MnemonicAuth;
    }
};

// Section: related_funcs

fn decode_DartFn_Inputs_String_Output_String_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(String) -> flutter_rust_bridge::DartFnFuture<String> {
    use flutter_rust_bridge::IntoDart;

    async fn body(dart_opaque: flutter_rust_bridge::DartOpaque, arg0: String) -> String {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<String>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: String| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
fn decode_DartFn_Inputs_String_Output_proton_user_key_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(String) -> flutter_rust_bridge::DartFnFuture<crate::proton_api::proton_users::ProtonUserKey>
{
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: String,
    ) -> crate::proton_api::proton_users::ProtonUserKey {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(
                <crate::proton_api::proton_users::ProtonUserKey>::sse_decode(&mut deserializer),
            ),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: String| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
fn decode_DartFn_Inputs__Output_list_api_wallet_key_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn() -> flutter_rust_bridge::DartFnFuture<Vec<crate::proton_api::wallet::ApiWalletKey>> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
    ) -> Vec<crate::proton_api::wallet::ApiWalletKey> {
        let args = vec![];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(
                <Vec<crate::proton_api::wallet::ApiWalletKey>>::sse_decode(&mut deserializer),
            ),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move || {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(dart_opaque.clone()))
    }
}
fn decode_DartFn_Inputs__Output_list_mnemonic_data_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn() -> flutter_rust_bridge::DartFnFuture<
    Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData>,
> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
    ) -> Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData> {
        let args = vec![];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<Vec<
                crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData,
            >>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move || {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(dart_opaque.clone()))
    }
}
fn decode_DartFn_Inputs_child_session_Output_String_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(crate::proton_api::auth_credential::ChildSession) -> flutter_rust_bridge::DartFnFuture<String>
{
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: crate::proton_api::auth_credential::ChildSession,
    ) -> String {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<String>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: crate::proton_api::auth_credential::ChildSession| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
fn decode_DartFn_Inputs_list_api_wallet_key_Output_unit_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(Vec<crate::proton_api::wallet::ApiWalletKey>) -> flutter_rust_bridge::DartFnFuture<()>
{
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: Vec<crate::proton_api::wallet::ApiWalletKey>,
    ) -> () {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<()>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: Vec<crate::proton_api::wallet::ApiWalletKey>| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
fn decode_DartFn_Inputs_list_mnemonic_data_Output_unit_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(
    Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData>,
) -> flutter_rust_bridge::DartFnFuture<()> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData>,
    ) -> () {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<()>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData>| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for AddressBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ApiTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Arc<ProtonAPIService> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BlockClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ContactsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for DiscoveredAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for DiscoveryContentClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EmailIntegrationClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EventClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ExchangeRateClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbAppDatabase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbBackupMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbBlockchainClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbDerivationPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbDetailledTxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbDetailledTxOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbLocalOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbPaymentLink {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbProtonRecovery {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbProtonWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbSequence {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbTransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbTxBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbTxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbUnleashClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbUnlockedWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbUserKeyStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbWalletKeyStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for FrbWalletMnemonicStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for InviteClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OnRampGatewayClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PriceGraphClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ProtonAPIService {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ProtonEmailAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ProtonSettingsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ProtonUsersClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ProtonWalletAuthStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SettingsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TransactionClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for WalletClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for bdkTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_dart_opaque(inner) };
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashMap<String, f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, f64)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiCountry>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::PaymentMethod>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::Quote>,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::proton_wallet::db::model::account_model::AccountModel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_accountId = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_derivationPath = <String>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_scriptType = <u32>::sse_decode(deserializer);
        let mut var_createTime = <u64>::sse_decode(deserializer);
        let mut var_modifyTime = <u64>::sse_decode(deserializer);
        let mut var_fiatCurrency = <String>::sse_decode(deserializer);
        let mut var_priority = <u32>::sse_decode(deserializer);
        let mut var_lastUsedIndex = <u32>::sse_decode(deserializer);
        let mut var_poolSize = <u32>::sse_decode(deserializer);
        return crate::proton_wallet::db::model::account_model::AccountModel {
            id: var_id,
            account_id: var_accountId,
            wallet_id: var_walletId,
            derivation_path: var_derivationPath,
            label: var_label,
            script_type: var_scriptType,
            create_time: var_createTime,
            modify_time: var_modifyTime,
            fiat_currency: var_fiatCurrency,
            priority: var_priority,
            last_used_index: var_lastUsedIndex,
            pool_size: var_poolSize,
        };
    }
}

impl SseDecode for crate::proton_api::proton_address::AllKeyAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_flags = <u32>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        let mut var_source = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_address::AllKeyAddressKey {
            flags: var_flags,
            public_key: var_publicKey,
            source: var_source,
        };
    }
}

impl SseDecode for crate::proton_api::contacts::ApiContactEmails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_canonicalEmail = <String>::sse_decode(deserializer);
        let mut var_isProton = <u32>::sse_decode(deserializer);
        return crate::proton_api::contacts::ApiContactEmails {
            ID: var_id,
            Name: var_name,
            Email: var_email,
            CanonicalEmail: var_canonicalEmail,
            IsProton: var_isProton,
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::ApiCountry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_fiatCurrency = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::proton_api::payment_gateway::ApiCountry {
            Code: var_code,
            FiatCurrency: var_fiatCurrency,
            Name: var_name,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_account::ApiEmailAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet_account::ApiEmailAddress {
            ID: var_id,
            Email: var_email,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::ApiMnemonicUserKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_privateKey = <String>::sse_decode(deserializer);
        let mut var_salt = <String>::sse_decode(deserializer);
        return crate::proton_api::proton_users::ApiMnemonicUserKey {
            ID: var_id,
            PrivateKey: var_privateKey,
            Salt: var_salt,
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::ApiSimpleFiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_minimumAmount = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::payment_gateway::ApiSimpleFiatCurrency {
            Name: var_name,
            Symbol: var_symbol,
            MinimumAmount: var_minimumAmount,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_isImported = <u8>::sse_decode(deserializer);
        let mut var_priority = <u8>::sse_decode(deserializer);
        let mut var_type = <u8>::sse_decode(deserializer);
        let mut var_hasPassphrase = <u8>::sse_decode(deserializer);
        let mut var_status = <u8>::sse_decode(deserializer);
        let mut var_mnemonic = <Option<String>>::sse_decode(deserializer);
        let mut var_fingerprint = <Option<String>>::sse_decode(deserializer);
        let mut var_publicKey = <Option<String>>::sse_decode(deserializer);
        let mut var_migrationRequired = <Option<u8>>::sse_decode(deserializer);
        let mut var_legacy = <Option<u8>>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWallet {
            ID: var_id,
            Name: var_name,
            IsImported: var_isImported,
            Priority: var_priority,
            Type: var_type,
            HasPassphrase: var_hasPassphrase,
            Status: var_status,
            Mnemonic: var_mnemonic,
            Fingerprint: var_fingerprint,
            PublicKey: var_publicKey,
            MigrationRequired: var_migrationRequired,
            Legacy: var_legacy,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_account::ApiWalletAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_derivationPath = <String>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_lastUsedIndex = <u32>::sse_decode(deserializer);
        let mut var_poolSize = <u32>::sse_decode(deserializer);
        let mut var_priority = <u32>::sse_decode(deserializer);
        let mut var_scriptType = <u8>::sse_decode(deserializer);
        let mut var_stopGap = <Option<u32>>::sse_decode(deserializer);
        let mut var_addresses =
            <Vec<crate::proton_api::wallet_account::ApiEmailAddress>>::sse_decode(deserializer);
        return crate::proton_api::wallet_account::ApiWalletAccount {
            ID: var_id,
            WalletID: var_walletId,
            FiatCurrency: var_fiatCurrency,
            DerivationPath: var_derivationPath,
            Label: var_label,
            LastUsedIndex: var_lastUsedIndex,
            PoolSize: var_poolSize,
            Priority: var_priority,
            ScriptType: var_scriptType,
            StopGap: var_stopGap,
            Addresses: var_addresses,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWalletBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_walletAccountId = <String>::sse_decode(deserializer);
        let mut var_fetched = <u8>::sse_decode(deserializer);
        let mut var_used = <u8>::sse_decode(deserializer);
        let mut var_bitcoinAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_bitcoinAddressSignature = <Option<String>>::sse_decode(deserializer);
        let mut var_bitcoinAddressIndex = <Option<u64>>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWalletBitcoinAddress {
            ID: var_id,
            WalletID: var_walletId,
            WalletAccountID: var_walletAccountId,
            Fetched: var_fetched,
            Used: var_used,
            BitcoinAddress: var_bitcoinAddress,
            BitcoinAddressSignature: var_bitcoinAddressSignature,
            BitcoinAddressIndex: var_bitcoinAddressIndex,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWalletData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_wallet = <crate::proton_api::wallet::ApiWallet>::sse_decode(deserializer);
        let mut var_walletKey = <crate::proton_api::wallet::ApiWalletKey>::sse_decode(deserializer);
        let mut var_walletSettings =
            <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWalletData {
            Wallet: var_wallet,
            WalletKey: var_walletKey,
            WalletSettings: var_walletSettings,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::ApiWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_walletKey = <String>::sse_decode(deserializer);
        let mut var_walletKeySignature = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet::ApiWalletKey {
            WalletID: var_walletId,
            UserKeyID: var_userKeyId,
            WalletKey: var_walletKey,
            WalletKeySignature: var_walletKeySignature,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_settings::ApiWalletSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_hideAccounts = <u8>::sse_decode(deserializer);
        let mut var_invoiceDefaultDescription = <Option<String>>::sse_decode(deserializer);
        let mut var_invoiceExpirationTime = <u64>::sse_decode(deserializer);
        let mut var_maxChannelOpeningFee = <u64>::sse_decode(deserializer);
        let mut var_showWalletRecovery = <Option<bool>>::sse_decode(deserializer);
        return crate::proton_api::wallet_settings::ApiWalletSettings {
            WalletID: var_walletId,
            HideAccounts: var_hideAccounts,
            InvoiceDefaultDescription: var_invoiceDefaultDescription,
            InvoiceExpirationTime: var_invoiceExpirationTime,
            MaxChannelOpeningFee: var_maxChannelOpeningFee,
            ShowWalletRecovery: var_showWalletRecovery,
        };
    }
}

impl SseDecode for crate::proton_api::user_settings::ApiWalletUserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinUnit =
            <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(deserializer);
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_hideEmptyUsedAddresses = <u8>::sse_decode(deserializer);
        let mut var_twoFactorAmountThreshold = <Option<u64>>::sse_decode(deserializer);
        let mut var_receiveInviterNotification = <Option<u8>>::sse_decode(deserializer);
        let mut var_receiveEmailIntegrationNotification = <Option<u8>>::sse_decode(deserializer);
        let mut var_receiveTransactionNotification = <Option<u8>>::sse_decode(deserializer);
        let mut var_walletCreated = <Option<u8>>::sse_decode(deserializer);
        let mut var_acceptTermsAndConditions = <Option<u8>>::sse_decode(deserializer);
        return crate::proton_api::user_settings::ApiWalletUserSettings {
            BitcoinUnit: var_bitcoinUnit,
            FiatCurrency: var_fiatCurrency,
            HideEmptyUsedAddresses: var_hideEmptyUsedAddresses,
            TwoFactorAmountThreshold: var_twoFactorAmountThreshold,
            ReceiveInviterNotification: var_receiveInviterNotification,
            ReceiveEmailIntegrationNotification: var_receiveEmailIntegrationNotification,
            ReceiveTransactionNotification: var_receiveTransactionNotification,
            WalletCreated: var_walletCreated,
            AcceptTermsAndConditions: var_acceptTermsAndConditions,
        };
    }
}

impl SseDecode for crate::proton_api::auth_credential::AuthCredential {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sessionId = <String>::sse_decode(deserializer);
        let mut var_userId = <String>::sse_decode(deserializer);
        let mut var_accessToken = <String>::sse_decode(deserializer);
        let mut var_refreshToken = <String>::sse_decode(deserializer);
        let mut var_eventId = <String>::sse_decode(deserializer);
        let mut var_userMail = <String>::sse_decode(deserializer);
        let mut var_userName = <String>::sse_decode(deserializer);
        let mut var_displayName = <String>::sse_decode(deserializer);
        let mut var_scops = <Vec<String>>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_userPrivateKey = <String>::sse_decode(deserializer);
        let mut var_userPassphrase = <String>::sse_decode(deserializer);
        return crate::proton_api::auth_credential::AuthCredential {
            session_id: var_sessionId,
            user_id: var_userId,
            access_token: var_accessToken,
            refresh_token: var_refreshToken,
            event_id: var_eventId,
            user_mail: var_userMail,
            user_name: var_userName,
            display_name: var_displayName,
            scops: var_scops,
            user_key_id: var_userKeyId,
            user_private_key: var_userPrivateKey,
            user_passphrase: var_userPassphrase,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinAddress = <String>::sse_decode(deserializer);
        let mut var_bitcoinAddressSignature = <String>::sse_decode(deserializer);
        let mut var_bitcoinAddressIndex = <u64>::sse_decode(deserializer);
        return crate::proton_api::wallet::BitcoinAddress {
            bitcoin_address: var_bitcoinAddress,
            bitcoin_address_signature: var_bitcoinAddressSignature,
            bitcoin_address_index: var_bitcoinAddressIndex,
        };
    }
}

impl SseDecode for crate::proton_api::user_settings::BitcoinUnit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::user_settings::BitcoinUnit::BTC,
            1 => crate::proton_api::user_settings::BitcoinUnit::MBTC,
            2 => crate::proton_api::user_settings::BitcoinUnit::SATS,
            _ => unreachable!("Invalid variant for BitcoinUnit: {}", inner),
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::errors::BridgeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::ApiLock(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::Generic(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::MuonAuthSession(var_field0);
            }
            3 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::MuonAuthRefresh(var_field0);
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::MuonClient(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::MuonSession(var_field0);
            }
            6 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::AndromedaBitcoin(var_field0);
            }
            7 => {
                let mut var_field0 = <crate::api::errors::ResponseError>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::ApiResponse(var_field0);
            }
            8 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::ApiSrp(var_field0);
            }
            9 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::AesGcm(var_field0);
            }
            10 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::WalletCrypto(var_field0);
            }
            11 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::WalletFeature(var_field0);
            }
            12 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::Login(var_field0);
            }
            13 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::Fork(var_field0);
            }
            14 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::errors::BridgeError::Database(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::common::broadcast_message::BroadcastMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_dataPacket = <String>::sse_decode(deserializer);
        let mut var_keyPackets =
            <std::collections::HashMap<String, String>>::sse_decode(deserializer);
        return crate::common::broadcast_message::BroadcastMessage {
            DataPacket: var_dataPacket,
            KeyPackets: var_keyPackets,
        };
    }
}

impl SseDecode for crate::common::change_spend_policy::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::change_spend_policy::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::common::change_spend_policy::ChangeSpendPolicy::OnlyChange,
            2 => crate::common::change_spend_policy::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::auth_credential::ChildSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sessionId = <String>::sse_decode(deserializer);
        let mut var_accessToken = <String>::sse_decode(deserializer);
        let mut var_refreshToken = <String>::sse_decode(deserializer);
        let mut var_scopes = <Vec<String>>::sse_decode(deserializer);
        return crate::proton_api::auth_credential::ChildSession {
            session_id: var_sessionId,
            access_token: var_accessToken,
            refresh_token: var_refreshToken,
            scopes: var_scopes,
        };
    }
}

impl SseDecode for crate::common::coin_selection::CoinSelection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::coin_selection::CoinSelection::BranchAndBound,
            1 => crate::common::coin_selection::CoinSelection::LargestFirst,
            2 => crate::common::coin_selection::CoinSelection::OldestFirst,
            3 => crate::common::coin_selection::CoinSelection::Manual,
            _ => unreachable!("Invalid variant for CoinSelection: {}", inner),
        };
    }
}

impl SseDecode for crate::common::confirmation_time::ConfirmationTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_height = <u32>::sse_decode(deserializer);
                let mut var_time = <u64>::sse_decode(deserializer);
                return crate::common::confirmation_time::ConfirmationTime::Confirmed {
                    height: var_height,
                    time: var_time,
                };
            }
            1 => {
                let mut var_lastSeen = <u64>::sse_decode(deserializer);
                return crate::common::confirmation_time::ConfirmationTime::Unconfirmed {
                    last_seen: var_lastSeen,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::proton_api::event_routes::ContactEmailEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_contactEmail =
            <Option<crate::proton_api::contacts::ApiContactEmails>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::ContactEmailEvent {
            id: var_id,
            action: var_action,
            contact_email: var_contactEmail,
        };
    }
}

impl SseDecode for crate::proton_api::discovery_content::Content {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_link = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_pubDate = <i64>::sse_decode(deserializer);
        let mut var_author = <String>::sse_decode(deserializer);
        let mut var_category = <String>::sse_decode(deserializer);
        return crate::proton_api::discovery_content::Content {
            Title: var_title,
            Link: var_link,
            Description: var_description,
            PubDate: var_pubDate,
            Author: var_author,
            Category: var_category,
        };
    }
}

impl SseDecode for crate::proton_api::wallet_account::CreateWalletAccountReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_derivationPath = <String>::sse_decode(deserializer);
        let mut var_scriptType = <u8>::sse_decode(deserializer);
        return crate::proton_api::wallet_account::CreateWalletAccountReq {
            label: var_label,
            derivation_path: var_derivationPath,
            script_type: var_scriptType,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::CreateWalletReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_isImported = <u8>::sse_decode(deserializer);
        let mut var_type = <u8>::sse_decode(deserializer);
        let mut var_hasPassphrase = <u8>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_walletKey = <String>::sse_decode(deserializer);
        let mut var_mnemonic = <Option<String>>::sse_decode(deserializer);
        let mut var_publicKey = <Option<String>>::sse_decode(deserializer);
        let mut var_fingerprint = <Option<String>>::sse_decode(deserializer);
        let mut var_walletKeySignature = <String>::sse_decode(deserializer);
        let mut var_isAutoCreated = <u8>::sse_decode(deserializer);
        return crate::proton_api::wallet::CreateWalletReq {
            name: var_name,
            is_imported: var_isImported,
            r#type: var_type,
            has_passphrase: var_hasPassphrase,
            user_key_id: var_userKeyId,
            wallet_key: var_walletKey,
            mnemonic: var_mnemonic,
            public_key: var_publicKey,
            fingerprint: var_fingerprint,
            wallet_key_signature: var_walletKeySignature,
            is_auto_created: var_isAutoCreated,
        };
    }
}

impl SseDecode for crate::proton_api::price_graph::DataPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_exchangeRate = <u64>::sse_decode(deserializer);
        let mut var_cents = <u8>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::proton_api::price_graph::DataPoint {
            ExchangeRate: var_exchangeRate,
            Cents: var_cents,
            Timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_bitcoinAddressSignature = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
            bitcoin_address: var_bitcoinAddress,
            bitcoin_address_signature: var_bitcoinAddressSignature,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::EmailSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <Option<String>>::sse_decode(deserializer);
        let mut var_status = <u32>::sse_decode(deserializer);
        let mut var_notify = <u32>::sse_decode(deserializer);
        let mut var_reset = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_users::EmailSettings {
            Value: var_value,
            Status: var_status,
            Notify: var_notify,
            Reset: var_reset,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::proton_api::user_settings::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::user_settings::FiatCurrency::ALL,
            1 => crate::proton_api::user_settings::FiatCurrency::DZD,
            2 => crate::proton_api::user_settings::FiatCurrency::ARS,
            3 => crate::proton_api::user_settings::FiatCurrency::AMD,
            4 => crate::proton_api::user_settings::FiatCurrency::AUD,
            5 => crate::proton_api::user_settings::FiatCurrency::AZN,
            6 => crate::proton_api::user_settings::FiatCurrency::BHD,
            7 => crate::proton_api::user_settings::FiatCurrency::BDT,
            8 => crate::proton_api::user_settings::FiatCurrency::BYN,
            9 => crate::proton_api::user_settings::FiatCurrency::BMD,
            10 => crate::proton_api::user_settings::FiatCurrency::BOB,
            11 => crate::proton_api::user_settings::FiatCurrency::BAM,
            12 => crate::proton_api::user_settings::FiatCurrency::BRL,
            13 => crate::proton_api::user_settings::FiatCurrency::BGN,
            14 => crate::proton_api::user_settings::FiatCurrency::KHR,
            15 => crate::proton_api::user_settings::FiatCurrency::CAD,
            16 => crate::proton_api::user_settings::FiatCurrency::CLP,
            17 => crate::proton_api::user_settings::FiatCurrency::CNY,
            18 => crate::proton_api::user_settings::FiatCurrency::COP,
            19 => crate::proton_api::user_settings::FiatCurrency::CRC,
            20 => crate::proton_api::user_settings::FiatCurrency::HRK,
            21 => crate::proton_api::user_settings::FiatCurrency::CUP,
            22 => crate::proton_api::user_settings::FiatCurrency::CZK,
            23 => crate::proton_api::user_settings::FiatCurrency::DKK,
            24 => crate::proton_api::user_settings::FiatCurrency::DOP,
            25 => crate::proton_api::user_settings::FiatCurrency::EGP,
            26 => crate::proton_api::user_settings::FiatCurrency::EUR,
            27 => crate::proton_api::user_settings::FiatCurrency::GEL,
            28 => crate::proton_api::user_settings::FiatCurrency::GHS,
            29 => crate::proton_api::user_settings::FiatCurrency::GTQ,
            30 => crate::proton_api::user_settings::FiatCurrency::HNL,
            31 => crate::proton_api::user_settings::FiatCurrency::HKD,
            32 => crate::proton_api::user_settings::FiatCurrency::HUF,
            33 => crate::proton_api::user_settings::FiatCurrency::ISK,
            34 => crate::proton_api::user_settings::FiatCurrency::INR,
            35 => crate::proton_api::user_settings::FiatCurrency::IDR,
            36 => crate::proton_api::user_settings::FiatCurrency::IRR,
            37 => crate::proton_api::user_settings::FiatCurrency::IQD,
            38 => crate::proton_api::user_settings::FiatCurrency::ILS,
            39 => crate::proton_api::user_settings::FiatCurrency::JMD,
            40 => crate::proton_api::user_settings::FiatCurrency::JPY,
            41 => crate::proton_api::user_settings::FiatCurrency::JOD,
            42 => crate::proton_api::user_settings::FiatCurrency::KZT,
            43 => crate::proton_api::user_settings::FiatCurrency::KES,
            44 => crate::proton_api::user_settings::FiatCurrency::KWD,
            45 => crate::proton_api::user_settings::FiatCurrency::KGS,
            46 => crate::proton_api::user_settings::FiatCurrency::LBP,
            47 => crate::proton_api::user_settings::FiatCurrency::MKD,
            48 => crate::proton_api::user_settings::FiatCurrency::MYR,
            49 => crate::proton_api::user_settings::FiatCurrency::MUR,
            50 => crate::proton_api::user_settings::FiatCurrency::MXN,
            51 => crate::proton_api::user_settings::FiatCurrency::MDL,
            52 => crate::proton_api::user_settings::FiatCurrency::MNT,
            53 => crate::proton_api::user_settings::FiatCurrency::MAD,
            54 => crate::proton_api::user_settings::FiatCurrency::MMK,
            55 => crate::proton_api::user_settings::FiatCurrency::NAD,
            56 => crate::proton_api::user_settings::FiatCurrency::NPR,
            57 => crate::proton_api::user_settings::FiatCurrency::TWD,
            58 => crate::proton_api::user_settings::FiatCurrency::NZD,
            59 => crate::proton_api::user_settings::FiatCurrency::NIO,
            60 => crate::proton_api::user_settings::FiatCurrency::NGN,
            61 => crate::proton_api::user_settings::FiatCurrency::NOK,
            62 => crate::proton_api::user_settings::FiatCurrency::OMR,
            63 => crate::proton_api::user_settings::FiatCurrency::PKR,
            64 => crate::proton_api::user_settings::FiatCurrency::PAB,
            65 => crate::proton_api::user_settings::FiatCurrency::PEN,
            66 => crate::proton_api::user_settings::FiatCurrency::PHP,
            67 => crate::proton_api::user_settings::FiatCurrency::PLN,
            68 => crate::proton_api::user_settings::FiatCurrency::GBP,
            69 => crate::proton_api::user_settings::FiatCurrency::QAR,
            70 => crate::proton_api::user_settings::FiatCurrency::RON,
            71 => crate::proton_api::user_settings::FiatCurrency::RUB,
            72 => crate::proton_api::user_settings::FiatCurrency::SAR,
            73 => crate::proton_api::user_settings::FiatCurrency::RSD,
            74 => crate::proton_api::user_settings::FiatCurrency::SGD,
            75 => crate::proton_api::user_settings::FiatCurrency::ZAR,
            76 => crate::proton_api::user_settings::FiatCurrency::KRW,
            77 => crate::proton_api::user_settings::FiatCurrency::SSP,
            78 => crate::proton_api::user_settings::FiatCurrency::VES,
            79 => crate::proton_api::user_settings::FiatCurrency::LKR,
            80 => crate::proton_api::user_settings::FiatCurrency::SEK,
            81 => crate::proton_api::user_settings::FiatCurrency::CHF,
            82 => crate::proton_api::user_settings::FiatCurrency::THB,
            83 => crate::proton_api::user_settings::FiatCurrency::TTD,
            84 => crate::proton_api::user_settings::FiatCurrency::TND,
            85 => crate::proton_api::user_settings::FiatCurrency::TRY,
            86 => crate::proton_api::user_settings::FiatCurrency::UGX,
            87 => crate::proton_api::user_settings::FiatCurrency::UAH,
            88 => crate::proton_api::user_settings::FiatCurrency::AED,
            89 => crate::proton_api::user_settings::FiatCurrency::USD,
            90 => crate::proton_api::user_settings::FiatCurrency::UYU,
            91 => crate::proton_api::user_settings::FiatCurrency::UZS,
            92 => crate::proton_api::user_settings::FiatCurrency::VND,
            _ => unreachable!("Invalid variant for FiatCurrency: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::FlagsSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::proton_api::proton_users::FlagsSettings {};
    }
}

impl SseDecode for crate::common::address_info::FrbAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_index = <u32>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_keychain =
            <crate::common::keychain_kind::KeychainKind>::sse_decode(deserializer);
        return crate::common::address_info::FrbAddressInfo {
            index: var_index,
            address: var_address,
            keychain: var_keychain,
        };
    }
}

impl SseDecode for crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_wallet::crypto::wallet_key::LockedWalletKey>::sse_decode(deserializer);
        return crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey(var_field0);
    }
}

impl SseDecode for crate::api::bdk_wallet::local_output::FrbOutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::bdk_wallet::local_output::FrbOutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::bdk_wallet::psbt::FrbPsbtRecipient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <u64>::sse_decode(deserializer);
        return crate::api::bdk_wallet::psbt::FrbPsbtRecipient(var_field0, var_field1);
    }
}

impl SseDecode for crate::api::proton_wallet::features::transition_layer::FrbSenderBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_toList = <String>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_body = <String>::sse_decode(deserializer);
        return crate::api::proton_wallet::features::transition_layer::FrbSenderBody {
            to_list: var_toList,
            sender: var_sender,
            body: var_body,
        };
    }
}

impl SseDecode for crate::api::proton_wallet::srp::srp_client::FrbSrpClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::proton_wallet::srp::srp_client::FrbSrpClient {};
    }
}

impl SseDecode
    for crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_encryptedTransactionId = <String>::sse_decode(deserializer);
        let mut var_index = <u32>::sse_decode(deserializer);
        return crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID{encrypted_transaction_id: var_encryptedTransactionId, index: var_index};
    }
}

impl SseDecode for crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transactionId = <String>::sse_decode(deserializer);
        let mut var_index = <u32>::sse_decode(deserializer);
        return crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID {
            transaction_id: var_transactionId,
            index: var_index,
        };
    }
}

impl SseDecode for crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer {};
    }
}

impl SseDecode for crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper {};
    }
}

impl SseDecode for crate::proton_api::payment_gateway::GatewayProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::payment_gateway::GatewayProvider::Banxa,
            1 => crate::proton_api::payment_gateway::GatewayProvider::Ramp,
            2 => crate::proton_api::payment_gateway::GatewayProvider::MoonPay,
            3 => crate::proton_api::payment_gateway::GatewayProvider::Unsupported,
            _ => unreachable!("Invalid variant for GatewayProvider: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::GetAuthInfoResponseBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <u32>::sse_decode(deserializer);
        let mut var_modulus = <String>::sse_decode(deserializer);
        let mut var_serverEphemeral = <String>::sse_decode(deserializer);
        let mut var_version = <u8>::sse_decode(deserializer);
        let mut var_salt = <String>::sse_decode(deserializer);
        let mut var_srpSession = <String>::sse_decode(deserializer);
        let mut var_twoFa = <crate::proton_api::proton_users::TwoFA>::sse_decode(deserializer);
        return crate::proton_api::proton_users::GetAuthInfoResponseBody {
            Code: var_code,
            Modulus: var_modulus,
            ServerEphemeral: var_serverEphemeral,
            Version: var_version,
            Salt: var_salt,
            SRPSession: var_srpSession,
            two_fa: var_twoFa,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::GetAuthModulusResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <u32>::sse_decode(deserializer);
        let mut var_modulus = <String>::sse_decode(deserializer);
        let mut var_modulusId = <String>::sse_decode(deserializer);
        return crate::proton_api::proton_users::GetAuthModulusResponse {
            Code: var_code,
            Modulus: var_modulus,
            ModulusID: var_modulusId,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::HighSecuritySettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_eligible = <u32>::sse_decode(deserializer);
        let mut var_value = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_users::HighSecuritySettings {
            Eligible: var_eligible,
            Value: var_value,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::proton_api::invite::InviteNotificationType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::invite::InviteNotificationType::Newcomer,
            1 => crate::proton_api::invite::InviteNotificationType::EmailIntegration,
            2 => crate::proton_api::invite::InviteNotificationType::Unsupported,
            _ => unreachable!("Invalid variant for InviteNotificationType: {}", inner),
        };
    }
}

impl SseDecode for isize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::common::keychain_kind::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::keychain_kind::KeychainKind::External,
            1 => crate::common::keychain_kind::KeychainKind::Internal,
            _ => unreachable!("Invalid variant for KeychainKind: {}", inner),
        };
    }
}

impl SseDecode for Vec<ApiTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ApiTx>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<DiscoveredAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<DiscoveredAccount>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FrbAddressDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FrbAddressDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FrbDetailledTxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FrbDetailledTxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FrbDetailledTxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FrbDetailledTxOutput>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FrbLocalOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FrbLocalOutput>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<FrbTransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<FrbTransactionDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_wallet::db::model::account_model::AccountModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_wallet::db::model::account_model::AccountModel>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_address::AllKeyAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::proton_address::AllKeyAddressKey>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::contacts::ApiContactEmails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::ApiCountry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::payment_gateway::ApiCountry>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet_account::ApiEmailAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet_account::ApiEmailAddress>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_users::ApiMnemonicUserKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::proton_users::ApiMnemonicUserKey>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet_account::ApiWalletAccount>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::ApiWalletBitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet::ApiWalletBitcoinAddress>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::ApiWalletData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::ApiWalletData>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::ApiWalletKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::ApiWalletKey>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::BitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::BitcoinAddress>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::ContactEmailEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::ContactEmailEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::discovery_content::Content> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::discovery_content::Content>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::price_graph::DataPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::price_graph::DataPoint>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bdk_wallet::local_output::FrbOutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::bdk_wallet::local_output::FrbOutPoint>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::bdk_wallet::psbt::FrbPsbtRecipient> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::bdk_wallet::psbt::FrbPsbtRecipient>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::MigratedWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::MigratedWalletAccount>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::MigratedWalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::wallet::MigratedWalletTransaction>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_users::MnemonicUserKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::proton_users::MnemonicUserKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_address::ProtonAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::proton_address::ProtonAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_address::ProtonAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::proton_address::ProtonAddressKey>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::ProtonEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::event_routes::ProtonEvent>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::proton_users::ProtonUserKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::proton_users::ProtonUserKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::payment_gateway::Quote> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::payment_gateway::Quote>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiCountry>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::PaymentMethod>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::Quote>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, f64)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletAccountEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::WalletAccountEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::event_routes::WalletEvent>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletKeyEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::event_routes::WalletKeyEvent>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_wallet::db::model::wallet_model::WalletModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_wallet::db::model::wallet_model::WalletModel>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletSettingsEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::WalletSettingsEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::proton_api::wallet::WalletTransaction>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::proton_api::event_routes::WalletTransactionEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::proton_api::event_routes::WalletTransactionEvent>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for crate::proton_wallet::crypto::wallet_key::LockedWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_encrypted = <String>::sse_decode(deserializer);
        let mut var_signature = <String>::sse_decode(deserializer);
        return crate::proton_wallet::crypto::wallet_key::LockedWalletKey {
            encrypted: var_encrypted,
            signature: var_signature,
        };
    }
}

impl SseDecode for crate::proton_api::transaction::MempoolInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_loaded = <u8>::sse_decode(deserializer);
        let mut var_size = <u32>::sse_decode(deserializer);
        let mut var_bytes = <u32>::sse_decode(deserializer);
        let mut var_usage = <u32>::sse_decode(deserializer);
        let mut var_maxMempool = <u32>::sse_decode(deserializer);
        let mut var_mempoolMinFee = <f32>::sse_decode(deserializer);
        let mut var_minRelayTxFee = <f32>::sse_decode(deserializer);
        let mut var_incrementalRelayFee = <f32>::sse_decode(deserializer);
        let mut var_unbroadcastCount = <u8>::sse_decode(deserializer);
        let mut var_fullRbf = <u8>::sse_decode(deserializer);
        return crate::proton_api::transaction::MempoolInfo {
            Loaded: var_loaded,
            Size: var_size,
            Bytes: var_bytes,
            Usage: var_usage,
            MaxMempool: var_maxMempool,
            MempoolMinFee: var_mempoolMinFee,
            MinRelayTxFee: var_minRelayTxFee,
            IncrementalRelayFee: var_incrementalRelayFee,
            UnbroadcastCount: var_unbroadcastCount,
            FullRbf: var_fullRbf,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::MigratedWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_userKeyId = <String>::sse_decode(deserializer);
        let mut var_walletKey = <String>::sse_decode(deserializer);
        let mut var_walletKeySignature = <String>::sse_decode(deserializer);
        let mut var_mnemonic = <String>::sse_decode(deserializer);
        let mut var_fingerprint = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet::MigratedWallet {
            Name: var_name,
            UserKeyID: var_userKeyId,
            WalletKey: var_walletKey,
            WalletKeySignature: var_walletKeySignature,
            Mnemonic: var_mnemonic,
            Fingerprint: var_fingerprint,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::MigratedWalletAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        return crate::proton_api::wallet::MigratedWalletAccount {
            ID: var_id,
            Label: var_label,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::MigratedWalletTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_walletAccountId = <String>::sse_decode(deserializer);
        let mut var_hashedTransactionId = <Option<String>>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::wallet::MigratedWalletTransaction {
            ID: var_id,
            WalletAccountID: var_walletAccountId,
            HashedTransactionID: var_hashedTransactionId,
            Label: var_label,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::MnemonicAuth {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_modulusId = <String>::sse_decode(deserializer);
        let mut var_salt = <String>::sse_decode(deserializer);
        let mut var_verifier = <String>::sse_decode(deserializer);
        return crate::proton_api::proton_users::MnemonicAuth {
            Version: var_version,
            ModulusID: var_modulusId,
            Salt: var_salt,
            Verifier: var_verifier,
        };
    }
}

impl SseDecode for crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_mnemonic = <Option<String>>::sse_decode(deserializer);
        return crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData {
            wallet_id: var_walletId,
            mnemonic: var_mnemonic,
        };
    }
}

impl SseDecode for crate::proton_wallet::features::backup_mnemonic::MnemonicResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_walletMnemonic = <String>::sse_decode(deserializer);
        return crate::proton_wallet::features::backup_mnemonic::MnemonicResult {
            wallet_id: var_walletId,
            wallet_name: var_walletName,
            wallet_mnemonic: var_walletMnemonic,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::MnemonicUserKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_privateKey = <String>::sse_decode(deserializer);
        return crate::proton_api::proton_users::MnemonicUserKey {
            ID: var_id,
            PrivateKey: var_privateKey,
        };
    }
}

impl SseDecode for crate::common::network::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::network::Network::Bitcoin,
            1 => crate::common::network::Network::Testnet,
            2 => crate::common::network::Network::Signet,
            3 => crate::common::network::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for Option<std::collections::HashMap<String, String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<std::collections::HashMap<String, String>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<FrbAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<FrbAccount>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<FrbAddressDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<FrbAddressDetails>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<FrbDetailledTxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<FrbDetailledTxOutput>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_wallet::db::model::account_model::AccountModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_wallet::db::model::account_model::AccountModel>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::contacts::ApiContactEmails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::ApiWallet> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::ApiWallet>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::wallet_account::ApiWalletAccount>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::ApiWalletKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::ApiWalletKey>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet_settings::ApiWalletSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::user_settings::ApiWalletUserSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::user_settings::ApiWalletUserSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::common::broadcast_message::BroadcastMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::common::broadcast_message::BroadcastMessage>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::FlagsSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::FlagsSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::payment_gateway::GatewayProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::HighSecuritySettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::HighSecuritySettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::common::pagination::Pagination> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::common::pagination::Pagination>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::PasswordSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::PasswordSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::PhoneSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::PhoneSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::exchange_rate::ProtonExchangeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::exchange_rate::ProtonExchangeRate>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::ProtonUser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::proton_users::ProtonUser>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::ProtonUserSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::ProtonUserSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::ReferralSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::ReferralSettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::common::pagination::SortOrder> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::common::pagination::SortOrder>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::TransactionType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::TransactionType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::proton_users::TwoFASettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_api::proton_users::TwoFASettings>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_wallet::db::model::wallet_model::WalletModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::proton_wallet::db::model::wallet_model::WalletModel>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::proton_api::wallet::WalletTransaction>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::ContactEmailEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::ContactEmailEvent>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::proton_users::ProtonUserKey>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletAccountEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletAccountEvent>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletEvent>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletKeyEvent>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletSettingsEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletSettingsEvent>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::proton_api::event_routes::WalletTransactionEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::proton_api::event_routes::WalletTransactionEvent>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::common::pagination::Pagination {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_skip = <usize>::sse_decode(deserializer);
        let mut var_take = <usize>::sse_decode(deserializer);
        return crate::common::pagination::Pagination {
            skip: var_skip,
            take: var_take,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::PasswordSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::proton_api::proton_users::PasswordSettings {};
    }
}

impl SseDecode for crate::proton_api::payment_gateway::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::payment_gateway::PaymentMethod::ApplePay,
            1 => crate::proton_api::payment_gateway::PaymentMethod::BankTransfer,
            2 => crate::proton_api::payment_gateway::PaymentMethod::Card,
            3 => crate::proton_api::payment_gateway::PaymentMethod::GooglePay,
            4 => crate::proton_api::payment_gateway::PaymentMethod::InstantPayment,
            5 => crate::proton_api::payment_gateway::PaymentMethod::Paypal,
            6 => crate::proton_api::payment_gateway::PaymentMethod::Unsupported,
            _ => unreachable!("Invalid variant for PaymentMethod: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::PhoneSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::proton_api::proton_users::PhoneSettings {};
    }
}

impl SseDecode for crate::proton_api::price_graph::PriceGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_bitcoinUnit =
            <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(deserializer);
        let mut var_graphData =
            <Vec<crate::proton_api::price_graph::DataPoint>>::sse_decode(deserializer);
        return crate::proton_api::price_graph::PriceGraph {
            FiatCurrency: var_fiatCurrency,
            BitcoinUnit: var_bitcoinUnit,
            GraphData: var_graphData,
        };
    }
}

impl SseDecode for crate::proton_api::proton_address::ProtonAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_domainId = <Option<String>>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_status = <u32>::sse_decode(deserializer);
        let mut var_type = <u32>::sse_decode(deserializer);
        let mut var_receive = <u32>::sse_decode(deserializer);
        let mut var_send = <u32>::sse_decode(deserializer);
        let mut var_displayName = <String>::sse_decode(deserializer);
        let mut var_keys =
            <Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>>>::sse_decode(
                deserializer,
            );
        return crate::proton_api::proton_address::ProtonAddress {
            id: var_id,
            domain_id: var_domainId,
            email: var_email,
            status: var_status,
            r#type: var_type,
            receive: var_receive,
            send: var_send,
            display_name: var_displayName,
            keys: var_keys,
        };
    }
}

impl SseDecode for crate::proton_api::proton_address::ProtonAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        let mut var_privateKey = <Option<String>>::sse_decode(deserializer);
        let mut var_token = <Option<String>>::sse_decode(deserializer);
        let mut var_signature = <Option<String>>::sse_decode(deserializer);
        let mut var_primary = <u32>::sse_decode(deserializer);
        let mut var_active = <u32>::sse_decode(deserializer);
        let mut var_flags = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_address::ProtonAddressKey {
            id: var_id,
            version: var_version,
            public_key: var_publicKey,
            private_key: var_privateKey,
            token: var_token,
            signature: var_signature,
            primary: var_primary,
            active: var_active,
            flags: var_flags,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::ProtonEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <u16>::sse_decode(deserializer);
        let mut var_eventId = <String>::sse_decode(deserializer);
        let mut var_refresh = <u32>::sse_decode(deserializer);
        let mut var_more = <u32>::sse_decode(deserializer);
        let mut var_contactEmailEvents = <Option<
            Vec<crate::proton_api::event_routes::ContactEmailEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletEvents =
            <Option<Vec<crate::proton_api::event_routes::WalletEvent>>>::sse_decode(deserializer);
        let mut var_walletAccountEvents = <Option<
            Vec<crate::proton_api::event_routes::WalletAccountEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletKeyEvents =
            <Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>>>::sse_decode(
                deserializer,
            );
        let mut var_walletSettingEvents = <Option<
            Vec<crate::proton_api::event_routes::WalletSettingsEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletTransactionEvents = <Option<
            Vec<crate::proton_api::event_routes::WalletTransactionEvent>,
        >>::sse_decode(deserializer);
        let mut var_walletUserSettings = <Option<
            crate::proton_api::user_settings::ApiWalletUserSettings,
        >>::sse_decode(deserializer);
        let mut var_protonUser =
            <Option<crate::proton_api::proton_users::ProtonUser>>::sse_decode(deserializer);
        let mut var_protonUserSettings =
            <Option<crate::proton_api::proton_users::ProtonUserSettings>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::ProtonEvent {
            code: var_code,
            event_id: var_eventId,
            refresh: var_refresh,
            more: var_more,
            contact_email_events: var_contactEmailEvents,
            wallet_events: var_walletEvents,
            wallet_account_events: var_walletAccountEvents,
            wallet_key_events: var_walletKeyEvents,
            wallet_setting_events: var_walletSettingEvents,
            wallet_transaction_events: var_walletTransactionEvents,
            wallet_user_settings: var_walletUserSettings,
            proton_user: var_protonUser,
            proton_user_settings: var_protonUserSettings,
        };
    }
}

impl SseDecode for crate::proton_api::exchange_rate::ProtonExchangeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_bitcoinUnit =
            <crate::proton_api::user_settings::BitcoinUnit>::sse_decode(deserializer);
        let mut var_fiatCurrency =
            <crate::proton_api::user_settings::FiatCurrency>::sse_decode(deserializer);
        let mut var_exchangeRateTime = <String>::sse_decode(deserializer);
        let mut var_exchangeRate = <u64>::sse_decode(deserializer);
        let mut var_cents = <u64>::sse_decode(deserializer);
        return crate::proton_api::exchange_rate::ProtonExchangeRate {
            id: var_id,
            bitcoin_unit: var_bitcoinUnit,
            fiat_currency: var_fiatCurrency,
            exchange_rate_time: var_exchangeRateTime,
            exchange_rate: var_exchangeRate,
            cents: var_cents,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::ProtonSrpClientProofs {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_clientEphemeral = <String>::sse_decode(deserializer);
        let mut var_clientProof = <String>::sse_decode(deserializer);
        let mut var_srpSession = <String>::sse_decode(deserializer);
        let mut var_twoFactorCode = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::proton_users::ProtonSrpClientProofs {
            ClientEphemeral: var_clientEphemeral,
            ClientProof: var_clientProof,
            SRPSession: var_srpSession,
            TwoFactorCode: var_twoFactorCode,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::ProtonUser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_usedSpace = <u64>::sse_decode(deserializer);
        let mut var_currency = <String>::sse_decode(deserializer);
        let mut var_credit = <u32>::sse_decode(deserializer);
        let mut var_createTime = <u64>::sse_decode(deserializer);
        let mut var_maxSpace = <u64>::sse_decode(deserializer);
        let mut var_maxUpload = <u64>::sse_decode(deserializer);
        let mut var_role = <u32>::sse_decode(deserializer);
        let mut var_private = <u32>::sse_decode(deserializer);
        let mut var_subscribed = <u32>::sse_decode(deserializer);
        let mut var_services = <u32>::sse_decode(deserializer);
        let mut var_delinquent = <u32>::sse_decode(deserializer);
        let mut var_organizationPrivateKey = <Option<String>>::sse_decode(deserializer);
        let mut var_email = <String>::sse_decode(deserializer);
        let mut var_displayName = <Option<String>>::sse_decode(deserializer);
        let mut var_keys =
            <Option<Vec<crate::proton_api::proton_users::ProtonUserKey>>>::sse_decode(deserializer);
        let mut var_mnemonicStatus = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_users::ProtonUser {
            ID: var_id,
            Name: var_name,
            UsedSpace: var_usedSpace,
            Currency: var_currency,
            Credit: var_credit,
            CreateTime: var_createTime,
            MaxSpace: var_maxSpace,
            MaxUpload: var_maxUpload,
            Role: var_role,
            Private: var_private,
            Subscribed: var_subscribed,
            Services: var_services,
            Delinquent: var_delinquent,
            OrganizationPrivateKey: var_organizationPrivateKey,
            Email: var_email,
            DisplayName: var_displayName,
            Keys: var_keys,
            MnemonicStatus: var_mnemonicStatus,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::ProtonUserKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_version = <u32>::sse_decode(deserializer);
        let mut var_privateKey = <String>::sse_decode(deserializer);
        let mut var_recoverySecret = <Option<String>>::sse_decode(deserializer);
        let mut var_recoverySecretSignature = <Option<String>>::sse_decode(deserializer);
        let mut var_token = <Option<String>>::sse_decode(deserializer);
        let mut var_fingerprint = <String>::sse_decode(deserializer);
        let mut var_primary = <u32>::sse_decode(deserializer);
        let mut var_active = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_users::ProtonUserKey {
            ID: var_id,
            Version: var_version,
            PrivateKey: var_privateKey,
            RecoverySecret: var_recoverySecret,
            RecoverySecretSignature: var_recoverySecretSignature,
            Token: var_token,
            Fingerprint: var_fingerprint,
            Primary: var_primary,
            Active: var_active,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::ProtonUserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_email =
            <crate::proton_api::proton_users::EmailSettings>::sse_decode(deserializer);
        let mut var_password =
            <Option<crate::proton_api::proton_users::PasswordSettings>>::sse_decode(deserializer);
        let mut var_phone =
            <Option<crate::proton_api::proton_users::PhoneSettings>>::sse_decode(deserializer);
        let mut var_twoFa =
            <Option<crate::proton_api::proton_users::TwoFASettings>>::sse_decode(deserializer);
        let mut var_news = <u32>::sse_decode(deserializer);
        let mut var_locale = <String>::sse_decode(deserializer);
        let mut var_logAuth = <u32>::sse_decode(deserializer);
        let mut var_invoiceText = <String>::sse_decode(deserializer);
        let mut var_density = <u32>::sse_decode(deserializer);
        let mut var_weekStart = <u32>::sse_decode(deserializer);
        let mut var_dateFormat = <u32>::sse_decode(deserializer);
        let mut var_timeFormat = <u32>::sse_decode(deserializer);
        let mut var_welcome = <u32>::sse_decode(deserializer);
        let mut var_welcomeFlag = <u32>::sse_decode(deserializer);
        let mut var_earlyAccess = <u32>::sse_decode(deserializer);
        let mut var_flags =
            <Option<crate::proton_api::proton_users::FlagsSettings>>::sse_decode(deserializer);
        let mut var_referral =
            <Option<crate::proton_api::proton_users::ReferralSettings>>::sse_decode(deserializer);
        let mut var_deviceRecovery = <Option<u32>>::sse_decode(deserializer);
        let mut var_telemetry = <u32>::sse_decode(deserializer);
        let mut var_crashReports = <u32>::sse_decode(deserializer);
        let mut var_hideSidePanel = <u32>::sse_decode(deserializer);
        let mut var_highSecurity =
            <Option<crate::proton_api::proton_users::HighSecuritySettings>>::sse_decode(
                deserializer,
            );
        let mut var_sessionAccountRecovery = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_users::ProtonUserSettings {
            Email: var_email,
            Password: var_password,
            Phone: var_phone,
            two_fa: var_twoFa,
            News: var_news,
            Locale: var_locale,
            LogAuth: var_logAuth,
            InvoiceText: var_invoiceText,
            Density: var_density,
            WeekStart: var_weekStart,
            DateFormat: var_dateFormat,
            TimeFormat: var_timeFormat,
            Welcome: var_welcome,
            WelcomeFlag: var_welcomeFlag,
            EarlyAccess: var_earlyAccess,
            Flags: var_flags,
            Referral: var_referral,
            DeviceRecovery: var_deviceRecovery,
            Telemetry: var_telemetry,
            CrashReports: var_crashReports,
            HideSidePanel: var_hideSidePanel,
            HighSecurity: var_highSecurity,
            SessionAccountRecovery: var_sessionAccountRecovery,
        };
    }
}

impl SseDecode for crate::proton_api::payment_gateway::Quote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bitcoinAmount = <String>::sse_decode(deserializer);
        let mut var_fiatAmount = <String>::sse_decode(deserializer);
        let mut var_fiatCurrencySymbol = <String>::sse_decode(deserializer);
        let mut var_networkFee = <String>::sse_decode(deserializer);
        let mut var_paymentGatewayFee = <String>::sse_decode(deserializer);
        let mut var_paymentMethod =
            <crate::proton_api::payment_gateway::PaymentMethod>::sse_decode(deserializer);
        let mut var_purchaseAmount = <Option<String>>::sse_decode(deserializer);
        let mut var_paymentProcessingFee = <Option<String>>::sse_decode(deserializer);
        let mut var_orderId = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::payment_gateway::Quote {
            BitcoinAmount: var_bitcoinAmount,
            FiatAmount: var_fiatAmount,
            FiatCurrencySymbol: var_fiatCurrencySymbol,
            NetworkFee: var_networkFee,
            PaymentGatewayFee: var_paymentGatewayFee,
            PaymentMethod: var_paymentMethod,
            PurchaseAmount: var_purchaseAmount,
            PaymentProcessingFee: var_paymentProcessingFee,
            OrderID: var_orderId,
        };
    }
}

impl SseDecode for crate::common::blockchain::RecommendedFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fastestFee = <u8>::sse_decode(deserializer);
        let mut var_halfHourFee = <u8>::sse_decode(deserializer);
        let mut var_hourFee = <u8>::sse_decode(deserializer);
        let mut var_economyFee = <u8>::sse_decode(deserializer);
        let mut var_minimumFee = <u8>::sse_decode(deserializer);
        return crate::common::blockchain::RecommendedFees {
            FastestFee: var_fastestFee,
            HalfHourFee: var_halfHourFee,
            HourFee: var_hourFee,
            EconomyFee: var_economyFee,
            MinimumFee: var_minimumFee,
        };
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::ApiCountry>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>>::sse_decode(
                deserializer,
            );
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::PaymentMethod>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::proton_api::payment_gateway::Quote>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::proton_api::proton_users::ReferralSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::proton_api::proton_users::ReferralSettings {};
    }
}

impl SseDecode for crate::proton_api::invite::RemainingMonthlyInvitations {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_used = <u8>::sse_decode(deserializer);
        let mut var_available = <u8>::sse_decode(deserializer);
        return crate::proton_api::invite::RemainingMonthlyInvitations {
            Used: var_used,
            Available: var_available,
        };
    }
}

impl SseDecode for crate::api::errors::ResponseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <u16>::sse_decode(deserializer);
        let mut var_error = <String>::sse_decode(deserializer);
        let mut var_details = <String>::sse_decode(deserializer);
        return crate::api::errors::ResponseError {
            code: var_code,
            error: var_error,
            details: var_details,
        };
    }
}

impl SseDecode for crate::common::script_type::ScriptType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::script_type::ScriptType::Legacy,
            1 => crate::common::script_type::ScriptType::NestedSegwit,
            2 => crate::common::script_type::ScriptType::NativeSegwit,
            3 => crate::common::script_type::ScriptType::Taproot,
            _ => unreachable!("Invalid variant for ScriptType: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::SetTwoFaTOTPRequestBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totpConfirmation = <String>::sse_decode(deserializer);
        let mut var_totpSharedSecret = <String>::sse_decode(deserializer);
        return crate::proton_api::proton_users::SetTwoFaTOTPRequestBody {
            TOTPConfirmation: var_totpConfirmation,
            TOTPSharedSecret: var_totpSharedSecret,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::SetTwoFaTOTPResponseBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <u32>::sse_decode(deserializer);
        let mut var_twoFactorRecoveryCodes = <Vec<String>>::sse_decode(deserializer);
        let mut var_userSettings =
            <crate::proton_api::proton_users::ProtonUserSettings>::sse_decode(deserializer);
        return crate::proton_api::proton_users::SetTwoFaTOTPResponseBody {
            Code: var_code,
            TwoFactorRecoveryCodes: var_twoFactorRecoveryCodes,
            UserSettings: var_userSettings,
        };
    }
}

impl SseDecode for crate::common::pagination::SortOrder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::pagination::SortOrder::Asc,
            1 => crate::common::pagination::SortOrder::Desc,
            _ => unreachable!("Invalid variant for SortOrder: {}", inner),
        };
    }
}

impl SseDecode for crate::srp::proofs::SRPProofB64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_clientEphemeral = <String>::sse_decode(deserializer);
        let mut var_clientProof = <String>::sse_decode(deserializer);
        let mut var_expectedServerProof = <String>::sse_decode(deserializer);
        return crate::srp::proofs::SRPProofB64 {
            client_ephemeral: var_clientEphemeral,
            client_proof: var_clientProof,
            expected_server_proof: var_expectedServerProof,
        };
    }
}

impl SseDecode for crate::proton_api::price_graph::Timeframe {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::price_graph::Timeframe::OneDay,
            1 => crate::proton_api::price_graph::Timeframe::OneWeek,
            2 => crate::proton_api::price_graph::Timeframe::OneMonth,
            3 => crate::proton_api::price_graph::Timeframe::Unsupported,
            _ => unreachable!("Invalid variant for Timeframe: {}", inner),
        };
    }
}

impl SseDecode for crate::common::transaction_time::TransactionTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_confirmationTime = <u64>::sse_decode(deserializer);
                return crate::common::transaction_time::TransactionTime::Confirmed {
                    confirmation_time: var_confirmationTime,
                };
            }
            1 => {
                let mut var_lastSeen = <u64>::sse_decode(deserializer);
                return crate::common::transaction_time::TransactionTime::Unconfirmed {
                    last_seen: var_lastSeen,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::proton_api::wallet::TransactionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::wallet::TransactionType::NotSend,
            1 => crate::proton_api::wallet::TransactionType::ProtonToProtonSend,
            2 => crate::proton_api::wallet::TransactionType::ProtonToProtonReceive,
            3 => crate::proton_api::wallet::TransactionType::ExternalSend,
            4 => crate::proton_api::wallet::TransactionType::ExternalReceive,
            5 => crate::proton_api::wallet::TransactionType::Unsupported,
            _ => unreachable!("Invalid variant for TransactionType: {}", inner),
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::TwoFA {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_enabled = <u8>::sse_decode(deserializer);
        return crate::proton_api::proton_users::TwoFA {
            Enabled: var_enabled,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::TwoFASettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_enabled = <u32>::sse_decode(deserializer);
        let mut var_allowed = <u32>::sse_decode(deserializer);
        return crate::proton_api::proton_users::TwoFASettings {
            Enabled: var_enabled,
            Allowed: var_allowed,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::proton_api::unleash::UnleashResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_statusCode = <u16>::sse_decode(deserializer);
        let mut var_body = <Vec<u8>>::sse_decode(deserializer);
        return crate::proton_api::unleash::UnleashResponse {
            status_code: var_statusCode,
            body: var_body,
        };
    }
}

impl SseDecode for crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mnemonicUserKeys =
            <Vec<crate::proton_api::proton_users::MnemonicUserKey>>::sse_decode(deserializer);
        let mut var_mnemonicSalt = <String>::sse_decode(deserializer);
        let mut var_mnemonicAuth =
            <crate::proton_api::proton_users::MnemonicAuth>::sse_decode(deserializer);
        return crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody {
            MnemonicUserKeys: var_mnemonicUserKeys,
            MnemonicSalt: var_mnemonicSalt,
            MnemonicAuth: var_mnemonicAuth,
        };
    }
}

impl SseDecode for crate::proton_api::user_settings::UserReceiveNotificationEmailTypes {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::NotificationToInviter,
1 => crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::EmailIntegration,
2 => crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::TransactionalBvE,
3 => crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::Unsupported,
            _ => unreachable!("Invalid variant for UserReceiveNotificationEmailTypes: {}", inner),
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletAccountEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletAccount =
            <Option<crate::proton_api::wallet_account::ApiWalletAccount>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletAccountEvent {
            id: var_id,
            action: var_action,
            wallet_account: var_walletAccount,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_wallet =
            <Option<crate::proton_api::wallet::ApiWallet>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletEvent {
            id: var_id,
            action: var_action,
            wallet: var_wallet,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletKeyEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletKey =
            <Option<crate::proton_api::wallet::ApiWalletKey>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletKeyEvent {
            id: var_id,
            action: var_action,
            wallet_key: var_walletKey,
        };
    }
}

impl SseDecode for crate::api::bdk_wallet::storage::WalletMobileConnectorFactory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_folderPath = <String>::sse_decode(deserializer);
        return crate::api::bdk_wallet::storage::WalletMobileConnectorFactory {
            folder_path: var_folderPath,
        };
    }
}

impl SseDecode for crate::proton_wallet::db::model::wallet_model::WalletModel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_passphrase = <u32>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        let mut var_imported = <u32>::sse_decode(deserializer);
        let mut var_priority = <u32>::sse_decode(deserializer);
        let mut var_status = <u32>::sse_decode(deserializer);
        let mut var_type = <u32>::sse_decode(deserializer);
        let mut var_createTime = <u32>::sse_decode(deserializer);
        let mut var_modifyTime = <u32>::sse_decode(deserializer);
        let mut var_userId = <String>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_accountCount = <u32>::sse_decode(deserializer);
        let mut var_balance = <f64>::sse_decode(deserializer);
        let mut var_fingerprint = <Option<String>>::sse_decode(deserializer);
        let mut var_showWalletRecovery = <u32>::sse_decode(deserializer);
        let mut var_migrationRequired = <u32>::sse_decode(deserializer);
        let mut var_legacy = <Option<u32>>::sse_decode(deserializer);
        return crate::proton_wallet::db::model::wallet_model::WalletModel {
            id: var_id,
            name: var_name,
            passphrase: var_passphrase,
            public_key: var_publicKey,
            imported: var_imported,
            priority: var_priority,
            status: var_status,
            type_: var_type,
            create_time: var_createTime,
            modify_time: var_modifyTime,
            user_id: var_userId,
            wallet_id: var_walletId,
            account_count: var_accountCount,
            balance: var_balance,
            fingerprint: var_fingerprint,
            show_wallet_recovery: var_showWalletRecovery,
            migration_required: var_migrationRequired,
            legacy: var_legacy,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletSettingsEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletSettings =
            <Option<crate::proton_api::wallet_settings::ApiWalletSettings>>::sse_decode(
                deserializer,
            );
        return crate::proton_api::event_routes::WalletSettingsEvent {
            id: var_id,
            action: var_action,
            wallet_settings: var_walletSettings,
        };
    }
}

impl SseDecode for crate::proton_api::wallet::WalletTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_type =
            <Option<crate::proton_api::wallet::TransactionType>>::sse_decode(deserializer);
        let mut var_walletId = <String>::sse_decode(deserializer);
        let mut var_walletAccountId = <Option<String>>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_transactionId = <String>::sse_decode(deserializer);
        let mut var_transactionTime = <String>::sse_decode(deserializer);
        let mut var_isSuspicious = <u8>::sse_decode(deserializer);
        let mut var_isPrivate = <u8>::sse_decode(deserializer);
        let mut var_isAnonymous = <Option<u8>>::sse_decode(deserializer);
        let mut var_exchangeRate =
            <Option<crate::proton_api::exchange_rate::ProtonExchangeRate>>::sse_decode(
                deserializer,
            );
        let mut var_hashedTransactionId = <Option<String>>::sse_decode(deserializer);
        let mut var_subject = <Option<String>>::sse_decode(deserializer);
        let mut var_body = <Option<String>>::sse_decode(deserializer);
        let mut var_sender = <Option<String>>::sse_decode(deserializer);
        let mut var_tolist = <Option<String>>::sse_decode(deserializer);
        return crate::proton_api::wallet::WalletTransaction {
            id: var_id,
            r#type: var_type,
            wallet_id: var_walletId,
            wallet_account_id: var_walletAccountId,
            label: var_label,
            transaction_id: var_transactionId,
            transaction_time: var_transactionTime,
            is_suspicious: var_isSuspicious,
            is_private: var_isPrivate,
            is_anonymous: var_isAnonymous,
            exchange_rate: var_exchangeRate,
            hashed_transaction_id: var_hashedTransactionId,
            subject: var_subject,
            body: var_body,
            sender: var_sender,
            tolist: var_tolist,
        };
    }
}

impl SseDecode for crate::proton_api::event_routes::WalletTransactionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_action = <u32>::sse_decode(deserializer);
        let mut var_walletTransaction =
            <Option<crate::proton_api::wallet::WalletTransaction>>::sse_decode(deserializer);
        return crate::proton_api::event_routes::WalletTransactionEvent {
            id: var_id,
            action: var_action,
            wallet_transaction: var_walletTransaction,
        };
    }
}

impl SseDecode for crate::common::word_count::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::common::word_count::WordCount::Words12,
            1 => crate::common::word_count::WordCount::Words15,
            2 => crate::common::word_count::WordCount::Words18,
            3 => crate::common::word_count::WordCount::Words21,
            4 => crate::common::word_count::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", inner),
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        1 => wire__crate__api__api_service__address_client__AddressClient_get_address_balance_impl(port, ptr, rust_vec_len, data_len),
2 => wire__crate__api__api_service__address_client__AddressClient_get_scripthash_transactions_impl(port, ptr, rust_vec_len, data_len),
3 => wire__crate__api__api_service__address_client__AddressClient_get_scripthash_transactions_at_transaction_id_impl(port, ptr, rust_vec_len, data_len),
4 => wire__crate__api__api_service__address_client__AddressClient_new_impl(port, ptr, rust_vec_len, data_len),
5 => wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_add_bitcoin_addresses_impl(port, ptr, rust_vec_len, data_len),
6 => wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_get_bitcoin_address_latest_index_impl(port, ptr, rust_vec_len, data_len),
7 => wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_get_wallet_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
8 => wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_new_impl(port, ptr, rust_vec_len, data_len),
9 => wire__crate__api__api_service__bitcoin_address_client__BitcoinAddressClient_update_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
10 => wire__crate__api__api_service__block_client__BlockClient_get_tip_height_impl(port, ptr, rust_vec_len, data_len),
11 => wire__crate__api__api_service__block_client__BlockClient_new_impl(port, ptr, rust_vec_len, data_len),
12 => wire__crate__api__api_service__proton_contacts_client__ContactsClient_get_contacts_impl(port, ptr, rust_vec_len, data_len),
13 => wire__crate__api__api_service__proton_contacts_client__ContactsClient_new_impl(port, ptr, rust_vec_len, data_len),
18 => wire__crate__api__api_service__discovery_content_client__DiscoveryContentClient_get_discovery_contents_impl(port, ptr, rust_vec_len, data_len),
19 => wire__crate__api__api_service__discovery_content_client__DiscoveryContentClient_new_impl(port, ptr, rust_vec_len, data_len),
20 => wire__crate__api__api_service__email_integration_client__EmailIntegrationClient_lookup_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
21 => wire__crate__api__api_service__email_integration_client__EmailIntegrationClient_new_impl(port, ptr, rust_vec_len, data_len),
22 => wire__crate__api__api_service__event_client__EventClient_collect_events_impl(port, ptr, rust_vec_len, data_len),
23 => wire__crate__api__api_service__event_client__EventClient_get_latest_event_id_impl(port, ptr, rust_vec_len, data_len),
24 => wire__crate__api__api_service__event_client__EventClient_is_valid_token_impl(port, ptr, rust_vec_len, data_len),
25 => wire__crate__api__api_service__event_client__EventClient_new_impl(port, ptr, rust_vec_len, data_len),
26 => wire__crate__api__api_service__exchange_rate_client__ExchangeRateClient_get_exchange_rate_impl(port, ptr, rust_vec_len, data_len),
27 => wire__crate__api__api_service__exchange_rate_client__ExchangeRateClient_new_impl(port, ptr, rust_vec_len, data_len),
28 => wire__crate__api__bdk_wallet__account__FrbAccount_build_tx_impl(port, ptr, rust_vec_len, data_len),
29 => wire__crate__api__bdk_wallet__account__FrbAccount_bump_transactions_fees_impl(port, ptr, rust_vec_len, data_len),
30 => wire__crate__api__bdk_wallet__account__FrbAccount_get_address_impl(port, ptr, rust_vec_len, data_len),
31 => wire__crate__api__bdk_wallet__account__FrbAccount_get_address_from_graph_impl(port, ptr, rust_vec_len, data_len),
32 => wire__crate__api__bdk_wallet__account__FrbAccount_get_addresses_from_graph_impl(port, ptr, rust_vec_len, data_len),
33 => wire__crate__api__bdk_wallet__account__FrbAccount_get_balance_impl(port, ptr, rust_vec_len, data_len),
34 => wire__crate__api__bdk_wallet__account__FrbAccount_get_derivation_path_impl(port, ptr, rust_vec_len, data_len),
35 => wire__crate__api__bdk_wallet__account__FrbAccount_get_highest_used_address_index_in_output_impl(port, ptr, rust_vec_len, data_len),
36 => wire__crate__api__bdk_wallet__account__FrbAccount_get_maximum_gap_size_impl(port, ptr, rust_vec_len, data_len),
37 => wire__crate__api__bdk_wallet__account__FrbAccount_get_next_receive_address_impl(port, ptr, rust_vec_len, data_len),
38 => wire__crate__api__bdk_wallet__account__FrbAccount_get_transaction_impl(port, ptr, rust_vec_len, data_len),
39 => wire__crate__api__bdk_wallet__account__FrbAccount_get_transactions_impl(port, ptr, rust_vec_len, data_len),
40 => wire__crate__api__bdk_wallet__account__FrbAccount_get_utxos_impl(port, ptr, rust_vec_len, data_len),
41 => wire__crate__api__bdk_wallet__account__FrbAccount_has_sync_data_impl(port, ptr, rust_vec_len, data_len),
42 => wire__crate__api__bdk_wallet__account__FrbAccount_insert_unconfirmed_tx_impl(port, ptr, rust_vec_len, data_len),
43 => wire__crate__api__bdk_wallet__account__FrbAccount_is_mine_impl(port, ptr, rust_vec_len, data_len),
44 => wire__crate__api__bdk_wallet__account__FrbAccount_mark_receive_addresses_used_to_impl(port, ptr, rust_vec_len, data_len),
46 => wire__crate__api__bdk_wallet__account__FrbAccount_sign_impl(port, ptr, rust_vec_len, data_len),
57 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_build_database_impl(port, ptr, rust_vec_len, data_len),
58 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_delete_wallet_impl(port, ptr, rust_vec_len, data_len),
59 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_delete_wallet_account_impl(port, ptr, rust_vec_len, data_len),
60 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallet_accounts_impl(port, ptr, rust_vec_len, data_len),
61 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallet_accounts_by_wallet_id_impl(port, ptr, rust_vec_len, data_len),
62 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallets_impl(port, ptr, rust_vec_len, data_len),
63 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_all_wallets_by_user_id_impl(port, ptr, rust_vec_len, data_len),
64 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_default_wallet_by_user_id_impl(port, ptr, rust_vec_len, data_len),
65 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_wallet_account_by_account_id_impl(port, ptr, rust_vec_len, data_len),
66 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_get_wallet_by_wallet_id_impl(port, ptr, rust_vec_len, data_len),
68 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_upsert_wallet_impl(port, ptr, rust_vec_len, data_len),
69 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_upsert_wallet_account_impl(port, ptr, rust_vec_len, data_len),
70 => wire__crate__api__proton_wallet__features__backup_mnemonic__FrbBackupMnemonic_two_fa_status_impl(port, ptr, rust_vec_len, data_len),
71 => wire__crate__api__proton_wallet__features__backup_mnemonic__FrbBackupMnemonic_view_seed_impl(port, ptr, rust_vec_len, data_len),
72 => wire__crate__api__bdk_wallet__balance__FrbBalance_default_impl(port, ptr, rust_vec_len, data_len),
75 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_broadcast_psbt_impl(port, ptr, rust_vec_len, data_len),
77 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_full_sync_impl(port, ptr, rust_vec_len, data_len),
78 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_get_fees_estimation_impl(port, ptr, rust_vec_len, data_len),
79 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_get_recommended_fees_impl(port, ptr, rust_vec_len, data_len),
81 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_partial_sync_impl(port, ptr, rust_vec_len, data_len),
82 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_should_sync_impl(port, ptr, rust_vec_len, data_len),
108 => wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_disable_recovery_impl(port, ptr, rust_vec_len, data_len),
109 => wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_enable_recovery_impl(port, ptr, rust_vec_len, data_len),
110 => wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_reactive_recovery_impl(port, ptr, rust_vec_len, data_len),
111 => wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_recovery_status_impl(port, ptr, rust_vec_len, data_len),
112 => wire__crate__api__proton_wallet__features__proton_recovery__FrbProtonRecovery_two_fa_status_impl(port, ptr, rust_vec_len, data_len),
115 => wire__crate__api__proton_wallet__wallet__FrbProtonWallet_new_impl(port, ptr, rust_vec_len, data_len),
137 => wire__crate__api__bdk_wallet__transactions__FrbTransaction_compute_txid_impl(port, ptr, rust_vec_len, data_len),
142 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_constrain_recipient_amounts_impl(port, ptr, rust_vec_len, data_len),
143 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_create_draft_psbt_impl(port, ptr, rust_vec_len, data_len),
144 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_create_pbst_impl(port, ptr, rust_vec_len, data_len),
155 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_account_impl(port, ptr, rust_vec_len, data_len),
158 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_fee_rate_impl(port, ptr, rust_vec_len, data_len),
159 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_update_recipient_impl(port, ptr, rust_vec_len, data_len),
160 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_update_recipient_amount_to_max_impl(port, ptr, rust_vec_len, data_len),
163 => wire__crate__api__api_service__unleash_client__FrbUnleashClient_fetch_toggles_impl(port, ptr, rust_vec_len, data_len),
164 => wire__crate__api__api_service__unleash_client__FrbUnleashClient_new_impl(port, ptr, rust_vec_len, data_len),
167 => wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_clear_auth_dart_callback_impl(port, ptr, rust_vec_len, data_len),
169 => wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_set_get_default_user_key_callback_impl(port, ptr, rust_vec_len, data_len),
170 => wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_set_get_passphrase_callback_impl(port, ptr, rust_vec_len, data_len),
171 => wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_clear_auth_dart_callback_impl(port, ptr, rust_vec_len, data_len),
173 => wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_set_get_wallet_keys_callback_impl(port, ptr, rust_vec_len, data_len),
174 => wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_set_save_wallet_keys_callback_impl(port, ptr, rust_vec_len, data_len),
175 => wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_clear_auth_dart_callback_impl(port, ptr, rust_vec_len, data_len),
177 => wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_set_get_wallet_keys_callback_impl(port, ptr, rust_vec_len, data_len),
178 => wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_set_save_wallet_keys_callback_impl(port, ptr, rust_vec_len, data_len),
180 => wire__crate__api__bdk_wallet__wallet__FrbWallet_discover_account_impl(port, ptr, rust_vec_len, data_len),
182 => wire__crate__api__bdk_wallet__wallet__FrbWallet_get_balance_impl(port, ptr, rust_vec_len, data_len),
184 => wire__crate__api__bdk_wallet__wallet__FrbWallet_get_transaction_impl(port, ptr, rust_vec_len, data_len),
185 => wire__crate__api__bdk_wallet__wallet__FrbWallet_get_transactions_impl(port, ptr, rust_vec_len, data_len),
187 => wire__crate__api__api_service__invite_client__InviteClient_check_invite_status_impl(port, ptr, rust_vec_len, data_len),
188 => wire__crate__api__api_service__invite_client__InviteClient_get_remaining_monthly_invitation_impl(port, ptr, rust_vec_len, data_len),
189 => wire__crate__api__api_service__invite_client__InviteClient_new_impl(port, ptr, rust_vec_len, data_len),
190 => wire__crate__api__api_service__invite_client__InviteClient_send_email_integration_invite_impl(port, ptr, rust_vec_len, data_len),
191 => wire__crate__api__api_service__invite_client__InviteClient_send_newcomer_invite_impl(port, ptr, rust_vec_len, data_len),
192 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_create_on_ramp_checkout_impl(port, ptr, rust_vec_len, data_len),
193 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_countries_impl(port, ptr, rust_vec_len, data_len),
194 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_fiat_currencies_impl(port, ptr, rust_vec_len, data_len),
195 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_payment_methods_impl(port, ptr, rust_vec_len, data_len),
196 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_public_api_key_impl(port, ptr, rust_vec_len, data_len),
197 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_get_quotes_impl(port, ptr, rust_vec_len, data_len),
198 => wire__crate__api__api_service__onramp_gateway_client__OnRampGatewayClient_new_impl(port, ptr, rust_vec_len, data_len),
199 => wire__crate__api__api_service__price_graph_client__PriceGraphClient_get_graph_data_impl(port, ptr, rust_vec_len, data_len),
200 => wire__crate__api__api_service__price_graph_client__PriceGraphClient_new_impl(port, ptr, rust_vec_len, data_len),
220 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_wallets_impl(port, ptr, rust_vec_len, data_len),
221 => wire__crate__api__api_service__proton_api_service__ProtonApiService_login_impl(port, ptr, rust_vec_len, data_len),
222 => wire__crate__api__api_service__proton_api_service__ProtonApiService_logout_impl(port, ptr, rust_vec_len, data_len),
224 => wire__crate__api__api_service__proton_api_service__ProtonApiService_set_proton_api_impl(port, ptr, rust_vec_len, data_len),
225 => wire__crate__api__api_service__proton_api_service__ProtonApiService_update_auth_impl(port, ptr, rust_vec_len, data_len),
226 => wire__crate__api__api_service__proton_email_addr_client__ProtonEmailAddressClient_get_all_public_keys_impl(port, ptr, rust_vec_len, data_len),
227 => wire__crate__api__api_service__proton_email_addr_client__ProtonEmailAddressClient_get_proton_address_impl(port, ptr, rust_vec_len, data_len),
228 => wire__crate__api__api_service__proton_email_addr_client__ProtonEmailAddressClient_new_impl(port, ptr, rust_vec_len, data_len),
229 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_disable_2fa_totp_impl(port, ptr, rust_vec_len, data_len),
230 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_disable_mnemonic_settings_impl(port, ptr, rust_vec_len, data_len),
231 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_enable_2fa_totp_impl(port, ptr, rust_vec_len, data_len),
232 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_get_mnemonic_settings_impl(port, ptr, rust_vec_len, data_len),
233 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_new_impl(port, ptr, rust_vec_len, data_len),
234 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_reactive_mnemonic_settings_impl(port, ptr, rust_vec_len, data_len),
235 => wire__crate__api__api_service__proton_settings_client__ProtonSettingsClient_set_mnemonic_settings_impl(port, ptr, rust_vec_len, data_len),
236 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_auth_info_impl(port, ptr, rust_vec_len, data_len),
237 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_auth_module_impl(port, ptr, rust_vec_len, data_len),
238 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_user_info_impl(port, ptr, rust_vec_len, data_len),
239 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_get_user_settings_impl(port, ptr, rust_vec_len, data_len),
240 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_lock_sensitive_settings_impl(port, ptr, rust_vec_len, data_len),
241 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_new_impl(port, ptr, rust_vec_len, data_len),
242 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_unlock_password_change_impl(port, ptr, rust_vec_len, data_len),
243 => wire__crate__api__api_service__proton_users_client__ProtonUsersClient_unlock_sensitive_settings_impl(port, ptr, rust_vec_len, data_len),
244 => wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_clear_auth_dart_callback_impl(port, ptr, rust_vec_len, data_len),
246 => wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_logout_impl(port, ptr, rust_vec_len, data_len),
248 => wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_set_auth_dart_callback_impl(port, ptr, rust_vec_len, data_len),
250 => wire__crate__api__api_service__settings_client__SettingsClient_accept_terms_and_conditions_impl(port, ptr, rust_vec_len, data_len),
251 => wire__crate__api__api_service__settings_client__SettingsClient_bitcoin_unit_impl(port, ptr, rust_vec_len, data_len),
252 => wire__crate__api__api_service__settings_client__SettingsClient_fiat_currency_impl(port, ptr, rust_vec_len, data_len),
253 => wire__crate__api__api_service__settings_client__SettingsClient_get_user_settings_impl(port, ptr, rust_vec_len, data_len),
254 => wire__crate__api__api_service__settings_client__SettingsClient_get_user_wallet_eligibility_impl(port, ptr, rust_vec_len, data_len),
255 => wire__crate__api__api_service__settings_client__SettingsClient_hide_empty_used_addresses_impl(port, ptr, rust_vec_len, data_len),
256 => wire__crate__api__api_service__settings_client__SettingsClient_new_impl(port, ptr, rust_vec_len, data_len),
257 => wire__crate__api__api_service__settings_client__SettingsClient_receive_notification_email_impl(port, ptr, rust_vec_len, data_len),
258 => wire__crate__api__api_service__settings_client__SettingsClient_two_fa_threshold_impl(port, ptr, rust_vec_len, data_len),
259 => wire__crate__api__api_service__transaction_client__TransactionClient_get_mempool_info_impl(port, ptr, rust_vec_len, data_len),
260 => wire__crate__api__api_service__transaction_client__TransactionClient_get_raw_transaction_impl(port, ptr, rust_vec_len, data_len),
261 => wire__crate__api__api_service__transaction_client__TransactionClient_new_impl(port, ptr, rust_vec_len, data_len),
262 => wire__crate__api__api_service__wallet_client__WalletClient_add_email_address_impl(port, ptr, rust_vec_len, data_len),
263 => wire__crate__api__api_service__wallet_client__WalletClient_create_wallet_impl(port, ptr, rust_vec_len, data_len),
264 => wire__crate__api__api_service__wallet_client__WalletClient_create_wallet_account_impl(port, ptr, rust_vec_len, data_len),
265 => wire__crate__api__api_service__wallet_client__WalletClient_create_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
266 => wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_impl(port, ptr, rust_vec_len, data_len),
267 => wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_account_impl(port, ptr, rust_vec_len, data_len),
268 => wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_transaction_impl(port, ptr, rust_vec_len, data_len),
269 => wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_transaction_private_flag_impl(port, ptr, rust_vec_len, data_len),
270 => wire__crate__api__api_service__wallet_client__WalletClient_delete_wallet_transaction_suspicious_flag_impl(port, ptr, rust_vec_len, data_len),
271 => wire__crate__api__api_service__wallet_client__WalletClient_disable_show_wallet_recovery_impl(port, ptr, rust_vec_len, data_len),
272 => wire__crate__api__api_service__wallet_client__WalletClient_get_wallet_account_addresses_impl(port, ptr, rust_vec_len, data_len),
273 => wire__crate__api__api_service__wallet_client__WalletClient_get_wallet_accounts_impl(port, ptr, rust_vec_len, data_len),
274 => wire__crate__api__api_service__wallet_client__WalletClient_get_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
275 => wire__crate__api__api_service__wallet_client__WalletClient_get_wallets_impl(port, ptr, rust_vec_len, data_len),
276 => wire__crate__api__api_service__wallet_client__WalletClient_migrate_impl(port, ptr, rust_vec_len, data_len),
277 => wire__crate__api__api_service__wallet_client__WalletClient_new_impl(port, ptr, rust_vec_len, data_len),
278 => wire__crate__api__api_service__wallet_client__WalletClient_remove_email_address_impl(port, ptr, rust_vec_len, data_len),
279 => wire__crate__api__api_service__wallet_client__WalletClient_set_wallet_transaction_private_flag_impl(port, ptr, rust_vec_len, data_len),
280 => wire__crate__api__api_service__wallet_client__WalletClient_set_wallet_transaction_suspicious_flag_impl(port, ptr, rust_vec_len, data_len),
281 => wire__crate__api__api_service__wallet_client__WalletClient_update_external_wallet_transaction_sender_impl(port, ptr, rust_vec_len, data_len),
282 => wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_account_fiat_currency_impl(port, ptr, rust_vec_len, data_len),
283 => wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_account_label_impl(port, ptr, rust_vec_len, data_len),
284 => wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_account_last_used_index_impl(port, ptr, rust_vec_len, data_len),
285 => wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_accounts_order_impl(port, ptr, rust_vec_len, data_len),
286 => wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_name_impl(port, ptr, rust_vec_len, data_len),
287 => wire__crate__api__api_service__wallet_client__WalletClient_update_wallet_transaction_label_impl(port, ptr, rust_vec_len, data_len),
288 => wire__crate__api__proton_api__add_bitcoin_addresses_impl(port, ptr, rust_vec_len, data_len),
289 => wire__crate__api__proton_api__add_email_address_impl(port, ptr, rust_vec_len, data_len),
290 => wire__crate__api__proton_api__create_wallet_transactions_impl(port, ptr, rust_vec_len, data_len),
291 => wire__crate__api__proton_api__fork_impl(port, ptr, rust_vec_len, data_len),
292 => wire__crate__api__proton_api__fork_selector_impl(port, ptr, rust_vec_len, data_len),
295 => wire__crate__api__proton_wallet__features__transition_layer__frb_sender_body_default_impl(port, ptr, rust_vec_len, data_len),
296 => wire__crate__api__proton_wallet__srp__srp_client__frb_srp_client_generate_proofs_impl(port, ptr, rust_vec_len, data_len),
298 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_messages_impl(port, ptr, rust_vec_len, data_len),
299 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_transaction_id_impl(port, ptr, rust_vec_len, data_len),
300 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_transaction_ids_impl(port, ptr, rust_vec_len, data_len),
301 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_wallet_key_impl(port, ptr, rust_vec_len, data_len),
302 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_decrypt_wallet_key_legacy_impl(port, ptr, rust_vec_len, data_len),
303 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_encrypt_messages_with_keys_impl(port, ptr, rust_vec_len, data_len),
304 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_encrypt_messages_with_userkey_impl(port, ptr, rust_vec_len, data_len),
305 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_encrypt_wallet_key_impl(port, ptr, rust_vec_len, data_len),
307 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_sign_impl(port, ptr, rust_vec_len, data_len),
308 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_verify_signature_impl(port, ptr, rust_vec_len, data_len),
315 => wire__crate__api__proton_api__get_exchange_rate_impl(port, ptr, rust_vec_len, data_len),
316 => wire__crate__api__proton_api__get_proton_address_impl(port, ptr, rust_vec_len, data_len),
317 => wire__crate__api__proton_api__get_wallet_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
318 => wire__crate__api__init__init_app_impl(port, ptr, rust_vec_len, data_len),
321 => wire__crate__api__proton_api__lookup_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
322 => wire__crate__api__proton_api__update_bitcoin_address_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        14 => wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_derivation_path_impl(ptr, rust_vec_len, data_len),
15 => wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_index_impl(ptr, rust_vec_len, data_len),
16 => wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_new_impl(ptr, rust_vec_len, data_len),
17 => wire__crate__api__bdk_wallet__discovered_account__DiscoveredAccount_script_type_impl(ptr, rust_vec_len, data_len),
45 => wire__crate__api__bdk_wallet__account__FrbAccount_new_impl(ptr, rust_vec_len, data_len),
47 => wire__crate__api__bdk_wallet__address__FrbAddressDetails_address_impl(ptr, rust_vec_len, data_len),
48 => wire__crate__api__bdk_wallet__address__FrbAddressDetails_balance_impl(ptr, rust_vec_len, data_len),
49 => wire__crate__api__bdk_wallet__address__FrbAddressDetails_index_impl(ptr, rust_vec_len, data_len),
50 => wire__crate__api__bdk_wallet__address__FrbAddressDetails_transactions_impl(ptr, rust_vec_len, data_len),
51 => wire__crate__api__bdk_wallet__address__FrbAddress_from_script_impl(ptr, rust_vec_len, data_len),
52 => wire__crate__api__bdk_wallet__address__FrbAddress_into_script_impl(ptr, rust_vec_len, data_len),
53 => wire__crate__api__bdk_wallet__address__FrbAddress_new_impl(ptr, rust_vec_len, data_len),
54 => wire__crate__api__bdk_wallet__address__FrbAddress_to_string_impl(ptr, rust_vec_len, data_len),
55 => wire__crate__api__bdk_wallet__amount__FrbAmount_to_btc_impl(ptr, rust_vec_len, data_len),
56 => wire__crate__api__bdk_wallet__amount__FrbAmount_to_sat_impl(ptr, rust_vec_len, data_len),
67 => wire__crate__api__proton_wallet__db__app_database_helper__FrbAppDatabase_new_impl(ptr, rust_vec_len, data_len),
73 => wire__crate__api__bdk_wallet__balance__FrbBalance_total_impl(ptr, rust_vec_len, data_len),
74 => wire__crate__api__bdk_wallet__balance__FrbBalance_trusted_spendable_impl(ptr, rust_vec_len, data_len),
76 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_create_esplora_blockchain_impl(ptr, rust_vec_len, data_len),
80 => wire__crate__api__bdk_wallet__blockchain__FrbBlockchainClient_new_impl(ptr, rust_vec_len, data_len),
83 => wire__crate__api__bdk_wallet__derivation_path__FrbDerivationPath_from_parts_impl(ptr, rust_vec_len, data_len),
84 => wire__crate__api__bdk_wallet__derivation_path__FrbDerivationPath_new_impl(ptr, rust_vec_len, data_len),
85 => wire__crate__api__bdk_wallet__transaction_details_txin__FrbDetailledTxIn_previous_output_impl(ptr, rust_vec_len, data_len),
86 => wire__crate__api__bdk_wallet__transaction_details_txin__FrbDetailledTxIn_script_sig_impl(ptr, rust_vec_len, data_len),
87 => wire__crate__api__bdk_wallet__transaction_details_txin__FrbDetailledTxIn_sequence_impl(ptr, rust_vec_len, data_len),
88 => wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_address_impl(ptr, rust_vec_len, data_len),
89 => wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_is_mine_impl(ptr, rust_vec_len, data_len),
90 => wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_script_pubkey_impl(ptr, rust_vec_len, data_len),
91 => wire__crate__api__bdk_wallet__transaction_details_txop__FrbDetailledTxOutput_value_impl(ptr, rust_vec_len, data_len),
92 => wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_confirmation_time_impl(ptr, rust_vec_len, data_len),
93 => wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_derivation_index_impl(ptr, rust_vec_len, data_len),
94 => wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_is_spent_impl(ptr, rust_vec_len, data_len),
95 => wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_keychain_impl(ptr, rust_vec_len, data_len),
96 => wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_outpoint_impl(ptr, rust_vec_len, data_len),
97 => wire__crate__api__bdk_wallet__local_output__FrbLocalOutput_txout_impl(ptr, rust_vec_len, data_len),
98 => wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_as_string_impl(ptr, rust_vec_len, data_len),
99 => wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_as_words_impl(ptr, rust_vec_len, data_len),
100 => wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_from_string_impl(ptr, rust_vec_len, data_len),
101 => wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_get_words_autocomplete_impl(ptr, rust_vec_len, data_len),
102 => wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_new_impl(ptr, rust_vec_len, data_len),
103 => wire__crate__api__bdk_wallet__mnemonic__FrbMnemonic_new_with_impl(ptr, rust_vec_len, data_len),
104 => wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_to_address_impl(ptr, rust_vec_len, data_len),
105 => wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_to_string_impl(ptr, rust_vec_len, data_len),
106 => wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_to_uri_impl(ptr, rust_vec_len, data_len),
107 => wire__crate__api__bdk_wallet__payment_link__FrbPaymentLink_try_parse_impl(ptr, rust_vec_len, data_len),
113 => wire__crate__api__proton_wallet__wallet__FrbProtonWallet_get_backup_mnemonic_feature_impl(ptr, rust_vec_len, data_len),
114 => wire__crate__api__proton_wallet__wallet__FrbProtonWallet_get_proton_recovery_feature_impl(ptr, rust_vec_len, data_len),
116 => wire__crate__api__bdk_wallet__psbt__FrbPsbt_compute_tx_vbytes_impl(ptr, rust_vec_len, data_len),
117 => wire__crate__api__bdk_wallet__psbt__FrbPsbt_extract_tx_impl(ptr, rust_vec_len, data_len),
118 => wire__crate__api__bdk_wallet__psbt__FrbPsbt_fee_impl(ptr, rust_vec_len, data_len),
119 => wire__crate__api__bdk_wallet__psbt__FrbPsbt_recipients_impl(ptr, rust_vec_len, data_len),
120 => wire__crate__api__bdk_wallet__psbt__FrbPsbt_total_fees_impl(ptr, rust_vec_len, data_len),
121 => wire__crate__api__bdk_wallet__script_buf__FrbScriptBuf_new_impl(ptr, rust_vec_len, data_len),
122 => wire__crate__api__bdk_wallet__script_buf__FrbScriptBuf_to_bytes_impl(ptr, rust_vec_len, data_len),
123 => wire__crate__api__bdk_wallet__sequence__FrbSequence_is_final_impl(ptr, rust_vec_len, data_len),
124 => wire__crate__api__bdk_wallet__sequence__FrbSequence_is_height_locked_impl(ptr, rust_vec_len, data_len),
125 => wire__crate__api__bdk_wallet__sequence__FrbSequence_is_rbf_impl(ptr, rust_vec_len, data_len),
126 => wire__crate__api__bdk_wallet__sequence__FrbSequence_is_relative_lock_time_impl(ptr, rust_vec_len, data_len),
127 => wire__crate__api__bdk_wallet__sequence__FrbSequence_is_time_locked_impl(ptr, rust_vec_len, data_len),
128 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_account_derivation_path_impl(ptr, rust_vec_len, data_len),
129 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_fees_impl(ptr, rust_vec_len, data_len),
130 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_inputs_impl(ptr, rust_vec_len, data_len),
131 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_outputs_impl(ptr, rust_vec_len, data_len),
132 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_received_impl(ptr, rust_vec_len, data_len),
133 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_sent_impl(ptr, rust_vec_len, data_len),
134 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_time_impl(ptr, rust_vec_len, data_len),
135 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_txid_impl(ptr, rust_vec_len, data_len),
136 => wire__crate__api__bdk_wallet__transaction_details__FrbTransactionDetails_vbytes_size_impl(ptr, rust_vec_len, data_len),
138 => wire__crate__api__bdk_wallet__transactions__FrbTransaction_new_impl(ptr, rust_vec_len, data_len),
139 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_add_recipient_impl(ptr, rust_vec_len, data_len),
140 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_clear_recipients_impl(ptr, rust_vec_len, data_len),
141 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_clear_utxos_to_spend_impl(ptr, rust_vec_len, data_len),
145 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_disable_rbf_impl(ptr, rust_vec_len, data_len),
146 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_enable_rbf_impl(ptr, rust_vec_len, data_len),
147 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_change_policy_impl(ptr, rust_vec_len, data_len),
148 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_coin_selection_impl(ptr, rust_vec_len, data_len),
149 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_fee_rate_impl(ptr, rust_vec_len, data_len),
150 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_rbf_enabled_impl(ptr, rust_vec_len, data_len),
151 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_get_utxos_to_spend_impl(ptr, rust_vec_len, data_len),
152 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_new_impl(ptr, rust_vec_len, data_len),
153 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_remove_locktime_impl(ptr, rust_vec_len, data_len),
154 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_remove_recipient_impl(ptr, rust_vec_len, data_len),
156 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_change_policy_impl(ptr, rust_vec_len, data_len),
157 => wire__crate__api__bdk_wallet__transaction_builder__FrbTxBuilder_set_coin_selection_impl(ptr, rust_vec_len, data_len),
161 => wire__crate__api__bdk_wallet__local_output__FrbTxOut_script_pubkey_impl(ptr, rust_vec_len, data_len),
162 => wire__crate__api__bdk_wallet__local_output__FrbTxOut_value_impl(ptr, rust_vec_len, data_len),
165 => wire__crate__api__proton_wallet__crypto__wallet_key__FrbUnlockedWalletKey_to_base64_impl(ptr, rust_vec_len, data_len),
166 => wire__crate__api__proton_wallet__crypto__wallet_key__FrbUnlockedWalletKey_to_entropy_impl(ptr, rust_vec_len, data_len),
168 => wire__crate__api__proton_wallet__storage__user_key_store__FrbUserKeyStore_new_impl(ptr, rust_vec_len, data_len),
172 => wire__crate__api__proton_wallet__storage__wallet_key_store__FrbWalletKeyStore_new_impl(ptr, rust_vec_len, data_len),
176 => wire__crate__api__proton_wallet__storage__wallet_mnemonic_store__FrbWalletMnemonicStore_new_impl(ptr, rust_vec_len, data_len),
179 => wire__crate__api__bdk_wallet__wallet__FrbWallet_add_account_impl(ptr, rust_vec_len, data_len),
181 => wire__crate__api__bdk_wallet__wallet__FrbWallet_get_account_impl(ptr, rust_vec_len, data_len),
183 => wire__crate__api__bdk_wallet__wallet__FrbWallet_get_fingerprint_impl(ptr, rust_vec_len, data_len),
186 => wire__crate__api__bdk_wallet__wallet__FrbWallet_new_impl(ptr, rust_vec_len, data_len),
201 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_address_client_impl(ptr, rust_vec_len, data_len),
202 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_arc_impl(ptr, rust_vec_len, data_len),
203 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_bitcoin_addr_client_impl(ptr, rust_vec_len, data_len),
204 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_block_client_impl(ptr, rust_vec_len, data_len),
205 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_discovery_content_client_impl(ptr, rust_vec_len, data_len),
206 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_email_integration_client_impl(ptr, rust_vec_len, data_len),
207 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_event_client_impl(ptr, rust_vec_len, data_len),
208 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_exchange_rate_client_impl(ptr, rust_vec_len, data_len),
209 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_invite_client_impl(ptr, rust_vec_len, data_len),
210 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_on_ramp_gateway_client_impl(ptr, rust_vec_len, data_len),
211 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_price_graph_client_impl(ptr, rust_vec_len, data_len),
212 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_contacts_client_impl(ptr, rust_vec_len, data_len),
213 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_email_addr_client_impl(ptr, rust_vec_len, data_len),
214 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_settings_client_impl(ptr, rust_vec_len, data_len),
215 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_proton_user_client_impl(ptr, rust_vec_len, data_len),
216 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_settings_client_impl(ptr, rust_vec_len, data_len),
217 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_transaction_client_impl(ptr, rust_vec_len, data_len),
218 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_unleash_client_impl(ptr, rust_vec_len, data_len),
219 => wire__crate__api__api_service__proton_api_service__ProtonApiService_get_wallet_client_impl(ptr, rust_vec_len, data_len),
223 => wire__crate__api__api_service__proton_api_service__ProtonApiService_new_impl(ptr, rust_vec_len, data_len),
245 => wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_from_session_impl(ptr, rust_vec_len, data_len),
247 => wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_new_impl(ptr, rust_vec_len, data_len),
249 => wire__crate__api__api_service__wallet_auth_store__ProtonWalletAuthStore_set_auth_sync_impl(ptr, rust_vec_len, data_len),
293 => wire__crate__api__proton_wallet__crypto__wallet_key__frb_locked_wallet_key_get_armored_impl(ptr, rust_vec_len, data_len),
294 => wire__crate__api__proton_wallet__crypto__wallet_key__frb_locked_wallet_key_get_signature_impl(ptr, rust_vec_len, data_len),
297 => wire__crate__api__proton_wallet__srp__srp_client__frb_srp_client_new_impl(ptr, rust_vec_len, data_len),
306 => wire__crate__api__proton_wallet__features__transition_layer__frb_transition_layer_get_hmac_hashed_string_impl(ptr, rust_vec_len, data_len),
309 => wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_decrypt_impl(ptr, rust_vec_len, data_len),
310 => wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_encrypt_impl(ptr, rust_vec_len, data_len),
311 => wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_generate_secret_key_impl(ptr, rust_vec_len, data_len),
312 => wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_generate_secret_key_as_base64_impl(ptr, rust_vec_len, data_len),
313 => wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_get_secure_random_impl(ptr, rust_vec_len, data_len),
314 => wire__crate__api__proton_wallet__crypto__wallet_key_helper__frb_wallet_key_helper_restore_impl(ptr, rust_vec_len, data_len),
319 => wire__crate__api__logger__init_rust_logging_impl(ptr, rust_vec_len, data_len),
320 => wire__crate__api__panic_hook__initialize_panic_hook_impl(ptr, rust_vec_len, data_len),
323 => wire__crate__api__bdk_wallet__storage__wallet_mobile_connector_factory_new_impl(ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressBalance> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressBalance>> for AddressBalance {
    fn into_into_dart(self) -> FrbWrapper<AddressBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressClient>> for AddressClient {
    fn into_into_dart(self) -> FrbWrapper<AddressClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ApiTx> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ApiTx> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ApiTx>> for ApiTx {
    fn into_into_dart(self) -> FrbWrapper<ApiTx> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<ProtonAPIService>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Arc<ProtonAPIService>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<ProtonAPIService>>>
    for Arc<ProtonAPIService>
{
    fn into_into_dart(self) -> FrbWrapper<Arc<ProtonAPIService>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddressClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinAddressClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddressClient>> for BitcoinAddressClient {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddressClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BlockClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BlockClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BlockClient>> for BlockClient {
    fn into_into_dart(self) -> FrbWrapper<BlockClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ContactsClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ContactsClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ContactsClient>> for ContactsClient {
    fn into_into_dart(self) -> FrbWrapper<ContactsClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DiscoveredAccount> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<DiscoveredAccount> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DiscoveredAccount>> for DiscoveredAccount {
    fn into_into_dart(self) -> FrbWrapper<DiscoveredAccount> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DiscoveryContentClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<DiscoveryContentClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DiscoveryContentClient>>
    for DiscoveryContentClient
{
    fn into_into_dart(self) -> FrbWrapper<DiscoveryContentClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EmailIntegrationClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<EmailIntegrationClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EmailIntegrationClient>>
    for EmailIntegrationClient
{
    fn into_into_dart(self) -> FrbWrapper<EmailIntegrationClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EventClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EventClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EventClient>> for EventClient {
    fn into_into_dart(self) -> FrbWrapper<EventClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ExchangeRateClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ExchangeRateClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ExchangeRateClient>> for ExchangeRateClient {
    fn into_into_dart(self) -> FrbWrapper<ExchangeRateClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbAccount> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbAccount> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbAccount>> for FrbAccount {
    fn into_into_dart(self) -> FrbWrapper<FrbAccount> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbAddress>> for FrbAddress {
    fn into_into_dart(self) -> FrbWrapper<FrbAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbAddressDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbAddressDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbAddressDetails>> for FrbAddressDetails {
    fn into_into_dart(self) -> FrbWrapper<FrbAddressDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbAmount> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbAmount> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbAmount>> for FrbAmount {
    fn into_into_dart(self) -> FrbWrapper<FrbAmount> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbAppDatabase> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbAppDatabase> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbAppDatabase>> for FrbAppDatabase {
    fn into_into_dart(self) -> FrbWrapper<FrbAppDatabase> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbBackupMnemonic> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbBackupMnemonic> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbBackupMnemonic>> for FrbBackupMnemonic {
    fn into_into_dart(self) -> FrbWrapper<FrbBackupMnemonic> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbBalance> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbBalance>> for FrbBalance {
    fn into_into_dart(self) -> FrbWrapper<FrbBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbBlockchainClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FrbBlockchainClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbBlockchainClient>> for FrbBlockchainClient {
    fn into_into_dart(self) -> FrbWrapper<FrbBlockchainClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbDerivationPath> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbDerivationPath> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbDerivationPath>> for FrbDerivationPath {
    fn into_into_dart(self) -> FrbWrapper<FrbDerivationPath> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbDetailledTxIn> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbDetailledTxIn> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbDetailledTxIn>> for FrbDetailledTxIn {
    fn into_into_dart(self) -> FrbWrapper<FrbDetailledTxIn> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbDetailledTxOutput> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FrbDetailledTxOutput>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbDetailledTxOutput>> for FrbDetailledTxOutput {
    fn into_into_dart(self) -> FrbWrapper<FrbDetailledTxOutput> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbLocalOutput> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbLocalOutput> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbLocalOutput>> for FrbLocalOutput {
    fn into_into_dart(self) -> FrbWrapper<FrbLocalOutput> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbMnemonic> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbMnemonic> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbMnemonic>> for FrbMnemonic {
    fn into_into_dart(self) -> FrbWrapper<FrbMnemonic> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbPaymentLink> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbPaymentLink> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbPaymentLink>> for FrbPaymentLink {
    fn into_into_dart(self) -> FrbWrapper<FrbPaymentLink> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbProtonRecovery> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbProtonRecovery> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbProtonRecovery>> for FrbProtonRecovery {
    fn into_into_dart(self) -> FrbWrapper<FrbProtonRecovery> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbProtonWallet> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbProtonWallet> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbProtonWallet>> for FrbProtonWallet {
    fn into_into_dart(self) -> FrbWrapper<FrbProtonWallet> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbPsbt> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbPsbt> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbPsbt>> for FrbPsbt {
    fn into_into_dart(self) -> FrbWrapper<FrbPsbt> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbScriptBuf> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbScriptBuf> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbScriptBuf>> for FrbScriptBuf {
    fn into_into_dart(self) -> FrbWrapper<FrbScriptBuf> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbSequence> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbSequence> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbSequence>> for FrbSequence {
    fn into_into_dart(self) -> FrbWrapper<FrbSequence> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbTransaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbTransaction> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbTransaction>> for FrbTransaction {
    fn into_into_dart(self) -> FrbWrapper<FrbTransaction> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbTransactionDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FrbTransactionDetails>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbTransactionDetails>>
    for FrbTransactionDetails
{
    fn into_into_dart(self) -> FrbWrapper<FrbTransactionDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbTxBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbTxBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbTxBuilder>> for FrbTxBuilder {
    fn into_into_dart(self) -> FrbWrapper<FrbTxBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbTxOut> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbTxOut> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbTxOut>> for FrbTxOut {
    fn into_into_dart(self) -> FrbWrapper<FrbTxOut> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbUnleashClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbUnleashClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbUnleashClient>> for FrbUnleashClient {
    fn into_into_dart(self) -> FrbWrapper<FrbUnleashClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbUnlockedWalletKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FrbUnlockedWalletKey>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbUnlockedWalletKey>> for FrbUnlockedWalletKey {
    fn into_into_dart(self) -> FrbWrapper<FrbUnlockedWalletKey> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbUserKeyStore> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbUserKeyStore> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbUserKeyStore>> for FrbUserKeyStore {
    fn into_into_dart(self) -> FrbWrapper<FrbUserKeyStore> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbWallet> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbWallet> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbWallet>> for FrbWallet {
    fn into_into_dart(self) -> FrbWrapper<FrbWallet> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbWalletKeyStore> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FrbWalletKeyStore> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbWalletKeyStore>> for FrbWalletKeyStore {
    fn into_into_dart(self) -> FrbWrapper<FrbWalletKeyStore> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FrbWalletMnemonicStore> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<FrbWalletMnemonicStore>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FrbWalletMnemonicStore>>
    for FrbWalletMnemonicStore
{
    fn into_into_dart(self) -> FrbWrapper<FrbWalletMnemonicStore> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<InviteClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<InviteClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<InviteClient>> for InviteClient {
    fn into_into_dart(self) -> FrbWrapper<InviteClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OnRampGatewayClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<OnRampGatewayClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OnRampGatewayClient>> for OnRampGatewayClient {
    fn into_into_dart(self) -> FrbWrapper<OnRampGatewayClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PriceGraphClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PriceGraphClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PriceGraphClient>> for PriceGraphClient {
    fn into_into_dart(self) -> FrbWrapper<PriceGraphClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonAPIService> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ProtonAPIService> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonAPIService>> for ProtonAPIService {
    fn into_into_dart(self) -> FrbWrapper<ProtonAPIService> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonEmailAddressClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ProtonEmailAddressClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonEmailAddressClient>>
    for ProtonEmailAddressClient
{
    fn into_into_dart(self) -> FrbWrapper<ProtonEmailAddressClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonSettingsClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ProtonSettingsClient>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonSettingsClient>> for ProtonSettingsClient {
    fn into_into_dart(self) -> FrbWrapper<ProtonSettingsClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonUsersClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ProtonUsersClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonUsersClient>> for ProtonUsersClient {
    fn into_into_dart(self) -> FrbWrapper<ProtonUsersClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ProtonWalletAuthStore> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ProtonWalletAuthStore>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ProtonWalletAuthStore>>
    for ProtonWalletAuthStore
{
    fn into_into_dart(self) -> FrbWrapper<ProtonWalletAuthStore> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SettingsClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SettingsClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SettingsClient>> for SettingsClient {
    fn into_into_dart(self) -> FrbWrapper<SettingsClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TransactionClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TransactionClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TransactionClient>> for TransactionClient {
    fn into_into_dart(self) -> FrbWrapper<TransactionClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<WalletClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<WalletClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<WalletClient>> for WalletClient {
    fn into_into_dart(self) -> FrbWrapper<WalletClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<bdkTransaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<bdkTransaction> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<bdkTransaction>> for bdkTransaction {
    fn into_into_dart(self) -> FrbWrapper<bdkTransaction> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::proton_wallet::db::model::account_model::AccountModel
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.account_id.into_into_dart().into_dart(),
            self.wallet_id.into_into_dart().into_dart(),
            self.derivation_path.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.script_type.into_into_dart().into_dart(),
            self.create_time.into_into_dart().into_dart(),
            self.modify_time.into_into_dart().into_dart(),
            self.fiat_currency.into_into_dart().into_dart(),
            self.priority.into_into_dart().into_dart(),
            self.last_used_index.into_into_dart().into_dart(),
            self.pool_size.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_wallet::db::model::account_model::AccountModel
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_wallet::db::model::account_model::AccountModel>
    for crate::proton_wallet::db::model::account_model::AccountModel
{
    fn into_into_dart(self) -> crate::proton_wallet::db::model::account_model::AccountModel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::proton_address::AllKeyAddressKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.flags.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.source.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::proton_address::AllKeyAddressKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::proton_address::AllKeyAddressKey>
    for crate::proton_api::proton_address::AllKeyAddressKey
{
    fn into_into_dart(self) -> crate::proton_api::proton_address::AllKeyAddressKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::contacts::ApiContactEmails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
            self.0.Email.into_into_dart().into_dart(),
            self.0.CanonicalEmail.into_into_dart().into_dart(),
            self.0.IsProton.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::contacts::ApiContactEmails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::contacts::ApiContactEmails>>
    for crate::proton_api::contacts::ApiContactEmails
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::contacts::ApiContactEmails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::payment_gateway::ApiCountry> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Code.into_into_dart().into_dart(),
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::ApiCountry>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::payment_gateway::ApiCountry>>
    for crate::proton_api::payment_gateway::ApiCountry
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::ApiCountry> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Email.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress>,
    > for crate::proton_api::wallet_account::ApiEmailAddress
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet_account::ApiEmailAddress> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::ApiMnemonicUserKey>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.PrivateKey.into_into_dart().into_dart(),
            self.0.Salt.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::ApiMnemonicUserKey>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::ApiMnemonicUserKey>,
    > for crate::proton_api::proton_users::ApiMnemonicUserKey
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::ApiMnemonicUserKey> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Name.into_into_dart().into_dart(),
            self.0.Symbol.into_into_dart().into_dart(),
            self.0.MinimumAmount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    > for crate::proton_api::payment_gateway::ApiSimpleFiatCurrency
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::ApiWallet> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
            self.0.IsImported.into_into_dart().into_dart(),
            self.0.Priority.into_into_dart().into_dart(),
            self.0.Type.into_into_dart().into_dart(),
            self.0.HasPassphrase.into_into_dart().into_dart(),
            self.0.Status.into_into_dart().into_dart(),
            self.0.Mnemonic.into_into_dart().into_dart(),
            self.0.Fingerprint.into_into_dart().into_dart(),
            self.0.PublicKey.into_into_dart().into_dart(),
            self.0.MigrationRequired.into_into_dart().into_dart(),
            self.0.Legacy.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWallet>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::ApiWallet>>
    for crate::proton_api::wallet::ApiWallet
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWallet> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.DerivationPath.into_into_dart().into_dart(),
            self.0.Label.into_into_dart().into_dart(),
            self.0.LastUsedIndex.into_into_dart().into_dart(),
            self.0.PoolSize.into_into_dart().into_dart(),
            self.0.Priority.into_into_dart().into_dart(),
            self.0.ScriptType.into_into_dart().into_dart(),
            self.0.StopGap.into_into_dart().into_dart(),
            self.0.Addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount>,
    > for crate::proton_api::wallet_account::ApiWalletAccount
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet_account::ApiWalletAccount> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.WalletAccountID.into_into_dart().into_dart(),
            self.0.Fetched.into_into_dart().into_dart(),
            self.0.Used.into_into_dart().into_dart(),
            self.0.BitcoinAddress.into_into_dart().into_dart(),
            self.0.BitcoinAddressSignature.into_into_dart().into_dart(),
            self.0.BitcoinAddressIndex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress>,
    > for crate::proton_api::wallet::ApiWalletBitcoinAddress
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWalletBitcoinAddress> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::ApiWalletData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Wallet.into_into_dart().into_dart(),
            self.0.WalletKey.into_into_dart().into_dart(),
            self.0.WalletSettings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWalletData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::ApiWalletData>>
    for crate::proton_api::wallet::ApiWalletData
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWalletData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::ApiWalletKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.UserKeyID.into_into_dart().into_dart(),
            self.0.WalletKey.into_into_dart().into_dart(),
            self.0.WalletKeySignature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::ApiWalletKey>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::ApiWalletKey>>
    for crate::proton_api::wallet::ApiWalletKey
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::ApiWalletKey> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.WalletID.into_into_dart().into_dart(),
            self.0.HideAccounts.into_into_dart().into_dart(),
            self.0
                .InvoiceDefaultDescription
                .into_into_dart()
                .into_dart(),
            self.0.InvoiceExpirationTime.into_into_dart().into_dart(),
            self.0.MaxChannelOpeningFee.into_into_dart().into_dart(),
            self.0.ShowWalletRecovery.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings>,
    > for crate::proton_api::wallet_settings::ApiWalletSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet_settings::ApiWalletSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.BitcoinUnit.into_into_dart().into_dart(),
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.HideEmptyUsedAddresses.into_into_dart().into_dart(),
            self.0.TwoFactorAmountThreshold.into_into_dart().into_dart(),
            self.0
                .ReceiveInviterNotification
                .into_into_dart()
                .into_dart(),
            self.0
                .ReceiveEmailIntegrationNotification
                .into_into_dart()
                .into_dart(),
            self.0
                .ReceiveTransactionNotification
                .into_into_dart()
                .into_dart(),
            self.0.WalletCreated.into_into_dart().into_dart(),
            self.0.AcceptTermsAndConditions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings>,
    > for crate::proton_api::user_settings::ApiWalletUserSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::user_settings::ApiWalletUserSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::auth_credential::AuthCredential {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.session_id.into_into_dart().into_dart(),
            self.user_id.into_into_dart().into_dart(),
            self.access_token.into_into_dart().into_dart(),
            self.refresh_token.into_into_dart().into_dart(),
            self.event_id.into_into_dart().into_dart(),
            self.user_mail.into_into_dart().into_dart(),
            self.user_name.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.scops.into_into_dart().into_dart(),
            self.user_key_id.into_into_dart().into_dart(),
            self.user_private_key.into_into_dart().into_dart(),
            self.user_passphrase.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::auth_credential::AuthCredential
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::auth_credential::AuthCredential>
    for crate::proton_api::auth_credential::AuthCredential
{
    fn into_into_dart(self) -> crate::proton_api::auth_credential::AuthCredential {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::BitcoinAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.bitcoin_address.into_into_dart().into_dart(),
            self.bitcoin_address_signature.into_into_dart().into_dart(),
            self.bitcoin_address_index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::BitcoinAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::BitcoinAddress>
    for crate::proton_api::wallet::BitcoinAddress
{
    fn into_into_dart(self) -> crate::proton_api::wallet::BitcoinAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::user_settings::BitcoinUnit> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::user_settings::BitcoinUnit::BTC => 0.into_dart(),
            crate::proton_api::user_settings::BitcoinUnit::MBTC => 1.into_dart(),
            crate::proton_api::user_settings::BitcoinUnit::SATS => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::BitcoinUnit>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::user_settings::BitcoinUnit>>
    for crate::proton_api::user_settings::BitcoinUnit
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::user_settings::BitcoinUnit> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::errors::BridgeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::errors::BridgeError::ApiLock(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::Generic(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::MuonAuthSession(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::MuonAuthRefresh(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::MuonClient(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::MuonSession(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::AndromedaBitcoin(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::ApiResponse(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::ApiSrp(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::AesGcm(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::WalletCrypto(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::WalletFeature(field0) => {
                [11.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::Login(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::Fork(field0) => {
                [13.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::errors::BridgeError::Database(field0) => {
                [14.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::errors::BridgeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::errors::BridgeError>
    for crate::api::errors::BridgeError
{
    fn into_into_dart(self) -> crate::api::errors::BridgeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::common::broadcast_message::BroadcastMessage>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.DataPacket.into_into_dart().into_dart(),
            self.0.KeyPackets.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::broadcast_message::BroadcastMessage>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::common::broadcast_message::BroadcastMessage>,
    > for crate::common::broadcast_message::BroadcastMessage
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::broadcast_message::BroadcastMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::common::change_spend_policy::ChangeSpendPolicy>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::change_spend_policy::ChangeSpendPolicy::ChangeAllowed => 0.into_dart(),
            crate::common::change_spend_policy::ChangeSpendPolicy::OnlyChange => 1.into_dart(),
            crate::common::change_spend_policy::ChangeSpendPolicy::ChangeForbidden => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::change_spend_policy::ChangeSpendPolicy>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::common::change_spend_policy::ChangeSpendPolicy>,
    > for crate::common::change_spend_policy::ChangeSpendPolicy
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::change_spend_policy::ChangeSpendPolicy> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::auth_credential::ChildSession>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.session_id.into_into_dart().into_dart(),
            self.0.access_token.into_into_dart().into_dart(),
            self.0.refresh_token.into_into_dart().into_dart(),
            self.0.scopes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::auth_credential::ChildSession>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::auth_credential::ChildSession>>
    for crate::proton_api::auth_credential::ChildSession
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::auth_credential::ChildSession> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::coin_selection::CoinSelection> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::coin_selection::CoinSelection::BranchAndBound => 0.into_dart(),
            crate::common::coin_selection::CoinSelection::LargestFirst => 1.into_dart(),
            crate::common::coin_selection::CoinSelection::OldestFirst => 2.into_dart(),
            crate::common::coin_selection::CoinSelection::Manual => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::coin_selection::CoinSelection>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::coin_selection::CoinSelection>>
    for crate::common::coin_selection::CoinSelection
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::coin_selection::CoinSelection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::common::confirmation_time::ConfirmationTime>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::confirmation_time::ConfirmationTime::Confirmed { height, time } => [
                0.into_dart(),
                height.into_into_dart().into_dart(),
                time.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::common::confirmation_time::ConfirmationTime::Unconfirmed { last_seen } => {
                [1.into_dart(), last_seen.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::confirmation_time::ConfirmationTime>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::common::confirmation_time::ConfirmationTime>,
    > for crate::common::confirmation_time::ConfirmationTime
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::confirmation_time::ConfirmationTime> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::ContactEmailEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.contact_email.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::ContactEmailEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::ContactEmailEvent>
    for crate::proton_api::event_routes::ContactEmailEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::ContactEmailEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::discovery_content::Content> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Title.into_into_dart().into_dart(),
            self.0.Link.into_into_dart().into_dart(),
            self.0.Description.into_into_dart().into_dart(),
            self.0.PubDate.into_into_dart().into_dart(),
            self.0.Author.into_into_dart().into_dart(),
            self.0.Category.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::discovery_content::Content>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::discovery_content::Content>>
    for crate::proton_api::discovery_content::Content
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::discovery_content::Content> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet_account::CreateWalletAccountReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.label.into_into_dart().into_dart(),
            self.derivation_path.into_into_dart().into_dart(),
            self.script_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet_account::CreateWalletAccountReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet_account::CreateWalletAccountReq>
    for crate::proton_api::wallet_account::CreateWalletAccountReq
{
    fn into_into_dart(self) -> crate::proton_api::wallet_account::CreateWalletAccountReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::CreateWalletReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.is_imported.into_into_dart().into_dart(),
            self.r#type.into_into_dart().into_dart(),
            self.has_passphrase.into_into_dart().into_dart(),
            self.user_key_id.into_into_dart().into_dart(),
            self.wallet_key.into_into_dart().into_dart(),
            self.mnemonic.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.fingerprint.into_into_dart().into_dart(),
            self.wallet_key_signature.into_into_dart().into_dart(),
            self.is_auto_created.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::CreateWalletReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::CreateWalletReq>
    for crate::proton_api::wallet::CreateWalletReq
{
    fn into_into_dart(self) -> crate::proton_api::wallet::CreateWalletReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::price_graph::DataPoint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ExchangeRate.into_into_dart().into_dart(),
            self.0.Cents.into_into_dart().into_dart(),
            self.0.Timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::price_graph::DataPoint>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::price_graph::DataPoint>>
    for crate::proton_api::price_graph::DataPoint
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::price_graph::DataPoint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.bitcoin_address.into_into_dart().into_dart(),
            self.bitcoin_address_signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::EmailIntegrationBitcoinAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::EmailIntegrationBitcoinAddress>
    for crate::proton_api::wallet::EmailIntegrationBitcoinAddress
{
    fn into_into_dart(self) -> crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::EmailSettings> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Value.into_into_dart().into_dart(),
            self.0.Status.into_into_dart().into_dart(),
            self.0.Notify.into_into_dart().into_dart(),
            self.0.Reset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::EmailSettings>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::EmailSettings>>
    for crate::proton_api::proton_users::EmailSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::EmailSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::user_settings::FiatCurrency> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::user_settings::FiatCurrency::ALL => 0.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::DZD => 1.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ARS => 2.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AMD => 3.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AUD => 4.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AZN => 5.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BHD => 6.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BDT => 7.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BYN => 8.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BMD => 9.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BOB => 10.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BAM => 11.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BRL => 12.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::BGN => 13.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KHR => 14.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CAD => 15.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CLP => 16.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CNY => 17.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::COP => 18.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CRC => 19.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HRK => 20.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CUP => 21.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CZK => 22.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::DKK => 23.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::DOP => 24.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::EGP => 25.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::EUR => 26.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GEL => 27.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GHS => 28.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GTQ => 29.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HNL => 30.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HKD => 31.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::HUF => 32.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ISK => 33.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::INR => 34.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::IDR => 35.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::IRR => 36.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::IQD => 37.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ILS => 38.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::JMD => 39.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::JPY => 40.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::JOD => 41.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KZT => 42.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KES => 43.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KWD => 44.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KGS => 45.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::LBP => 46.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MKD => 47.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MYR => 48.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MUR => 49.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MXN => 50.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MDL => 51.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MNT => 52.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MAD => 53.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::MMK => 54.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NAD => 55.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NPR => 56.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TWD => 57.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NZD => 58.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NIO => 59.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NGN => 60.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::NOK => 61.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::OMR => 62.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PKR => 63.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PAB => 64.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PEN => 65.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PHP => 66.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::PLN => 67.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::GBP => 68.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::QAR => 69.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::RON => 70.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::RUB => 71.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SAR => 72.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::RSD => 73.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SGD => 74.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::ZAR => 75.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::KRW => 76.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SSP => 77.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::VES => 78.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::LKR => 79.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::SEK => 80.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::CHF => 81.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::THB => 82.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TTD => 83.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TND => 84.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::TRY => 85.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UGX => 86.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UAH => 87.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::AED => 88.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::USD => 89.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UYU => 90.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::UZS => 91.into_dart(),
            crate::proton_api::user_settings::FiatCurrency::VND => 92.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::FiatCurrency>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::user_settings::FiatCurrency>>
    for crate::proton_api::user_settings::FiatCurrency
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::user_settings::FiatCurrency> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::FlagsSettings> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::FlagsSettings>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::FlagsSettings>>
    for crate::proton_api::proton_users::FlagsSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::FlagsSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::common::address_info::FrbAddressInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.index.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::common::address_info::FrbAddressInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::common::address_info::FrbAddressInfo>
    for crate::common::address_info::FrbAddressInfo
{
    fn into_into_dart(self) -> crate::common::address_info::FrbAddressInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey,
    > for crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey
{
    fn into_into_dart(self) -> crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bdk_wallet::local_output::FrbOutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bdk_wallet::local_output::FrbOutPoint
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bdk_wallet::local_output::FrbOutPoint>
    for crate::api::bdk_wallet::local_output::FrbOutPoint
{
    fn into_into_dart(self) -> crate::api::bdk_wallet::local_output::FrbOutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bdk_wallet::psbt::FrbPsbtRecipient {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.into_into_dart().into_dart(),
            self.1.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bdk_wallet::psbt::FrbPsbtRecipient
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bdk_wallet::psbt::FrbPsbtRecipient>
    for crate::api::bdk_wallet::psbt::FrbPsbtRecipient
{
    fn into_into_dart(self) -> crate::api::bdk_wallet::psbt::FrbPsbtRecipient {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::proton_wallet::features::transition_layer::FrbSenderBody
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.to_list.into_into_dart().into_dart(),
            self.sender.into_into_dart().into_dart(),
            self.body.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::features::transition_layer::FrbSenderBody
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::proton_wallet::features::transition_layer::FrbSenderBody,
    > for crate::api::proton_wallet::features::transition_layer::FrbSenderBody
{
    fn into_into_dart(
        self,
    ) -> crate::api::proton_wallet::features::transition_layer::FrbSenderBody {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::proton_wallet::srp::srp_client::FrbSrpClient {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::srp::srp_client::FrbSrpClient
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::proton_wallet::srp::srp_client::FrbSrpClient>
    for crate::api::proton_wallet::srp::srp_client::FrbSrpClient
{
    fn into_into_dart(self) -> crate::api::proton_wallet::srp::srp_client::FrbSrpClient {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.encrypted_transaction_id.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID,
    > for crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID
{
    fn into_into_dart(
        self,
    ) -> crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transaction_id.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID,
    > for crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID
{
    fn into_into_dart(
        self,
    ) -> crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer,
    > for crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer
{
    fn into_into_dart(
        self,
    ) -> crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper,
    > for crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper
{
    fn into_into_dart(
        self,
    ) -> crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::payment_gateway::GatewayProvider::Banxa => 0.into_dart(),
            crate::proton_api::payment_gateway::GatewayProvider::Ramp => 1.into_dart(),
            crate::proton_api::payment_gateway::GatewayProvider::MoonPay => 2.into_dart(),
            crate::proton_api::payment_gateway::GatewayProvider::Unsupported => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider>,
    > for crate::proton_api::payment_gateway::GatewayProvider
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::GatewayProvider> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::GetAuthInfoResponseBody>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Code.into_into_dart().into_dart(),
            self.0.Modulus.into_into_dart().into_dart(),
            self.0.ServerEphemeral.into_into_dart().into_dart(),
            self.0.Version.into_into_dart().into_dart(),
            self.0.Salt.into_into_dart().into_dart(),
            self.0.SRPSession.into_into_dart().into_dart(),
            self.0.two_fa.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::GetAuthInfoResponseBody>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::GetAuthInfoResponseBody>,
    > for crate::proton_api::proton_users::GetAuthInfoResponseBody
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::proton_users::GetAuthInfoResponseBody> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::GetAuthModulusResponse>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Code.into_into_dart().into_dart(),
            self.0.Modulus.into_into_dart().into_dart(),
            self.0.ModulusID.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::GetAuthModulusResponse>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::GetAuthModulusResponse>,
    > for crate::proton_api::proton_users::GetAuthModulusResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::GetAuthModulusResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::HighSecuritySettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Eligible.into_into_dart().into_dart(),
            self.0.Value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::HighSecuritySettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::HighSecuritySettings>,
    > for crate::proton_api::proton_users::HighSecuritySettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::HighSecuritySettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::invite::InviteNotificationType>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::invite::InviteNotificationType::Newcomer => 0.into_dart(),
            crate::proton_api::invite::InviteNotificationType::EmailIntegration => 1.into_dart(),
            crate::proton_api::invite::InviteNotificationType::Unsupported => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::invite::InviteNotificationType>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::invite::InviteNotificationType>>
    for crate::proton_api::invite::InviteNotificationType
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::invite::InviteNotificationType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::keychain_kind::KeychainKind> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::keychain_kind::KeychainKind::External => 0.into_dart(),
            crate::common::keychain_kind::KeychainKind::Internal => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::keychain_kind::KeychainKind>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::keychain_kind::KeychainKind>>
    for crate::common::keychain_kind::KeychainKind
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::keychain_kind::KeychainKind> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_wallet::crypto::wallet_key::LockedWalletKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.encrypted.into_into_dart().into_dart(),
            self.signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_wallet::crypto::wallet_key::LockedWalletKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_wallet::crypto::wallet_key::LockedWalletKey>
    for crate::proton_wallet::crypto::wallet_key::LockedWalletKey
{
    fn into_into_dart(self) -> crate::proton_wallet::crypto::wallet_key::LockedWalletKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::transaction::MempoolInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Loaded.into_into_dart().into_dart(),
            self.0.Size.into_into_dart().into_dart(),
            self.0.Bytes.into_into_dart().into_dart(),
            self.0.Usage.into_into_dart().into_dart(),
            self.0.MaxMempool.into_into_dart().into_dart(),
            self.0.MempoolMinFee.into_into_dart().into_dart(),
            self.0.MinRelayTxFee.into_into_dart().into_dart(),
            self.0.IncrementalRelayFee.into_into_dart().into_dart(),
            self.0.UnbroadcastCount.into_into_dart().into_dart(),
            self.0.FullRbf.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::transaction::MempoolInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::transaction::MempoolInfo>>
    for crate::proton_api::transaction::MempoolInfo
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::transaction::MempoolInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::MigratedWallet> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Name.into_into_dart().into_dart(),
            self.0.UserKeyID.into_into_dart().into_dart(),
            self.0.WalletKey.into_into_dart().into_dart(),
            self.0.WalletKeySignature.into_into_dart().into_dart(),
            self.0.Mnemonic.into_into_dart().into_dart(),
            self.0.Fingerprint.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::MigratedWallet>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::MigratedWallet>>
    for crate::proton_api::wallet::MigratedWallet
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::MigratedWallet> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet::MigratedWalletAccount>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Label.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::MigratedWalletAccount>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::MigratedWalletAccount>>
    for crate::proton_api::wallet::MigratedWalletAccount
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::MigratedWalletAccount> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::wallet::MigratedWalletTransaction>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.WalletAccountID.into_into_dart().into_dart(),
            self.0.HashedTransactionID.into_into_dart().into_dart(),
            self.0.Label.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::MigratedWalletTransaction>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::wallet::MigratedWalletTransaction>,
    > for crate::proton_api::wallet::MigratedWalletTransaction
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::MigratedWalletTransaction> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::MnemonicAuth> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Version.into_into_dart().into_dart(),
            self.0.ModulusID.into_into_dart().into_dart(),
            self.0.Salt.into_into_dart().into_dart(),
            self.0.Verifier.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::MnemonicAuth>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::MnemonicAuth>>
    for crate::proton_api::proton_users::MnemonicAuth
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::MnemonicAuth> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_id.into_into_dart().into_dart(),
            self.mnemonic.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData,
    > for crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData
{
    fn into_into_dart(self) -> crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::proton_wallet::features::backup_mnemonic::MnemonicResult
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_id.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.wallet_mnemonic.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_wallet::features::backup_mnemonic::MnemonicResult
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::proton_wallet::features::backup_mnemonic::MnemonicResult,
    > for crate::proton_wallet::features::backup_mnemonic::MnemonicResult
{
    fn into_into_dart(self) -> crate::proton_wallet::features::backup_mnemonic::MnemonicResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::MnemonicUserKey>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.PrivateKey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::MnemonicUserKey>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::MnemonicUserKey>>
    for crate::proton_api::proton_users::MnemonicUserKey
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::MnemonicUserKey> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::network::Network> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::network::Network::Bitcoin => 0.into_dart(),
            crate::common::network::Network::Testnet => 1.into_dart(),
            crate::common::network::Network::Signet => 2.into_dart(),
            crate::common::network::Network::Regtest => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::network::Network>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::network::Network>>
    for crate::common::network::Network
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::network::Network> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::pagination::Pagination> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.skip.into_into_dart().into_dart(),
            self.0.take.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::pagination::Pagination>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::pagination::Pagination>>
    for crate::common::pagination::Pagination
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::pagination::Pagination> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::PasswordSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::PasswordSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::PasswordSettings>>
    for crate::proton_api::proton_users::PasswordSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::PasswordSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::payment_gateway::PaymentMethod::ApplePay => 0.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::BankTransfer => 1.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::Card => 2.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::GooglePay => 3.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::InstantPayment => 4.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::Paypal => 5.into_dart(),
            crate::proton_api::payment_gateway::PaymentMethod::Unsupported => 6.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod>>
    for crate::proton_api::payment_gateway::PaymentMethod
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::PaymentMethod> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::PhoneSettings> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::PhoneSettings>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::PhoneSettings>>
    for crate::proton_api::proton_users::PhoneSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::PhoneSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::price_graph::PriceGraph> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.FiatCurrency.into_into_dart().into_dart(),
            self.0.BitcoinUnit.into_into_dart().into_dart(),
            self.0.GraphData.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::price_graph::PriceGraph>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::price_graph::PriceGraph>>
    for crate::proton_api::price_graph::PriceGraph
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::price_graph::PriceGraph> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::proton_address::ProtonAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.domain_id.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.r#type.into_into_dart().into_dart(),
            self.receive.into_into_dart().into_dart(),
            self.send.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::proton_address::ProtonAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::proton_address::ProtonAddress>
    for crate::proton_api::proton_address::ProtonAddress
{
    fn into_into_dart(self) -> crate::proton_api::proton_address::ProtonAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::proton_address::ProtonAddressKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.private_key.into_into_dart().into_dart(),
            self.token.into_into_dart().into_dart(),
            self.signature.into_into_dart().into_dart(),
            self.primary.into_into_dart().into_dart(),
            self.active.into_into_dart().into_dart(),
            self.flags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::proton_address::ProtonAddressKey
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::proton_address::ProtonAddressKey>
    for crate::proton_api::proton_address::ProtonAddressKey
{
    fn into_into_dart(self) -> crate::proton_api::proton_address::ProtonAddressKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::ProtonEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.code.into_into_dart().into_dart(),
            self.event_id.into_into_dart().into_dart(),
            self.refresh.into_into_dart().into_dart(),
            self.more.into_into_dart().into_dart(),
            self.contact_email_events.into_into_dart().into_dart(),
            self.wallet_events.into_into_dart().into_dart(),
            self.wallet_account_events.into_into_dart().into_dart(),
            self.wallet_key_events.into_into_dart().into_dart(),
            self.wallet_setting_events.into_into_dart().into_dart(),
            self.wallet_transaction_events.into_into_dart().into_dart(),
            self.wallet_user_settings.into_into_dart().into_dart(),
            self.proton_user.into_into_dart().into_dart(),
            self.proton_user_settings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::ProtonEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::ProtonEvent>
    for crate::proton_api::event_routes::ProtonEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::ProtonEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::exchange_rate::ProtonExchangeRate {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.bitcoin_unit.into_into_dart().into_dart(),
            self.fiat_currency.into_into_dart().into_dart(),
            self.exchange_rate_time.into_into_dart().into_dart(),
            self.exchange_rate.into_into_dart().into_dart(),
            self.cents.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::exchange_rate::ProtonExchangeRate
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::exchange_rate::ProtonExchangeRate>
    for crate::proton_api::exchange_rate::ProtonExchangeRate
{
    fn into_into_dart(self) -> crate::proton_api::exchange_rate::ProtonExchangeRate {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::ProtonSrpClientProofs>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ClientEphemeral.into_into_dart().into_dart(),
            self.0.ClientProof.into_into_dart().into_dart(),
            self.0.SRPSession.into_into_dart().into_dart(),
            self.0.TwoFactorCode.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::ProtonSrpClientProofs>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::ProtonSrpClientProofs>,
    > for crate::proton_api::proton_users::ProtonSrpClientProofs
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::ProtonSrpClientProofs> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::ProtonUser> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Name.into_into_dart().into_dart(),
            self.0.UsedSpace.into_into_dart().into_dart(),
            self.0.Currency.into_into_dart().into_dart(),
            self.0.Credit.into_into_dart().into_dart(),
            self.0.CreateTime.into_into_dart().into_dart(),
            self.0.MaxSpace.into_into_dart().into_dart(),
            self.0.MaxUpload.into_into_dart().into_dart(),
            self.0.Role.into_into_dart().into_dart(),
            self.0.Private.into_into_dart().into_dart(),
            self.0.Subscribed.into_into_dart().into_dart(),
            self.0.Services.into_into_dart().into_dart(),
            self.0.Delinquent.into_into_dart().into_dart(),
            self.0.OrganizationPrivateKey.into_into_dart().into_dart(),
            self.0.Email.into_into_dart().into_dart(),
            self.0.DisplayName.into_into_dart().into_dart(),
            self.0.Keys.into_into_dart().into_dart(),
            self.0.MnemonicStatus.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::ProtonUser>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::ProtonUser>>
    for crate::proton_api::proton_users::ProtonUser
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::ProtonUser> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::ProtonUserKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.ID.into_into_dart().into_dart(),
            self.0.Version.into_into_dart().into_dart(),
            self.0.PrivateKey.into_into_dart().into_dart(),
            self.0.RecoverySecret.into_into_dart().into_dart(),
            self.0.RecoverySecretSignature.into_into_dart().into_dart(),
            self.0.Token.into_into_dart().into_dart(),
            self.0.Fingerprint.into_into_dart().into_dart(),
            self.0.Primary.into_into_dart().into_dart(),
            self.0.Active.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::ProtonUserKey>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::ProtonUserKey>>
    for crate::proton_api::proton_users::ProtonUserKey
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::ProtonUserKey> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::ProtonUserSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Email.into_into_dart().into_dart(),
            self.0.Password.into_into_dart().into_dart(),
            self.0.Phone.into_into_dart().into_dart(),
            self.0.two_fa.into_into_dart().into_dart(),
            self.0.News.into_into_dart().into_dart(),
            self.0.Locale.into_into_dart().into_dart(),
            self.0.LogAuth.into_into_dart().into_dart(),
            self.0.InvoiceText.into_into_dart().into_dart(),
            self.0.Density.into_into_dart().into_dart(),
            self.0.WeekStart.into_into_dart().into_dart(),
            self.0.DateFormat.into_into_dart().into_dart(),
            self.0.TimeFormat.into_into_dart().into_dart(),
            self.0.Welcome.into_into_dart().into_dart(),
            self.0.WelcomeFlag.into_into_dart().into_dart(),
            self.0.EarlyAccess.into_into_dart().into_dart(),
            self.0.Flags.into_into_dart().into_dart(),
            self.0.Referral.into_into_dart().into_dart(),
            self.0.DeviceRecovery.into_into_dart().into_dart(),
            self.0.Telemetry.into_into_dart().into_dart(),
            self.0.CrashReports.into_into_dart().into_dart(),
            self.0.HideSidePanel.into_into_dart().into_dart(),
            self.0.HighSecurity.into_into_dart().into_dart(),
            self.0.SessionAccountRecovery.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::ProtonUserSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::ProtonUserSettings>,
    > for crate::proton_api::proton_users::ProtonUserSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::ProtonUserSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::payment_gateway::Quote> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.BitcoinAmount.into_into_dart().into_dart(),
            self.0.FiatAmount.into_into_dart().into_dart(),
            self.0.FiatCurrencySymbol.into_into_dart().into_dart(),
            self.0.NetworkFee.into_into_dart().into_dart(),
            self.0.PaymentGatewayFee.into_into_dart().into_dart(),
            self.0.PaymentMethod.into_into_dart().into_dart(),
            self.0.PurchaseAmount.into_into_dart().into_dart(),
            self.0.PaymentProcessingFee.into_into_dart().into_dart(),
            self.0.OrderID.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::payment_gateway::Quote>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::payment_gateway::Quote>>
    for crate::proton_api::payment_gateway::Quote
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::payment_gateway::Quote> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::blockchain::RecommendedFees> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.FastestFee.into_into_dart().into_dart(),
            self.0.HalfHourFee.into_into_dart().into_dart(),
            self.0.HourFee.into_into_dart().into_dart(),
            self.0.EconomyFee.into_into_dart().into_dart(),
            self.0.MinimumFee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::blockchain::RecommendedFees>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::blockchain::RecommendedFees>>
    for crate::common::blockchain::RecommendedFees
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::blockchain::RecommendedFees> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::ReferralSettings>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::ReferralSettings>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::ReferralSettings>>
    for crate::proton_api::proton_users::ReferralSettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::ReferralSettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::invite::RemainingMonthlyInvitations>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Used.into_into_dart().into_dart(),
            self.0.Available.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::invite::RemainingMonthlyInvitations>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::invite::RemainingMonthlyInvitations>,
    > for crate::proton_api::invite::RemainingMonthlyInvitations
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::invite::RemainingMonthlyInvitations> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::errors::ResponseError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.code.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
            self.details.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::errors::ResponseError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::errors::ResponseError>
    for crate::api::errors::ResponseError
{
    fn into_into_dart(self) -> crate::api::errors::ResponseError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::script_type::ScriptType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::script_type::ScriptType::Legacy => 0.into_dart(),
            crate::common::script_type::ScriptType::NestedSegwit => 1.into_dart(),
            crate::common::script_type::ScriptType::NativeSegwit => 2.into_dart(),
            crate::common::script_type::ScriptType::Taproot => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::script_type::ScriptType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::script_type::ScriptType>>
    for crate::common::script_type::ScriptType
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::script_type::ScriptType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPRequestBody>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.TOTPConfirmation.into_into_dart().into_dart(),
            self.0.TOTPSharedSecret.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPRequestBody>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPRequestBody>,
    > for crate::proton_api::proton_users::SetTwoFaTOTPRequestBody
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPRequestBody> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPResponseBody>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Code.into_into_dart().into_dart(),
            self.0.TwoFactorRecoveryCodes.into_into_dart().into_dart(),
            self.0.UserSettings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPResponseBody>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPResponseBody>,
    > for crate::proton_api::proton_users::SetTwoFaTOTPResponseBody
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::proton_users::SetTwoFaTOTPResponseBody> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::pagination::SortOrder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::pagination::SortOrder::Asc => 0.into_dart(),
            crate::common::pagination::SortOrder::Desc => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::pagination::SortOrder>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::pagination::SortOrder>>
    for crate::common::pagination::SortOrder
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::pagination::SortOrder> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::srp::proofs::SRPProofB64> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.client_ephemeral.into_into_dart().into_dart(),
            self.0.client_proof.into_into_dart().into_dart(),
            self.0.expected_server_proof.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::srp::proofs::SRPProofB64>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::srp::proofs::SRPProofB64>>
    for crate::srp::proofs::SRPProofB64
{
    fn into_into_dart(self) -> FrbWrapper<crate::srp::proofs::SRPProofB64> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::price_graph::Timeframe> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::price_graph::Timeframe::OneDay => 0.into_dart(),
            crate::proton_api::price_graph::Timeframe::OneWeek => 1.into_dart(),
            crate::proton_api::price_graph::Timeframe::OneMonth => 2.into_dart(),
            crate::proton_api::price_graph::Timeframe::Unsupported => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::price_graph::Timeframe>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::price_graph::Timeframe>>
    for crate::proton_api::price_graph::Timeframe
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::price_graph::Timeframe> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::common::transaction_time::TransactionTime>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::transaction_time::TransactionTime::Confirmed { confirmation_time } => [
                0.into_dart(),
                confirmation_time.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::common::transaction_time::TransactionTime::Unconfirmed { last_seen } => {
                [1.into_dart(), last_seen.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::transaction_time::TransactionTime>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::transaction_time::TransactionTime>>
    for crate::common::transaction_time::TransactionTime
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::transaction_time::TransactionTime> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::wallet::TransactionType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::proton_api::wallet::TransactionType::NotSend => 0.into_dart(),
            crate::proton_api::wallet::TransactionType::ProtonToProtonSend => 1.into_dart(),
            crate::proton_api::wallet::TransactionType::ProtonToProtonReceive => 2.into_dart(),
            crate::proton_api::wallet::TransactionType::ExternalSend => 3.into_dart(),
            crate::proton_api::wallet::TransactionType::ExternalReceive => 4.into_dart(),
            crate::proton_api::wallet::TransactionType::Unsupported => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::wallet::TransactionType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::wallet::TransactionType>>
    for crate::proton_api::wallet::TransactionType
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::wallet::TransactionType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::TwoFA> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.Enabled.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::TwoFA>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::TwoFA>>
    for crate::proton_api::proton_users::TwoFA
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::TwoFA> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::proton_users::TwoFASettings> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.Enabled.into_into_dart().into_dart(),
            self.0.Allowed.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::TwoFASettings>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::proton_users::TwoFASettings>>
    for crate::proton_api::proton_users::TwoFASettings
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::proton_users::TwoFASettings> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::proton_api::unleash::UnleashResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.status_code.into_into_dart().into_dart(),
            self.0.body.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::unleash::UnleashResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::proton_api::unleash::UnleashResponse>>
    for crate::proton_api::unleash::UnleashResponse
{
    fn into_into_dart(self) -> FrbWrapper<crate::proton_api::unleash::UnleashResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.MnemonicUserKeys.into_into_dart().into_dart(),
            self.0.MnemonicSalt.into_into_dart().into_dart(),
            self.0.MnemonicAuth.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody>,
    > for crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::proton_api::user_settings::UserReceiveNotificationEmailTypes>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
                    crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::NotificationToInviter => 0.into_dart(),
crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::EmailIntegration => 1.into_dart(),
crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::TransactionalBvE => 2.into_dart(),
crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::Unsupported => 3.into_dart(),
                    _ => unreachable!(),
                }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::proton_api::user_settings::UserReceiveNotificationEmailTypes>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::proton_api::user_settings::UserReceiveNotificationEmailTypes>,
    > for crate::proton_api::user_settings::UserReceiveNotificationEmailTypes
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::proton_api::user_settings::UserReceiveNotificationEmailTypes> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletAccountEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_account.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletAccountEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletAccountEvent>
    for crate::proton_api::event_routes::WalletAccountEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletAccountEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletEvent>
    for crate::proton_api::event_routes::WalletEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletKeyEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletKeyEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletKeyEvent>
    for crate::proton_api::event_routes::WalletKeyEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletKeyEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::bdk_wallet::storage::WalletMobileConnectorFactory
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.folder_path.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bdk_wallet::storage::WalletMobileConnectorFactory
{
}
impl
    flutter_rust_bridge::IntoIntoDart<crate::api::bdk_wallet::storage::WalletMobileConnectorFactory>
    for crate::api::bdk_wallet::storage::WalletMobileConnectorFactory
{
    fn into_into_dart(self) -> crate::api::bdk_wallet::storage::WalletMobileConnectorFactory {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_wallet::db::model::wallet_model::WalletModel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
            self.imported.into_into_dart().into_dart(),
            self.priority.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.type_.into_into_dart().into_dart(),
            self.create_time.into_into_dart().into_dart(),
            self.modify_time.into_into_dart().into_dart(),
            self.user_id.into_into_dart().into_dart(),
            self.wallet_id.into_into_dart().into_dart(),
            self.account_count.into_into_dart().into_dart(),
            self.balance.into_into_dart().into_dart(),
            self.fingerprint.into_into_dart().into_dart(),
            self.show_wallet_recovery.into_into_dart().into_dart(),
            self.migration_required.into_into_dart().into_dart(),
            self.legacy.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_wallet::db::model::wallet_model::WalletModel
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_wallet::db::model::wallet_model::WalletModel>
    for crate::proton_wallet::db::model::wallet_model::WalletModel
{
    fn into_into_dart(self) -> crate::proton_wallet::db::model::wallet_model::WalletModel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletSettingsEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_settings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletSettingsEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletSettingsEvent>
    for crate::proton_api::event_routes::WalletSettingsEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletSettingsEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::wallet::WalletTransaction {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.r#type.into_into_dart().into_dart(),
            self.wallet_id.into_into_dart().into_dart(),
            self.wallet_account_id.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.transaction_id.into_into_dart().into_dart(),
            self.transaction_time.into_into_dart().into_dart(),
            self.is_suspicious.into_into_dart().into_dart(),
            self.is_private.into_into_dart().into_dart(),
            self.is_anonymous.into_into_dart().into_dart(),
            self.exchange_rate.into_into_dart().into_dart(),
            self.hashed_transaction_id.into_into_dart().into_dart(),
            self.subject.into_into_dart().into_dart(),
            self.body.into_into_dart().into_dart(),
            self.sender.into_into_dart().into_dart(),
            self.tolist.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::wallet::WalletTransaction
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::wallet::WalletTransaction>
    for crate::proton_api::wallet::WalletTransaction
{
    fn into_into_dart(self) -> crate::proton_api::wallet::WalletTransaction {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::proton_api::event_routes::WalletTransactionEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.action.into_into_dart().into_dart(),
            self.wallet_transaction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::proton_api::event_routes::WalletTransactionEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::proton_api::event_routes::WalletTransactionEvent>
    for crate::proton_api::event_routes::WalletTransactionEvent
{
    fn into_into_dart(self) -> crate::proton_api::event_routes::WalletTransactionEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::common::word_count::WordCount> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::common::word_count::WordCount::Words12 => 0.into_dart(),
            crate::common::word_count::WordCount::Words15 => 1.into_dart(),
            crate::common::word_count::WordCount::Words18 => 2.into_dart(),
            crate::common::word_count::WordCount::Words21 => 3.into_dart(),
            crate::common::word_count::WordCount::Words24 => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::common::word_count::WordCount>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::common::word_count::WordCount>>
    for crate::common::word_count::WordCount
{
    fn into_into_dart(self) -> FrbWrapper<crate::common::word_count::WordCount> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for AddressBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ApiTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Arc<ProtonAPIService> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for BitcoinAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for BlockClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ContactsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for DiscoveredAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for DiscoveryContentClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for EmailIntegrationClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for EventClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ExchangeRateClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbAddressDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbAppDatabase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbBackupMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbBlockchainClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbDerivationPath {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbDetailledTxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbDetailledTxOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FrbLocalOutput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbPaymentLink {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbProtonRecovery {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbProtonWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbSequence {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbTransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FrbTxBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbTxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbUnleashClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbUnlockedWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for FrbUserKeyStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbWalletKeyStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for FrbWalletMnemonicStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for InviteClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for OnRampGatewayClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for PriceGraphClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ProtonAPIService {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ProtonEmailAddressClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ProtonSettingsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ProtonUsersClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ProtonWalletAuthStore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for SettingsClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for TransactionClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for WalletClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for bdkTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.encode(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, f64)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiCountry>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::PaymentMethod>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::proton_api::payment_gateway::GatewayProvider,
            Vec<crate::proton_api::payment_gateway::Quote>,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<ProtonAPIService>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::proton_wallet::db::model::account_model::AccountModel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.account_id, serializer);
        <String>::sse_encode(self.wallet_id, serializer);
        <String>::sse_encode(self.derivation_path, serializer);
        <String>::sse_encode(self.label, serializer);
        <u32>::sse_encode(self.script_type, serializer);
        <u64>::sse_encode(self.create_time, serializer);
        <u64>::sse_encode(self.modify_time, serializer);
        <String>::sse_encode(self.fiat_currency, serializer);
        <u32>::sse_encode(self.priority, serializer);
        <u32>::sse_encode(self.last_used_index, serializer);
        <u32>::sse_encode(self.pool_size, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_address::AllKeyAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.flags, serializer);
        <String>::sse_encode(self.public_key, serializer);
        <u32>::sse_encode(self.source, serializer);
    }
}

impl SseEncode for crate::proton_api::contacts::ApiContactEmails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Name, serializer);
        <String>::sse_encode(self.Email, serializer);
        <String>::sse_encode(self.CanonicalEmail, serializer);
        <u32>::sse_encode(self.IsProton, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::ApiCountry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.Code, serializer);
        <String>::sse_encode(self.FiatCurrency, serializer);
        <String>::sse_encode(self.Name, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_account::ApiEmailAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Email, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::ApiMnemonicUserKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.PrivateKey, serializer);
        <String>::sse_encode(self.Salt, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::ApiSimpleFiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.Name, serializer);
        <String>::sse_encode(self.Symbol, serializer);
        <Option<String>>::sse_encode(self.MinimumAmount, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Name, serializer);
        <u8>::sse_encode(self.IsImported, serializer);
        <u8>::sse_encode(self.Priority, serializer);
        <u8>::sse_encode(self.Type, serializer);
        <u8>::sse_encode(self.HasPassphrase, serializer);
        <u8>::sse_encode(self.Status, serializer);
        <Option<String>>::sse_encode(self.Mnemonic, serializer);
        <Option<String>>::sse_encode(self.Fingerprint, serializer);
        <Option<String>>::sse_encode(self.PublicKey, serializer);
        <Option<u8>>::sse_encode(self.MigrationRequired, serializer);
        <Option<u8>>::sse_encode(self.Legacy, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_account::ApiWalletAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.WalletID, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(self.FiatCurrency, serializer);
        <String>::sse_encode(self.DerivationPath, serializer);
        <String>::sse_encode(self.Label, serializer);
        <u32>::sse_encode(self.LastUsedIndex, serializer);
        <u32>::sse_encode(self.PoolSize, serializer);
        <u32>::sse_encode(self.Priority, serializer);
        <u8>::sse_encode(self.ScriptType, serializer);
        <Option<u32>>::sse_encode(self.StopGap, serializer);
        <Vec<crate::proton_api::wallet_account::ApiEmailAddress>>::sse_encode(
            self.Addresses,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWalletBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.WalletID, serializer);
        <String>::sse_encode(self.WalletAccountID, serializer);
        <u8>::sse_encode(self.Fetched, serializer);
        <u8>::sse_encode(self.Used, serializer);
        <Option<String>>::sse_encode(self.BitcoinAddress, serializer);
        <Option<String>>::sse_encode(self.BitcoinAddressSignature, serializer);
        <Option<u64>>::sse_encode(self.BitcoinAddressIndex, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWalletData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::wallet::ApiWallet>::sse_encode(self.Wallet, serializer);
        <crate::proton_api::wallet::ApiWalletKey>::sse_encode(self.WalletKey, serializer);
        <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_encode(
            self.WalletSettings,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet::ApiWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.WalletID, serializer);
        <String>::sse_encode(self.UserKeyID, serializer);
        <String>::sse_encode(self.WalletKey, serializer);
        <String>::sse_encode(self.WalletKeySignature, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_settings::ApiWalletSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.WalletID, serializer);
        <u8>::sse_encode(self.HideAccounts, serializer);
        <Option<String>>::sse_encode(self.InvoiceDefaultDescription, serializer);
        <u64>::sse_encode(self.InvoiceExpirationTime, serializer);
        <u64>::sse_encode(self.MaxChannelOpeningFee, serializer);
        <Option<bool>>::sse_encode(self.ShowWalletRecovery, serializer);
    }
}

impl SseEncode for crate::proton_api::user_settings::ApiWalletUserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::user_settings::BitcoinUnit>::sse_encode(self.BitcoinUnit, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(self.FiatCurrency, serializer);
        <u8>::sse_encode(self.HideEmptyUsedAddresses, serializer);
        <Option<u64>>::sse_encode(self.TwoFactorAmountThreshold, serializer);
        <Option<u8>>::sse_encode(self.ReceiveInviterNotification, serializer);
        <Option<u8>>::sse_encode(self.ReceiveEmailIntegrationNotification, serializer);
        <Option<u8>>::sse_encode(self.ReceiveTransactionNotification, serializer);
        <Option<u8>>::sse_encode(self.WalletCreated, serializer);
        <Option<u8>>::sse_encode(self.AcceptTermsAndConditions, serializer);
    }
}

impl SseEncode for crate::proton_api::auth_credential::AuthCredential {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.session_id, serializer);
        <String>::sse_encode(self.user_id, serializer);
        <String>::sse_encode(self.access_token, serializer);
        <String>::sse_encode(self.refresh_token, serializer);
        <String>::sse_encode(self.event_id, serializer);
        <String>::sse_encode(self.user_mail, serializer);
        <String>::sse_encode(self.user_name, serializer);
        <String>::sse_encode(self.display_name, serializer);
        <Vec<String>>::sse_encode(self.scops, serializer);
        <String>::sse_encode(self.user_key_id, serializer);
        <String>::sse_encode(self.user_private_key, serializer);
        <String>::sse_encode(self.user_passphrase, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.bitcoin_address, serializer);
        <String>::sse_encode(self.bitcoin_address_signature, serializer);
        <u64>::sse_encode(self.bitcoin_address_index, serializer);
    }
}

impl SseEncode for crate::proton_api::user_settings::BitcoinUnit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::user_settings::BitcoinUnit::BTC => 0,
                crate::proton_api::user_settings::BitcoinUnit::MBTC => 1,
                crate::proton_api::user_settings::BitcoinUnit::SATS => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::errors::BridgeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::errors::BridgeError::ApiLock(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::Generic(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::MuonAuthSession(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::MuonAuthRefresh(field0) => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::MuonClient(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::MuonSession(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::AndromedaBitcoin(field0) => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::ApiResponse(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::api::errors::ResponseError>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::ApiSrp(field0) => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::AesGcm(field0) => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::WalletCrypto(field0) => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::WalletFeature(field0) => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::Login(field0) => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::Fork(field0) => {
                <i32>::sse_encode(13, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::errors::BridgeError::Database(field0) => {
                <i32>::sse_encode(14, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::common::broadcast_message::BroadcastMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.DataPacket, serializer);
        <std::collections::HashMap<String, String>>::sse_encode(self.KeyPackets, serializer);
    }
}

impl SseEncode for crate::common::change_spend_policy::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::change_spend_policy::ChangeSpendPolicy::ChangeAllowed => 0,
                crate::common::change_spend_policy::ChangeSpendPolicy::OnlyChange => 1,
                crate::common::change_spend_policy::ChangeSpendPolicy::ChangeForbidden => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::auth_credential::ChildSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.session_id, serializer);
        <String>::sse_encode(self.access_token, serializer);
        <String>::sse_encode(self.refresh_token, serializer);
        <Vec<String>>::sse_encode(self.scopes, serializer);
    }
}

impl SseEncode for crate::common::coin_selection::CoinSelection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::coin_selection::CoinSelection::BranchAndBound => 0,
                crate::common::coin_selection::CoinSelection::LargestFirst => 1,
                crate::common::coin_selection::CoinSelection::OldestFirst => 2,
                crate::common::coin_selection::CoinSelection::Manual => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::common::confirmation_time::ConfirmationTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::common::confirmation_time::ConfirmationTime::Confirmed { height, time } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(height, serializer);
                <u64>::sse_encode(time, serializer);
            }
            crate::common::confirmation_time::ConfirmationTime::Unconfirmed { last_seen } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(last_seen, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::proton_api::event_routes::ContactEmailEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::contacts::ApiContactEmails>>::sse_encode(
            self.contact_email,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::discovery_content::Content {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.Title, serializer);
        <String>::sse_encode(self.Link, serializer);
        <String>::sse_encode(self.Description, serializer);
        <i64>::sse_encode(self.PubDate, serializer);
        <String>::sse_encode(self.Author, serializer);
        <String>::sse_encode(self.Category, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet_account::CreateWalletAccountReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.label, serializer);
        <String>::sse_encode(self.derivation_path, serializer);
        <u8>::sse_encode(self.script_type, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::CreateWalletReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <u8>::sse_encode(self.is_imported, serializer);
        <u8>::sse_encode(self.r#type, serializer);
        <u8>::sse_encode(self.has_passphrase, serializer);
        <String>::sse_encode(self.user_key_id, serializer);
        <String>::sse_encode(self.wallet_key, serializer);
        <Option<String>>::sse_encode(self.mnemonic, serializer);
        <Option<String>>::sse_encode(self.public_key, serializer);
        <Option<String>>::sse_encode(self.fingerprint, serializer);
        <String>::sse_encode(self.wallet_key_signature, serializer);
        <u8>::sse_encode(self.is_auto_created, serializer);
    }
}

impl SseEncode for crate::proton_api::price_graph::DataPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.ExchangeRate, serializer);
        <u8>::sse_encode(self.Cents, serializer);
        <u64>::sse_encode(self.Timestamp, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::EmailIntegrationBitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.bitcoin_address, serializer);
        <Option<String>>::sse_encode(self.bitcoin_address_signature, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::EmailSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.Value, serializer);
        <u32>::sse_encode(self.Status, serializer);
        <u32>::sse_encode(self.Notify, serializer);
        <u32>::sse_encode(self.Reset, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::proton_api::user_settings::FiatCurrency {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::user_settings::FiatCurrency::ALL => 0,
                crate::proton_api::user_settings::FiatCurrency::DZD => 1,
                crate::proton_api::user_settings::FiatCurrency::ARS => 2,
                crate::proton_api::user_settings::FiatCurrency::AMD => 3,
                crate::proton_api::user_settings::FiatCurrency::AUD => 4,
                crate::proton_api::user_settings::FiatCurrency::AZN => 5,
                crate::proton_api::user_settings::FiatCurrency::BHD => 6,
                crate::proton_api::user_settings::FiatCurrency::BDT => 7,
                crate::proton_api::user_settings::FiatCurrency::BYN => 8,
                crate::proton_api::user_settings::FiatCurrency::BMD => 9,
                crate::proton_api::user_settings::FiatCurrency::BOB => 10,
                crate::proton_api::user_settings::FiatCurrency::BAM => 11,
                crate::proton_api::user_settings::FiatCurrency::BRL => 12,
                crate::proton_api::user_settings::FiatCurrency::BGN => 13,
                crate::proton_api::user_settings::FiatCurrency::KHR => 14,
                crate::proton_api::user_settings::FiatCurrency::CAD => 15,
                crate::proton_api::user_settings::FiatCurrency::CLP => 16,
                crate::proton_api::user_settings::FiatCurrency::CNY => 17,
                crate::proton_api::user_settings::FiatCurrency::COP => 18,
                crate::proton_api::user_settings::FiatCurrency::CRC => 19,
                crate::proton_api::user_settings::FiatCurrency::HRK => 20,
                crate::proton_api::user_settings::FiatCurrency::CUP => 21,
                crate::proton_api::user_settings::FiatCurrency::CZK => 22,
                crate::proton_api::user_settings::FiatCurrency::DKK => 23,
                crate::proton_api::user_settings::FiatCurrency::DOP => 24,
                crate::proton_api::user_settings::FiatCurrency::EGP => 25,
                crate::proton_api::user_settings::FiatCurrency::EUR => 26,
                crate::proton_api::user_settings::FiatCurrency::GEL => 27,
                crate::proton_api::user_settings::FiatCurrency::GHS => 28,
                crate::proton_api::user_settings::FiatCurrency::GTQ => 29,
                crate::proton_api::user_settings::FiatCurrency::HNL => 30,
                crate::proton_api::user_settings::FiatCurrency::HKD => 31,
                crate::proton_api::user_settings::FiatCurrency::HUF => 32,
                crate::proton_api::user_settings::FiatCurrency::ISK => 33,
                crate::proton_api::user_settings::FiatCurrency::INR => 34,
                crate::proton_api::user_settings::FiatCurrency::IDR => 35,
                crate::proton_api::user_settings::FiatCurrency::IRR => 36,
                crate::proton_api::user_settings::FiatCurrency::IQD => 37,
                crate::proton_api::user_settings::FiatCurrency::ILS => 38,
                crate::proton_api::user_settings::FiatCurrency::JMD => 39,
                crate::proton_api::user_settings::FiatCurrency::JPY => 40,
                crate::proton_api::user_settings::FiatCurrency::JOD => 41,
                crate::proton_api::user_settings::FiatCurrency::KZT => 42,
                crate::proton_api::user_settings::FiatCurrency::KES => 43,
                crate::proton_api::user_settings::FiatCurrency::KWD => 44,
                crate::proton_api::user_settings::FiatCurrency::KGS => 45,
                crate::proton_api::user_settings::FiatCurrency::LBP => 46,
                crate::proton_api::user_settings::FiatCurrency::MKD => 47,
                crate::proton_api::user_settings::FiatCurrency::MYR => 48,
                crate::proton_api::user_settings::FiatCurrency::MUR => 49,
                crate::proton_api::user_settings::FiatCurrency::MXN => 50,
                crate::proton_api::user_settings::FiatCurrency::MDL => 51,
                crate::proton_api::user_settings::FiatCurrency::MNT => 52,
                crate::proton_api::user_settings::FiatCurrency::MAD => 53,
                crate::proton_api::user_settings::FiatCurrency::MMK => 54,
                crate::proton_api::user_settings::FiatCurrency::NAD => 55,
                crate::proton_api::user_settings::FiatCurrency::NPR => 56,
                crate::proton_api::user_settings::FiatCurrency::TWD => 57,
                crate::proton_api::user_settings::FiatCurrency::NZD => 58,
                crate::proton_api::user_settings::FiatCurrency::NIO => 59,
                crate::proton_api::user_settings::FiatCurrency::NGN => 60,
                crate::proton_api::user_settings::FiatCurrency::NOK => 61,
                crate::proton_api::user_settings::FiatCurrency::OMR => 62,
                crate::proton_api::user_settings::FiatCurrency::PKR => 63,
                crate::proton_api::user_settings::FiatCurrency::PAB => 64,
                crate::proton_api::user_settings::FiatCurrency::PEN => 65,
                crate::proton_api::user_settings::FiatCurrency::PHP => 66,
                crate::proton_api::user_settings::FiatCurrency::PLN => 67,
                crate::proton_api::user_settings::FiatCurrency::GBP => 68,
                crate::proton_api::user_settings::FiatCurrency::QAR => 69,
                crate::proton_api::user_settings::FiatCurrency::RON => 70,
                crate::proton_api::user_settings::FiatCurrency::RUB => 71,
                crate::proton_api::user_settings::FiatCurrency::SAR => 72,
                crate::proton_api::user_settings::FiatCurrency::RSD => 73,
                crate::proton_api::user_settings::FiatCurrency::SGD => 74,
                crate::proton_api::user_settings::FiatCurrency::ZAR => 75,
                crate::proton_api::user_settings::FiatCurrency::KRW => 76,
                crate::proton_api::user_settings::FiatCurrency::SSP => 77,
                crate::proton_api::user_settings::FiatCurrency::VES => 78,
                crate::proton_api::user_settings::FiatCurrency::LKR => 79,
                crate::proton_api::user_settings::FiatCurrency::SEK => 80,
                crate::proton_api::user_settings::FiatCurrency::CHF => 81,
                crate::proton_api::user_settings::FiatCurrency::THB => 82,
                crate::proton_api::user_settings::FiatCurrency::TTD => 83,
                crate::proton_api::user_settings::FiatCurrency::TND => 84,
                crate::proton_api::user_settings::FiatCurrency::TRY => 85,
                crate::proton_api::user_settings::FiatCurrency::UGX => 86,
                crate::proton_api::user_settings::FiatCurrency::UAH => 87,
                crate::proton_api::user_settings::FiatCurrency::AED => 88,
                crate::proton_api::user_settings::FiatCurrency::USD => 89,
                crate::proton_api::user_settings::FiatCurrency::UYU => 90,
                crate::proton_api::user_settings::FiatCurrency::UZS => 91,
                crate::proton_api::user_settings::FiatCurrency::VND => 92,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_users::FlagsSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::common::address_info::FrbAddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.index, serializer);
        <String>::sse_encode(self.address, serializer);
        <crate::common::keychain_kind::KeychainKind>::sse_encode(self.keychain, serializer);
    }
}

impl SseEncode for crate::api::proton_wallet::crypto::wallet_key::FrbLockedWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_wallet::crypto::wallet_key::LockedWalletKey>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::bdk_wallet::local_output::FrbOutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::bdk_wallet::psbt::FrbPsbtRecipient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <u64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::proton_wallet::features::transition_layer::FrbSenderBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_list, serializer);
        <String>::sse_encode(self.sender, serializer);
        <String>::sse_encode(self.body, serializer);
    }
}

impl SseEncode for crate::api::proton_wallet::srp::srp_client::FrbSrpClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode
    for crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.encrypted_transaction_id, serializer);
        <u32>::sse_encode(self.index, serializer);
    }
}

impl SseEncode for crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.transaction_id, serializer);
        <u32>::sse_encode(self.index, serializer);
    }
}

impl SseEncode for crate::api::proton_wallet::features::transition_layer::FrbTransitionLayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::proton_wallet::crypto::wallet_key_helper::FrbWalletKeyHelper {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::proton_api::payment_gateway::GatewayProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::payment_gateway::GatewayProvider::Banxa => 0,
                crate::proton_api::payment_gateway::GatewayProvider::Ramp => 1,
                crate::proton_api::payment_gateway::GatewayProvider::MoonPay => 2,
                crate::proton_api::payment_gateway::GatewayProvider::Unsupported => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_users::GetAuthInfoResponseBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.Code, serializer);
        <String>::sse_encode(self.Modulus, serializer);
        <String>::sse_encode(self.ServerEphemeral, serializer);
        <u8>::sse_encode(self.Version, serializer);
        <String>::sse_encode(self.Salt, serializer);
        <String>::sse_encode(self.SRPSession, serializer);
        <crate::proton_api::proton_users::TwoFA>::sse_encode(self.two_fa, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::GetAuthModulusResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.Code, serializer);
        <String>::sse_encode(self.Modulus, serializer);
        <String>::sse_encode(self.ModulusID, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::HighSecuritySettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.Eligible, serializer);
        <u32>::sse_encode(self.Value, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::proton_api::invite::InviteNotificationType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::invite::InviteNotificationType::Newcomer => 0,
                crate::proton_api::invite::InviteNotificationType::EmailIntegration => 1,
                crate::proton_api::invite::InviteNotificationType::Unsupported => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for isize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_i64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::common::keychain_kind::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::keychain_kind::KeychainKind::External => 0,
                crate::common::keychain_kind::KeychainKind::Internal => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<ApiTx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ApiTx>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<DiscoveredAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <DiscoveredAccount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FrbAddressDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FrbAddressDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FrbDetailledTxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FrbDetailledTxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FrbDetailledTxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FrbDetailledTxOutput>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FrbLocalOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FrbLocalOutput>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<FrbTransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <FrbTransactionDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_wallet::db::model::account_model::AccountModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_wallet::db::model::account_model::AccountModel>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_address::AllKeyAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_address::AllKeyAddressKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::contacts::ApiContactEmails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::ApiCountry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::ApiCountry>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet_account::ApiEmailAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet_account::ApiEmailAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_users::ApiMnemonicUserKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_users::ApiMnemonicUserKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet_account::ApiWalletAccount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::ApiWalletBitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::ApiWalletBitcoinAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::ApiWalletData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::ApiWalletData>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::ApiWalletKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::ApiWalletKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::BitcoinAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::BitcoinAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::ContactEmailEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::ContactEmailEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::discovery_content::Content> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::discovery_content::Content>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::price_graph::DataPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::price_graph::DataPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bdk_wallet::local_output::FrbOutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bdk_wallet::local_output::FrbOutPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::bdk_wallet::psbt::FrbPsbtRecipient> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::bdk_wallet::psbt::FrbPsbtRecipient>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::proton_wallet::features::transition_layer::FrbTLEncryptedTransactionID>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::proton_wallet::features::transition_layer::FrbTLTransactionID>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::MigratedWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::MigratedWalletAccount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::MigratedWalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::MigratedWalletTransaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_users::MnemonicUserKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_users::MnemonicUserKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::PaymentMethod>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_address::ProtonAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_address::ProtonAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_address::ProtonAddressKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_address::ProtonAddressKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::ProtonEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::ProtonEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::proton_users::ProtonUserKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::proton_users::ProtonUserKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::payment_gateway::Quote> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::payment_gateway::Quote>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiCountry>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::PaymentMethod>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::proton_api::payment_gateway::GatewayProvider,
                Vec<crate::proton_api::payment_gateway::Quote>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, f64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletAccountEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletAccountEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletKeyEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletKeyEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_wallet::db::model::wallet_model::WalletModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_wallet::db::model::wallet_model::WalletModel>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletSettingsEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletSettingsEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::wallet::WalletTransaction>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::proton_api::event_routes::WalletTransactionEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::proton_api::event_routes::WalletTransactionEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::proton_wallet::crypto::wallet_key::LockedWalletKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.encrypted, serializer);
        <String>::sse_encode(self.signature, serializer);
    }
}

impl SseEncode for crate::proton_api::transaction::MempoolInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.Loaded, serializer);
        <u32>::sse_encode(self.Size, serializer);
        <u32>::sse_encode(self.Bytes, serializer);
        <u32>::sse_encode(self.Usage, serializer);
        <u32>::sse_encode(self.MaxMempool, serializer);
        <f32>::sse_encode(self.MempoolMinFee, serializer);
        <f32>::sse_encode(self.MinRelayTxFee, serializer);
        <f32>::sse_encode(self.IncrementalRelayFee, serializer);
        <u8>::sse_encode(self.UnbroadcastCount, serializer);
        <u8>::sse_encode(self.FullRbf, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::MigratedWallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.Name, serializer);
        <String>::sse_encode(self.UserKeyID, serializer);
        <String>::sse_encode(self.WalletKey, serializer);
        <String>::sse_encode(self.WalletKeySignature, serializer);
        <String>::sse_encode(self.Mnemonic, serializer);
        <String>::sse_encode(self.Fingerprint, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::MigratedWalletAccount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.Label, serializer);
    }
}

impl SseEncode for crate::proton_api::wallet::MigratedWalletTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.WalletAccountID, serializer);
        <Option<String>>::sse_encode(self.HashedTransactionID, serializer);
        <Option<String>>::sse_encode(self.Label, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::MnemonicAuth {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.Version, serializer);
        <String>::sse_encode(self.ModulusID, serializer);
        <String>::sse_encode(self.Salt, serializer);
        <String>::sse_encode(self.Verifier, serializer);
    }
}

impl SseEncode for crate::proton_wallet::storage::wallet_mnemonic_ext::MnemonicData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.wallet_id, serializer);
        <Option<String>>::sse_encode(self.mnemonic, serializer);
    }
}

impl SseEncode for crate::proton_wallet::features::backup_mnemonic::MnemonicResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.wallet_id, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.wallet_mnemonic, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::MnemonicUserKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <String>::sse_encode(self.PrivateKey, serializer);
    }
}

impl SseEncode for crate::common::network::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::network::Network::Bitcoin => 0,
                crate::common::network::Network::Testnet => 1,
                crate::common::network::Network::Signet => 2,
                crate::common::network::Network::Regtest => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<std::collections::HashMap<String, String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <std::collections::HashMap<String, String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<FrbAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <FrbAccount>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<FrbAddressDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <FrbAddressDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<FrbDetailledTxOutput> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <FrbDetailledTxOutput>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_wallet::db::model::account_model::AccountModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_wallet::db::model::account_model::AccountModel>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::proton_api::contacts::ApiContactEmails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::contacts::ApiContactEmails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::ApiWallet> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::ApiWallet>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet_account::ApiWalletAccount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet_account::ApiWalletAccount>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::ApiWalletKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::ApiWalletKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet_settings::ApiWalletSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet_settings::ApiWalletSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::user_settings::ApiWalletUserSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::user_settings::ApiWalletUserSettings>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::common::broadcast_message::BroadcastMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::common::broadcast_message::BroadcastMessage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::FlagsSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::FlagsSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::payment_gateway::GatewayProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::HighSecuritySettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::HighSecuritySettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::common::pagination::Pagination> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::common::pagination::Pagination>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::PasswordSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::PasswordSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::payment_gateway::PaymentMethod> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::payment_gateway::PaymentMethod>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::PhoneSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::PhoneSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::exchange_rate::ProtonExchangeRate> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::exchange_rate::ProtonExchangeRate>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::ProtonUser> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::ProtonUser>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::ProtonUserSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::ProtonUserSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::ReferralSettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::ReferralSettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::common::pagination::SortOrder> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::common::pagination::SortOrder>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::TransactionType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::TransactionType>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_api::proton_users::TwoFASettings> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::proton_users::TwoFASettings>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::proton_wallet::db::model::wallet_model::WalletModel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_wallet::db::model::wallet_model::WalletModel>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::proton_api::wallet::WalletTransaction> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::proton_api::wallet::WalletTransaction>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::ContactEmailEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::ContactEmailEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::proton_address::ProtonAddressKey>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::proton_users::ProtonUserKey>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::proton_users::ProtonUserKey>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletAccountEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletAccountEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletEvent>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletKeyEvent>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletSettingsEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletSettingsEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<crate::proton_api::event_routes::WalletTransactionEvent>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::proton_api::event_routes::WalletTransactionEvent>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for crate::common::pagination::Pagination {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.skip, serializer);
        <usize>::sse_encode(self.take, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::PasswordSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::proton_api::payment_gateway::PaymentMethod {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::payment_gateway::PaymentMethod::ApplePay => 0,
                crate::proton_api::payment_gateway::PaymentMethod::BankTransfer => 1,
                crate::proton_api::payment_gateway::PaymentMethod::Card => 2,
                crate::proton_api::payment_gateway::PaymentMethod::GooglePay => 3,
                crate::proton_api::payment_gateway::PaymentMethod::InstantPayment => 4,
                crate::proton_api::payment_gateway::PaymentMethod::Paypal => 5,
                crate::proton_api::payment_gateway::PaymentMethod::Unsupported => 6,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_users::PhoneSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::proton_api::price_graph::PriceGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(self.FiatCurrency, serializer);
        <crate::proton_api::user_settings::BitcoinUnit>::sse_encode(self.BitcoinUnit, serializer);
        <Vec<crate::proton_api::price_graph::DataPoint>>::sse_encode(self.GraphData, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_address::ProtonAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <Option<String>>::sse_encode(self.domain_id, serializer);
        <String>::sse_encode(self.email, serializer);
        <u32>::sse_encode(self.status, serializer);
        <u32>::sse_encode(self.r#type, serializer);
        <u32>::sse_encode(self.receive, serializer);
        <u32>::sse_encode(self.send, serializer);
        <String>::sse_encode(self.display_name, serializer);
        <Option<Vec<crate::proton_api::proton_address::ProtonAddressKey>>>::sse_encode(
            self.keys, serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_address::ProtonAddressKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.version, serializer);
        <String>::sse_encode(self.public_key, serializer);
        <Option<String>>::sse_encode(self.private_key, serializer);
        <Option<String>>::sse_encode(self.token, serializer);
        <Option<String>>::sse_encode(self.signature, serializer);
        <u32>::sse_encode(self.primary, serializer);
        <u32>::sse_encode(self.active, serializer);
        <u32>::sse_encode(self.flags, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::ProtonEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.event_id, serializer);
        <u32>::sse_encode(self.refresh, serializer);
        <u32>::sse_encode(self.more, serializer);
        <Option<Vec<crate::proton_api::event_routes::ContactEmailEvent>>>::sse_encode(
            self.contact_email_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletEvent>>>::sse_encode(
            self.wallet_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletAccountEvent>>>::sse_encode(
            self.wallet_account_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletKeyEvent>>>::sse_encode(
            self.wallet_key_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletSettingsEvent>>>::sse_encode(
            self.wallet_setting_events,
            serializer,
        );
        <Option<Vec<crate::proton_api::event_routes::WalletTransactionEvent>>>::sse_encode(
            self.wallet_transaction_events,
            serializer,
        );
        <Option<crate::proton_api::user_settings::ApiWalletUserSettings>>::sse_encode(
            self.wallet_user_settings,
            serializer,
        );
        <Option<crate::proton_api::proton_users::ProtonUser>>::sse_encode(
            self.proton_user,
            serializer,
        );
        <Option<crate::proton_api::proton_users::ProtonUserSettings>>::sse_encode(
            self.proton_user_settings,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::exchange_rate::ProtonExchangeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::proton_api::user_settings::BitcoinUnit>::sse_encode(self.bitcoin_unit, serializer);
        <crate::proton_api::user_settings::FiatCurrency>::sse_encode(
            self.fiat_currency,
            serializer,
        );
        <String>::sse_encode(self.exchange_rate_time, serializer);
        <u64>::sse_encode(self.exchange_rate, serializer);
        <u64>::sse_encode(self.cents, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::ProtonSrpClientProofs {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ClientEphemeral, serializer);
        <String>::sse_encode(self.ClientProof, serializer);
        <String>::sse_encode(self.SRPSession, serializer);
        <Option<String>>::sse_encode(self.TwoFactorCode, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::ProtonUser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <Option<String>>::sse_encode(self.Name, serializer);
        <u64>::sse_encode(self.UsedSpace, serializer);
        <String>::sse_encode(self.Currency, serializer);
        <u32>::sse_encode(self.Credit, serializer);
        <u64>::sse_encode(self.CreateTime, serializer);
        <u64>::sse_encode(self.MaxSpace, serializer);
        <u64>::sse_encode(self.MaxUpload, serializer);
        <u32>::sse_encode(self.Role, serializer);
        <u32>::sse_encode(self.Private, serializer);
        <u32>::sse_encode(self.Subscribed, serializer);
        <u32>::sse_encode(self.Services, serializer);
        <u32>::sse_encode(self.Delinquent, serializer);
        <Option<String>>::sse_encode(self.OrganizationPrivateKey, serializer);
        <String>::sse_encode(self.Email, serializer);
        <Option<String>>::sse_encode(self.DisplayName, serializer);
        <Option<Vec<crate::proton_api::proton_users::ProtonUserKey>>>::sse_encode(
            self.Keys, serializer,
        );
        <u32>::sse_encode(self.MnemonicStatus, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::ProtonUserKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ID, serializer);
        <u32>::sse_encode(self.Version, serializer);
        <String>::sse_encode(self.PrivateKey, serializer);
        <Option<String>>::sse_encode(self.RecoverySecret, serializer);
        <Option<String>>::sse_encode(self.RecoverySecretSignature, serializer);
        <Option<String>>::sse_encode(self.Token, serializer);
        <String>::sse_encode(self.Fingerprint, serializer);
        <u32>::sse_encode(self.Primary, serializer);
        <u32>::sse_encode(self.Active, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::ProtonUserSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::proton_users::EmailSettings>::sse_encode(self.Email, serializer);
        <Option<crate::proton_api::proton_users::PasswordSettings>>::sse_encode(
            self.Password,
            serializer,
        );
        <Option<crate::proton_api::proton_users::PhoneSettings>>::sse_encode(
            self.Phone, serializer,
        );
        <Option<crate::proton_api::proton_users::TwoFASettings>>::sse_encode(
            self.two_fa,
            serializer,
        );
        <u32>::sse_encode(self.News, serializer);
        <String>::sse_encode(self.Locale, serializer);
        <u32>::sse_encode(self.LogAuth, serializer);
        <String>::sse_encode(self.InvoiceText, serializer);
        <u32>::sse_encode(self.Density, serializer);
        <u32>::sse_encode(self.WeekStart, serializer);
        <u32>::sse_encode(self.DateFormat, serializer);
        <u32>::sse_encode(self.TimeFormat, serializer);
        <u32>::sse_encode(self.Welcome, serializer);
        <u32>::sse_encode(self.WelcomeFlag, serializer);
        <u32>::sse_encode(self.EarlyAccess, serializer);
        <Option<crate::proton_api::proton_users::FlagsSettings>>::sse_encode(
            self.Flags, serializer,
        );
        <Option<crate::proton_api::proton_users::ReferralSettings>>::sse_encode(
            self.Referral,
            serializer,
        );
        <Option<u32>>::sse_encode(self.DeviceRecovery, serializer);
        <u32>::sse_encode(self.Telemetry, serializer);
        <u32>::sse_encode(self.CrashReports, serializer);
        <u32>::sse_encode(self.HideSidePanel, serializer);
        <Option<crate::proton_api::proton_users::HighSecuritySettings>>::sse_encode(
            self.HighSecurity,
            serializer,
        );
        <u32>::sse_encode(self.SessionAccountRecovery, serializer);
    }
}

impl SseEncode for crate::proton_api::payment_gateway::Quote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.BitcoinAmount, serializer);
        <String>::sse_encode(self.FiatAmount, serializer);
        <String>::sse_encode(self.FiatCurrencySymbol, serializer);
        <String>::sse_encode(self.NetworkFee, serializer);
        <String>::sse_encode(self.PaymentGatewayFee, serializer);
        <crate::proton_api::payment_gateway::PaymentMethod>::sse_encode(
            self.PaymentMethod,
            serializer,
        );
        <Option<String>>::sse_encode(self.PurchaseAmount, serializer);
        <Option<String>>::sse_encode(self.PaymentProcessingFee, serializer);
        <Option<String>>::sse_encode(self.OrderID, serializer);
    }
}

impl SseEncode for crate::common::blockchain::RecommendedFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.FastestFee, serializer);
        <u8>::sse_encode(self.HalfHourFee, serializer);
        <u8>::sse_encode(self.HourFee, serializer);
        <u8>::sse_encode(self.EconomyFee, serializer);
        <u8>::sse_encode(self.MinimumFee, serializer);
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiCountry>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::ApiCountry>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::ApiSimpleFiatCurrency>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::PaymentMethod>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::PaymentMethod>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        crate::proton_api::payment_gateway::GatewayProvider,
        Vec<crate::proton_api::payment_gateway::Quote>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::proton_api::payment_gateway::GatewayProvider>::sse_encode(self.0, serializer);
        <Vec<crate::proton_api::payment_gateway::Quote>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::ReferralSettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::proton_api::invite::RemainingMonthlyInvitations {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.Used, serializer);
        <u8>::sse_encode(self.Available, serializer);
    }
}

impl SseEncode for crate::api::errors::ResponseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.error, serializer);
        <String>::sse_encode(self.details, serializer);
    }
}

impl SseEncode for crate::common::script_type::ScriptType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::script_type::ScriptType::Legacy => 0,
                crate::common::script_type::ScriptType::NestedSegwit => 1,
                crate::common::script_type::ScriptType::NativeSegwit => 2,
                crate::common::script_type::ScriptType::Taproot => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_users::SetTwoFaTOTPRequestBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.TOTPConfirmation, serializer);
        <String>::sse_encode(self.TOTPSharedSecret, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::SetTwoFaTOTPResponseBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.Code, serializer);
        <Vec<String>>::sse_encode(self.TwoFactorRecoveryCodes, serializer);
        <crate::proton_api::proton_users::ProtonUserSettings>::sse_encode(
            self.UserSettings,
            serializer,
        );
    }
}

impl SseEncode for crate::common::pagination::SortOrder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::pagination::SortOrder::Asc => 0,
                crate::common::pagination::SortOrder::Desc => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::srp::proofs::SRPProofB64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.client_ephemeral, serializer);
        <String>::sse_encode(self.client_proof, serializer);
        <String>::sse_encode(self.expected_server_proof, serializer);
    }
}

impl SseEncode for crate::proton_api::price_graph::Timeframe {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::price_graph::Timeframe::OneDay => 0,
                crate::proton_api::price_graph::Timeframe::OneWeek => 1,
                crate::proton_api::price_graph::Timeframe::OneMonth => 2,
                crate::proton_api::price_graph::Timeframe::Unsupported => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::common::transaction_time::TransactionTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::common::transaction_time::TransactionTime::Confirmed { confirmation_time } => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(confirmation_time, serializer);
            }
            crate::common::transaction_time::TransactionTime::Unconfirmed { last_seen } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(last_seen, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::proton_api::wallet::TransactionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::proton_api::wallet::TransactionType::NotSend => 0,
                crate::proton_api::wallet::TransactionType::ProtonToProtonSend => 1,
                crate::proton_api::wallet::TransactionType::ProtonToProtonReceive => 2,
                crate::proton_api::wallet::TransactionType::ExternalSend => 3,
                crate::proton_api::wallet::TransactionType::ExternalReceive => 4,
                crate::proton_api::wallet::TransactionType::Unsupported => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::proton_users::TwoFA {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.Enabled, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::TwoFASettings {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.Enabled, serializer);
        <u32>::sse_encode(self.Allowed, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::proton_api::unleash::UnleashResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.status_code, serializer);
        <Vec<u8>>::sse_encode(self.body, serializer);
    }
}

impl SseEncode for crate::proton_api::proton_users::UpdateMnemonicSettingsRequestBody {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::proton_api::proton_users::MnemonicUserKey>>::sse_encode(
            self.MnemonicUserKeys,
            serializer,
        );
        <String>::sse_encode(self.MnemonicSalt, serializer);
        <crate::proton_api::proton_users::MnemonicAuth>::sse_encode(self.MnemonicAuth, serializer);
    }
}

impl SseEncode for crate::proton_api::user_settings::UserReceiveNotificationEmailTypes {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::NotificationToInviter => { 0 }
crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::EmailIntegration => { 1 }
crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::TransactionalBvE => { 2 }
crate::proton_api::user_settings::UserReceiveNotificationEmailTypes::Unsupported => { 3 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletAccountEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet_account::ApiWalletAccount>>::sse_encode(
            self.wallet_account,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet::ApiWallet>>::sse_encode(self.wallet, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletKeyEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet::ApiWalletKey>>::sse_encode(self.wallet_key, serializer);
    }
}

impl SseEncode for crate::api::bdk_wallet::storage::WalletMobileConnectorFactory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.folder_path, serializer);
    }
}

impl SseEncode for crate::proton_wallet::db::model::wallet_model::WalletModel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <u32>::sse_encode(self.passphrase, serializer);
        <String>::sse_encode(self.public_key, serializer);
        <u32>::sse_encode(self.imported, serializer);
        <u32>::sse_encode(self.priority, serializer);
        <u32>::sse_encode(self.status, serializer);
        <u32>::sse_encode(self.type_, serializer);
        <u32>::sse_encode(self.create_time, serializer);
        <u32>::sse_encode(self.modify_time, serializer);
        <String>::sse_encode(self.user_id, serializer);
        <String>::sse_encode(self.wallet_id, serializer);
        <u32>::sse_encode(self.account_count, serializer);
        <f64>::sse_encode(self.balance, serializer);
        <Option<String>>::sse_encode(self.fingerprint, serializer);
        <u32>::sse_encode(self.show_wallet_recovery, serializer);
        <u32>::sse_encode(self.migration_required, serializer);
        <Option<u32>>::sse_encode(self.legacy, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletSettingsEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet_settings::ApiWalletSettings>>::sse_encode(
            self.wallet_settings,
            serializer,
        );
    }
}

impl SseEncode for crate::proton_api::wallet::WalletTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <Option<crate::proton_api::wallet::TransactionType>>::sse_encode(self.r#type, serializer);
        <String>::sse_encode(self.wallet_id, serializer);
        <Option<String>>::sse_encode(self.wallet_account_id, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <String>::sse_encode(self.transaction_id, serializer);
        <String>::sse_encode(self.transaction_time, serializer);
        <u8>::sse_encode(self.is_suspicious, serializer);
        <u8>::sse_encode(self.is_private, serializer);
        <Option<u8>>::sse_encode(self.is_anonymous, serializer);
        <Option<crate::proton_api::exchange_rate::ProtonExchangeRate>>::sse_encode(
            self.exchange_rate,
            serializer,
        );
        <Option<String>>::sse_encode(self.hashed_transaction_id, serializer);
        <Option<String>>::sse_encode(self.subject, serializer);
        <Option<String>>::sse_encode(self.body, serializer);
        <Option<String>>::sse_encode(self.sender, serializer);
        <Option<String>>::sse_encode(self.tolist, serializer);
    }
}

impl SseEncode for crate::proton_api::event_routes::WalletTransactionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.action, serializer);
        <Option<crate::proton_api::wallet::WalletTransaction>>::sse_encode(
            self.wallet_transaction,
            serializer,
        );
    }
}

impl SseEncode for crate::common::word_count::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::common::word_count::WordCount::Words12 => 0,
                crate::common::word_count::WordCount::Words15 => 1,
                crate::common::word_count::WordCount::Words18 => 2,
                crate::common::word_count::WordCount::Words21 => 3,
                crate::common::word_count::WordCount::Words24 => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.6.0.

    // Section: imports

    use super::*;
    use crate::api::api_service::address_client::*;
    use crate::api::api_service::bitcoin_address_client::*;
    use crate::api::api_service::block_client::*;
    use crate::api::api_service::discovery_content_client::*;
    use crate::api::api_service::email_integration_client::*;
    use crate::api::api_service::event_client::*;
    use crate::api::api_service::exchange_rate_client::*;
    use crate::api::api_service::invite_client::*;
    use crate::api::api_service::onramp_gateway_client::*;
    use crate::api::api_service::price_graph_client::*;
    use crate::api::api_service::proton_api_service::*;
    use crate::api::api_service::proton_contacts_client::*;
    use crate::api::api_service::proton_email_addr_client::*;
    use crate::api::api_service::proton_settings_client::*;
    use crate::api::api_service::proton_users_client::*;
    use crate::api::api_service::settings_client::*;
    use crate::api::api_service::transaction_client::*;
    use crate::api::api_service::unleash_client::*;
    use crate::api::api_service::wallet_auth_store::*;
    use crate::api::api_service::wallet_client::*;
    use crate::api::bdk_wallet::account::*;
    use crate::api::bdk_wallet::address::*;
    use crate::api::bdk_wallet::amount::*;
    use crate::api::bdk_wallet::balance::*;
    use crate::api::bdk_wallet::blockchain::*;
    use crate::api::bdk_wallet::derivation_path::*;
    use crate::api::bdk_wallet::discovered_account::*;
    use crate::api::bdk_wallet::local_output::*;
    use crate::api::bdk_wallet::mnemonic::*;
    use crate::api::bdk_wallet::payment_link::*;
    use crate::api::bdk_wallet::psbt::*;
    use crate::api::bdk_wallet::script_buf::*;
    use crate::api::bdk_wallet::sequence::*;
    use crate::api::bdk_wallet::transaction_builder::*;
    use crate::api::bdk_wallet::transaction_details::*;
    use crate::api::bdk_wallet::transaction_details_txin::*;
    use crate::api::bdk_wallet::transaction_details_txop::*;
    use crate::api::bdk_wallet::transactions::*;
    use crate::api::bdk_wallet::wallet::*;
    use crate::api::proton_wallet::crypto::wallet_key::*;
    use crate::api::proton_wallet::db::app_database_helper::*;
    use crate::api::proton_wallet::features::backup_mnemonic::*;
    use crate::api::proton_wallet::features::proton_recovery::*;
    use crate::api::proton_wallet::storage::user_key_store::*;
    use crate::api::proton_wallet::storage::wallet_key_store::*;
    use crate::api::proton_wallet::storage::wallet_mnemonic_store::*;
    use crate::api::proton_wallet::wallet::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < ProtonAPIService >>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < ProtonAPIService >>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlockClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlockClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlockClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ContactsClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDiscoveredAccount(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDiscoveredAccount(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveredAccount>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDiscoveryContentClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDiscoveryContentClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DiscoveryContentClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EmailIntegrationClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExchangeRateClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAccount(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAccount(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAccount>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAddress(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAddress(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddress>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAddressDetails(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAddressDetails(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAddressDetails>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAmount(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAmount(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAmount>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAppDatabase(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbAppDatabase(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbAppDatabase>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbBackupMnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbBackupMnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBackupMnemonic>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbBalance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbBalance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBalance>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbBlockchainClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbBlockchainClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbBlockchainClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbDerivationPath(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbDerivationPath(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDerivationPath>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbDetailledTxIn(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbDetailledTxIn(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxIn>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbDetailledTxOutput(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbDetailledTxOutput(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbDetailledTxOutput>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbLocalOutput(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbLocalOutput(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbLocalOutput>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbMnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbMnemonic(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbMnemonic>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbPaymentLink(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbPaymentLink(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPaymentLink>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbProtonRecovery(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbProtonRecovery(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonRecovery>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbProtonWallet(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbProtonWallet(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbProtonWallet>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbPsbt(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbPsbt(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbPsbt>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbScriptBuf(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbScriptBuf(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbScriptBuf>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbSequence(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbSequence(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbSequence>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransaction>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTransactionDetails(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTransactionDetails(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTransactionDetails>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTxBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTxBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxBuilder>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTxOut(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbTxOut(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbTxOut>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbUnleashClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbUnleashClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnleashClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbUnlockedWalletKey(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbUnlockedWalletKey(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUnlockedWalletKey>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbUserKeyStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbUserKeyStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbUserKeyStore>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbWallet(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbWallet(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWallet>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbWalletKeyStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbWalletKeyStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletKeyStore>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbWalletMnemonicStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFrbWalletMnemonicStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FrbWalletMnemonicStore>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInviteClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerInviteClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InviteClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnRampGatewayClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPriceGraphClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPriceGraphClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceGraphClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonAPIService>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonEmailAddressClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonSettingsClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonSettingsClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonSettingsClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonUsersClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProtonWalletAuthStore>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SettingsClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WalletClient>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<bdkTransaction>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
