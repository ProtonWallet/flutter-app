// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.33.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/api2.dart';
import 'api/api_service/address_client.dart';
import 'api/api_service/bitcoin_address_client.dart';
import 'api/api_service/email_integration_client.dart';
import 'api/api_service/event_client.dart';
import 'api/api_service/exchange_rate_client.dart';
import 'api/api_service/onramp_gateway_client.dart';
import 'api/api_service/proton_api_service.dart';
import 'api/api_service/proton_contacts_client.dart';
import 'api/api_service/proton_email_addr_client.dart';
import 'api/api_service/proton_users_client.dart';
import 'api/api_service/settings_client.dart';
import 'api/api_service/transaction_client.dart';
import 'api/api_service/wallet_auth_store.dart';
import 'api/api_service/wallet_client.dart';
import 'api/bdk_wallet.dart';
import 'api/flutter_logger.dart';
import 'api/ldk_api.dart';
import 'api/proton_api.dart';
import 'api/rust_api.dart';
import 'api/rust_objects.dart';
import 'bdk/blockchain.dart';
import 'bdk/error.dart';
import 'bdk/types.dart';
import 'bdk/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'proton_api/auth_credential.dart';
import 'proton_api/contacts.dart';
import 'proton_api/errors.dart';
import 'proton_api/event_routes.dart';
import 'proton_api/exchange_rate.dart';
import 'proton_api/payment_gateway.dart';
import 'proton_api/proton_address.dart';
import 'proton_api/user_settings.dart';
import 'proton_api/wallet.dart';
import 'proton_api/wallet_account.dart';
import 'proton_api/wallet_settings.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.initApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.33';

  @override
  int get rustContentHash => 740389886;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'proton_wallet_common',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<int> addOne({required int left, required int right, dynamic hint});

  Future<int> addThree({required int left, required int right, dynamic hint});

  String greet({required String name, dynamic hint});

  String helloworld({dynamic hint});

  Future<void> initApp({dynamic hint});

  Future<AddressBalance> addressClientGetAddressBalance(
      {required AddressClient that, required String address, dynamic hint});

  Future<List<ApiTx>> addressClientGetScripthashTransactions(
      {required AddressClient that, required String scriptHash, dynamic hint});

  Future<List<ApiTx>> addressClientGetScripthashTransactionsAtTransactionId(
      {required AddressClient that,
      required String scriptHash,
      required String transactionId,
      dynamic hint});

  Future<AddressClient> addressClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<List<ApiWalletBitcoinAddress>> bitcoinAddressClientAddBitcoinAddresses(
      {required BitcoinAddressClient that,
      required String walletId,
      required String walletAccountId,
      required List<BitcoinAddress> bitcoinAddresses,
      dynamic hint});

  Future<int> bitcoinAddressClientGetBitcoinAddressLatestIndex(
      {required BitcoinAddressClient that,
      required String walletId,
      required String walletAccountId,
      dynamic hint});

  Future<List<ApiWalletBitcoinAddress>>
      bitcoinAddressClientGetWalletBitcoinAddress(
          {required BitcoinAddressClient that,
          required String walletId,
          required String walletAccountId,
          int? onlyRequest,
          dynamic hint});

  Future<BitcoinAddressClient> bitcoinAddressClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<ApiWalletBitcoinAddress> bitcoinAddressClientUpdateBitcoinAddress(
      {required BitcoinAddressClient that,
      required String walletId,
      required String walletAccountId,
      required String walletAccountBitcoinAddressId,
      required BitcoinAddress bitcoinAddress,
      dynamic hint});

  Future<EmailIntegrationBitcoinAddress>
      emailIntegrationClientLookupBitcoinAddress(
          {required EmailIntegrationClient that,
          required String email,
          dynamic hint});

  Future<EmailIntegrationClient> emailIntegrationClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<List<ProtonEvent>> eventClientCollectEvents(
      {required EventClient that, required String latestEventId, dynamic hint});

  Future<String> eventClientGetLatestEventId(
      {required EventClient that, dynamic hint});

  Future<bool> eventClientIsValidToken(
      {required EventClient that, dynamic hint});

  Future<EventClient> eventClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<ProtonExchangeRate> exchangeRateClientGetExchangeRate(
      {required ExchangeRateClient that,
      required FiatCurrency fiatCurrency,
      int? time,
      dynamic hint});

  Future<ExchangeRateClient> exchangeRateClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<String> onRampGatewayClientCreateOnRampCheckout(
      {required OnRampGatewayClient that,
      required String amount,
      required String btcAddress,
      required FiatCurrency fiatCurrency,
      required PaymentMethod payMethod,
      required GatewayProvider provider,
      dynamic hint});

  Future<Map<GatewayProvider, List<ApiCountry>>>
      onRampGatewayClientGetCountries(
          {required OnRampGatewayClient that, dynamic hint});

  Future<Map<GatewayProvider, List<ApiCountryFiatCurrency>>>
      onRampGatewayClientGetFiatCurrencies(
          {required OnRampGatewayClient that, dynamic hint});

  Future<Map<GatewayProvider, List<PaymentMethod>>>
      onRampGatewayClientGetPaymentMethods(
          {required OnRampGatewayClient that,
          required FiatCurrency fiatSymbol,
          dynamic hint});

  Future<Map<GatewayProvider, List<Quote>>> onRampGatewayClientGetQuotes(
      {required OnRampGatewayClient that,
      required String amount,
      required FiatCurrency fiatCurrency,
      PaymentMethod? payMethod,
      GatewayProvider? provider,
      dynamic hint});

  Future<OnRampGatewayClient> onRampGatewayClientNew(
      {required ProtonApiService service, dynamic hint});

  AddressClient protonApiServiceGetAddressClient(
      {required ProtonApiService that, dynamic hint});

  BitcoinAddressClient protonApiServiceGetBitcoinAddrClient(
      {required ProtonApiService that, dynamic hint});

  EmailIntegrationClient protonApiServiceGetEmailIntegrationClient(
      {required ProtonApiService that, dynamic hint});

  EventClient protonApiServiceGetEventClient(
      {required ProtonApiService that, dynamic hint});

  ExchangeRateClient protonApiServiceGetExchangeRateClient(
      {required ProtonApiService that, dynamic hint});

  OnRampGatewayClient protonApiServiceGetOnRampGatewayClient(
      {required ProtonApiService that, dynamic hint});

  ContactsClient protonApiServiceGetProtonContactsClient(
      {required ProtonApiService that, dynamic hint});

  ProtonEmailAddressClient protonApiServiceGetProtonEmailAddrClient(
      {required ProtonApiService that, dynamic hint});

  SettingsClient protonApiServiceGetSettingsClient(
      {required ProtonApiService that, dynamic hint});

  TransactionClient protonApiServiceGetTransactionClient(
      {required ProtonApiService that, dynamic hint});

  WalletClient protonApiServiceGetWalletClient(
      {required ProtonApiService that, dynamic hint});

  Future<List<ApiWalletData>> protonApiServiceGetWallets(
      {required ProtonApiService that, dynamic hint});

  Future<AuthCredential> protonApiServiceLogin(
      {required ProtonApiService that,
      required String username,
      required String password,
      dynamic hint});

  Future<void> protonApiServiceLogout(
      {required ProtonApiService that, dynamic hint});

  ProtonApiService protonApiServiceNew(
      {required String env,
      required String appVersion,
      required String userAgent,
      required ProtonWalletAuthStore store,
      dynamic hint});

  Future<void> protonApiServiceSetProtonApi(
      {required ProtonApiService that, dynamic hint});

  Future<void> protonApiServiceUpdateAuth(
      {required ProtonApiService that,
      required String uid,
      required String access,
      required String refresh,
      required List<String> scopes,
      dynamic hint});

  Future<List<ApiContactEmails>> contactsClientGetContacts(
      {required ContactsClient that, dynamic hint});

  Future<ContactsClient> contactsClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<List<AllKeyAddressKey>> protonEmailAddressClientGetAllPublicKeys(
      {required ProtonEmailAddressClient that,
      required String email,
      required int internalOnly,
      dynamic hint});

  Future<List<ProtonAddress>> protonEmailAddressClientGetProtonAddress(
      {required ProtonEmailAddressClient that, dynamic hint});

  Future<ProtonEmailAddressClient> protonEmailAddressClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<ProtonUsersClient> protonUsersClientNew(
      {required ArcProtonApiService client, dynamic hint});

  Future<ApiWalletUserSettings> settingsClientBitcoinUnit(
      {required SettingsClient that,
      required BitcoinUnit symbol,
      dynamic hint});

  Future<ApiWalletUserSettings> settingsClientFiatCurrency(
      {required SettingsClient that,
      required FiatCurrency symbol,
      dynamic hint});

  Future<ApiWalletUserSettings> settingsClientGetUserSettings(
      {required SettingsClient that, dynamic hint});

  Future<ApiWalletUserSettings> settingsClientHideEmptyUsedAddresses(
      {required SettingsClient that,
      required bool hideEmptyUsedAddresses,
      dynamic hint});

  Future<SettingsClient> settingsClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<ApiWalletUserSettings> settingsClientTwoFaThreshold(
      {required SettingsClient that, required int amount, dynamic hint});

  Future<String> transactionClientBroadcastRawTransaction(
      {required TransactionClient that,
      required String signedTransactionHex,
      required String walletId,
      required String walletAccountId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      String? addressId,
      String? subject,
      String? body,
      dynamic hint});

  Future<BdkTransaction> transactionClientGetRawTransaction(
      {required TransactionClient that, required String txid, dynamic hint});

  Future<TransactionClient> transactionClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<void> protonWalletAuthStoreClearAuthDartCallback(
      {required ProtonWalletAuthStore that, dynamic hint});

  ProtonWalletAuthStore protonWalletAuthStoreFromSession(
      {required String env,
      required String uid,
      required String access,
      required String refresh,
      required List<String> scopes,
      dynamic hint});

  Future<void> protonWalletAuthStoreLogout(
      {required ProtonWalletAuthStore that, dynamic hint});

  ProtonWalletAuthStore protonWalletAuthStoreNew(
      {required String env, dynamic hint});

  Future<void> protonWalletAuthStoreSetAuthDartCallback(
      {required ProtonWalletAuthStore that,
      required FutureOr<String> Function(ChildSession) callback,
      dynamic hint});

  void protonWalletAuthStoreSetAuthSync(
      {required ProtonWalletAuthStore that,
      required String uid,
      required String access,
      required String refresh,
      required List<String> scopes,
      dynamic hint});

  Future<ApiWalletAccount> walletClientAddEmailAddress(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint});

  Future<ApiWalletData> walletClientCreateWallet(
      {required WalletClient that,
      required CreateWalletReq walletReq,
      dynamic hint});

  Future<ApiWalletAccount> walletClientCreateWalletAccount(
      {required WalletClient that,
      required String walletId,
      required CreateWalletAccountReq req,
      dynamic hint});

  Future<WalletTransaction> walletClientCreateWalletTransactions(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String transactionId,
      required String hashedTransactionId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      dynamic hint});

  Future<void> walletClientDeleteWallet(
      {required WalletClient that, required String walletId, dynamic hint});

  Future<void> walletClientDeleteWalletAccount(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      dynamic hint});

  Future<void> walletClientDeleteWalletTransactions(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      dynamic hint});

  Future<List<ApiWalletAccount>> walletClientGetWalletAccounts(
      {required WalletClient that, required String walletId, dynamic hint});

  Future<List<WalletTransaction>> walletClientGetWalletTransactions(
      {required WalletClient that,
      required String walletId,
      String? walletAccountId,
      List<String>? hashedTxids,
      dynamic hint});

  Future<List<ApiWalletData>> walletClientGetWallets(
      {required WalletClient that, dynamic hint});

  Future<WalletClient> walletClientNew(
      {required ProtonApiService service, dynamic hint});

  Future<ApiWalletAccount> walletClientRemoveEmailAddress(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint});

  Future<ApiWalletAccount> walletClientUpdateWalletAccountLabel(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String newLabel,
      dynamic hint});

  Future<ApiWallet> walletClientUpdateWalletName(
      {required WalletClient that,
      required String walletId,
      required String newName,
      dynamic hint});

  Future<WalletTransaction> walletClientUpdateWalletTransactionLabel(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      required String label,
      dynamic hint});

  String bdkWalletManagerFingerprint(
      {required BdkWalletManager that, dynamic hint});

  Future<BdkWalletManager> bdkWalletManagerNew(
      {required Network network,
      required String bip39Mnemonic,
      String? bip38Passphrase,
      dynamic hint});

  Stream<LogEntry> infoLogger({dynamic hint});

  Future<void> panic({dynamic hint});

  Future<void> test({required int i, dynamic hint});

  Future<int> addTwo({required int left, required int right, dynamic hint});

  Future<String> testOne({dynamic hint});

  Future<List<ApiWalletBitcoinAddress>> addBitcoinAddresses(
      {required String walletId,
      required String walletAccountId,
      required List<BitcoinAddress> bitcoinAddresses,
      dynamic hint});

  Future<ApiWalletAccount> addEmailAddress(
      {required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint});

  Future<ApiWalletUserSettings> bitcoinUnit(
      {required BitcoinUnit symbol, dynamic hint});

  Future<String> broadcastRawTransaction(
      {required String signedTransactionHex,
      required String walletId,
      required String walletAccountId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      String? addressId,
      String? subject,
      String? body,
      dynamic hint});

  Future<List<ProtonEvent>> collectEvents(
      {required String latestEventId, dynamic hint});

  Future<ApiWalletData> createWallet(
      {required CreateWalletReq walletReq, dynamic hint});

  Future<ApiWalletAccount> createWalletAccount(
      {required String walletId,
      required CreateWalletAccountReq req,
      dynamic hint});

  Future<WalletTransaction> createWalletTransactions(
      {required String walletId,
      required String walletAccountId,
      required String transactionId,
      required String hashedTransactionId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      dynamic hint});

  Future<void> deleteWallet({required String walletId, dynamic hint});

  Future<void> deleteWalletAccount(
      {required String walletId,
      required String walletAccountId,
      dynamic hint});

  Future<void> deleteWalletTransactions(
      {required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      dynamic hint});

  Future<ApiWalletUserSettings> fiatCurrency(
      {required FiatCurrency symbol, dynamic hint});

  Future<ChildSession> fork({dynamic hint});

  Future<List<AllKeyAddressKey>> getAllPublicKeys(
      {required String email, required int internalOnly, dynamic hint});

  Future<int> getBitcoinAddressLatestIndex(
      {required String walletId,
      required String walletAccountId,
      dynamic hint});

  Future<List<ApiContactEmails>> getContacts({dynamic hint});

  Future<ProtonExchangeRate> getExchangeRate(
      {required FiatCurrency fiatCurrency, int? time, dynamic hint});

  Future<String> getLatestEventId({dynamic hint});

  Future<List<ProtonAddress>> getProtonAddress({dynamic hint});

  Future<ApiWalletUserSettings> getUserSettings({dynamic hint});

  Future<List<ApiWalletAccount>> getWalletAccounts(
      {required String walletId, dynamic hint});

  Future<List<ApiWalletBitcoinAddress>> getWalletBitcoinAddress(
      {required String walletId,
      required String walletAccountId,
      int? onlyRequest,
      dynamic hint});

  Future<List<WalletTransaction>> getWalletTransactions(
      {required String walletId,
      String? walletAccountId,
      List<String>? hashedTxids,
      dynamic hint});

  Future<List<ApiWalletData>> getWallets({dynamic hint});

  Future<ApiWalletUserSettings> hideEmptyUsedAddresses(
      {required bool hideEmptyUsedAddresses, dynamic hint});

  Future<bool> isValidToken({dynamic hint});

  Future<EmailIntegrationBitcoinAddress> lookupBitcoinAddress(
      {required String email, dynamic hint});

  Future<ApiWalletAccount> removeEmailAddress(
      {required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint});

  Future<ApiWalletUserSettings> twoFaThreshold(
      {required int amount, dynamic hint});

  Future<ApiWalletBitcoinAddress> updateBitcoinAddress(
      {required String walletId,
      required String walletAccountId,
      required String walletAccountBitcoinAddressId,
      required BitcoinAddress bitcoinAddress,
      dynamic hint});

  Future<ApiWalletAccount> updateWalletAccountFiatCurrency(
      {required String walletId,
      required String walletAccountId,
      required FiatCurrency newFiatCurrency,
      dynamic hint});

  Future<ApiWalletAccount> updateWalletAccountLabel(
      {required String walletId,
      required String walletAccountId,
      required String newLabel,
      dynamic hint});

  Future<ApiWallet> updateWalletName(
      {required String walletId, required String newName, dynamic hint});

  Future<WalletTransaction> updateWalletTransactionLabel(
      {required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      required String label,
      dynamic hint});

  Future<String> apiAddressFromScript(
      {required Script script, required Network network, dynamic hint});

  Future<Network> apiAddressNetwork({required String address, dynamic hint});

  Future<Script> apiAddressToScriptPubkey(
      {required String address, dynamic hint});

  Future<String> apiBroadcast(
      {required String tx, required String blockchainId, dynamic hint});

  Future<(String, TransactionDetails)> apiBumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required String walletId,
      required bool enableRbf,
      int? nSequence,
      dynamic hint});

  Future<String> apiCombinePsbt(
      {required String psbtStr, required String other, dynamic hint});

  Future<String> apiCreateAddress({required String address, dynamic hint});

  Future<String> apiCreateDerivationPath({required String path, dynamic hint});

  Future<String> apiCreateDescriptor(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiCreateDescriptorPublic(
      {String? xpub, required String path, required bool derive, dynamic hint});

  Future<String> apiCreateDescriptorSecret(
      {required Network network,
      required String mnemonic,
      String? password,
      dynamic hint});

  Future<String> apiCreateEsploraBlockchainWithApi(
      {required EsploraConfig config, dynamic hint});

  Future<String> apiCreateTransaction({required List<int> tx, dynamic hint});

  Future<String> apiCreateWallet(
      {required String descriptor,
      String? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint});

  Future<String> apiDeriveDescriptorSecret(
      {required String secret, required String path, dynamic hint});

  Future<String> apiDescriptorAsString(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiDescriptorAsStringPrivate(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiDescriptorPublicFromString(
      {required String publicKey, dynamic hint});

  Future<String> apiDescriptorSecretAsPublic(
      {required String secret, dynamic hint});

  Future<Uint8List> apiDescriptorSecretAsSecretBytes(
      {required String secret, dynamic hint});

  Future<String> apiDescriptorSecretFromString(
      {required String secret, dynamic hint});

  Future<double> apiEstimateFee(
      {required int target, required String blockchainId, dynamic hint});

  Future<String> apiExtendDescriptorSecret(
      {required String secret, required String path, dynamic hint});

  Future<String> apiExtractTx({required String psbtStr, dynamic hint});

  Future<String> apiGenerateSeedFromEntropy(
      {required List<int> entropy, dynamic hint});

  Future<String> apiGenerateSeedFromString(
      {required String mnemonic, dynamic hint});

  Future<String> apiGenerateSeedFromWordCount(
      {required WordCount wordCount, dynamic hint});

  Future<AddressInfo> apiGetAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint});

  Future<Balance> apiGetBalance({required String walletId, dynamic hint});

  Future<String> apiGetBlockchainHash(
      {required int blockchainHeight,
      required String blockchainId,
      dynamic hint});

  Future<(String, Network)> apiGetDescriptorForKeychain(
      {required String walletId, required KeychainKind keychain, dynamic hint});

  Future<int> apiGetHeight({required String blockchainId, dynamic hint});

  Future<AddressInfo> apiGetInternalAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint});

  Future<String> apiGetPsbtInput(
      {required String walletId,
      required LocalUtxo utxo,
      required bool onlyWitnessUtxo,
      PsbtSigHashType? psbtSighashType,
      dynamic hint});

  Future<List<TransactionDetails>> apiGetTransactions(
      {required String walletId, required bool includeRaw, dynamic hint});

  Future<List<TxIn>> apiInput({required String tx, dynamic hint});

  Future<bool> apiIsCoinBase({required String tx, dynamic hint});

  Future<bool> apiIsExplicitlyRbf({required String tx, dynamic hint});

  Future<bool> apiIsLockTimeEnabled({required String tx, dynamic hint});

  Future<bool> apiIsMine(
      {required Script script, required String walletId, dynamic hint});

  Future<String> apiJsonSerialize({required String psbtStr, dynamic hint});

  Future<List<LocalUtxo>> apiListUnspent(
      {required String walletId, dynamic hint});

  Future<List<LocalUtxo>> apiListUnspentOutputs(
      {required String walletId, dynamic hint});

  Future<int> apiLockTime({required String tx, dynamic hint});

  Future<int> apiMaxSatisfactionWeight(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiNewBip44Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint});

  Future<String> apiNewBip44Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint});

  Future<String> apiNewBip49Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint});

  Future<String> apiNewBip49Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint});

  Future<String> apiNewBip84Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint});

  Future<String> apiNewBip84Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint});

  Future<List<TxOut>> apiOutput({required String tx, dynamic hint});

  Future<int?> apiPsbtFeeAmount({required String psbtStr, dynamic hint});

  Future<double?> apiPsbtFeeRate({required String psbtStr, dynamic hint});

  Future<String> apiPsbtTxid({required String psbtStr, dynamic hint});

  Future<String> apiSerializePsbt({required String psbtStr, dynamic hint});

  Future<String?> apiSign(
      {required String walletId,
      required String psbtStr,
      SignOptions? signOptions,
      dynamic hint});

  Future<int> apiSize({required String tx, dynamic hint});

  Future<void> apiSyncWallet(
      {required String walletId, required String blockchainId, dynamic hint});

  Future<(String, TransactionDetails)> apiTxBuilderFinish(
      {required String walletId,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      (OutPoint, String, int)? foreignUtxo,
      required List<OutPoint> unspendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      dynamic hint});

  Future<String> apiTxTxid({required String tx, dynamic hint});

  Future<int> apiVersion({required String tx, dynamic hint});

  Future<int> apiVsize({required String tx, dynamic hint});

  Future<Network> apiWalletNetwork({required String walletId, dynamic hint});

  Future<int> apiWeight({required String tx, dynamic hint});

  Future<MyTestObject> myTestObjectNew({dynamic hint});

  Future<String> myTestObjectReadText(
      {required MyTestObject that, dynamic hint});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AddressBalance;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AddressBalance;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AddressBalancePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AddressClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AddressClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AddressClientPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ApiTx;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ApiTx;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ApiTxPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcProtonApiService;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcProtonApiService;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcProtonApiServicePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkWalletManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkWalletManager;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BdkWalletManagerPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BitcoinAddressClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BitcoinAddressClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BitcoinAddressClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ContactsClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ContactsClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ContactsClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EmailIntegrationClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EmailIntegrationClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_EmailIntegrationClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventClient;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EventClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExchangeRateClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExchangeRateClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExchangeRateClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OnRampGatewayClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OnRampGatewayClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_OnRampGatewayClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonApiService;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonApiService;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProtonApiServicePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonEmailAddressClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonEmailAddressClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProtonEmailAddressClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonUsersClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonUsersClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProtonUsersClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonWalletAuthStore;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonWalletAuthStore;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProtonWalletAuthStorePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SettingsClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SettingsClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SettingsClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_TransactionClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_TransactionClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_TransactionClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WalletClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WalletClient;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WalletClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkTransaction;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkTransaction;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BdkTransactionPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<int> addOne({required int left, required int right, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(left, serializer);
        sse_encode_usize(right, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kAddOneConstMeta,
      argValues: [left, right],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddOneConstMeta => const TaskConstMeta(
        debugName: "add_one",
        argNames: ["left", "right"],
      );

  @override
  Future<int> addThree({required int left, required int right, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(left, serializer);
        sse_encode_usize(right, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kAddThreeConstMeta,
      argValues: [left, right],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddThreeConstMeta => const TaskConstMeta(
        debugName: "add_three",
        argNames: ["left", "right"],
      );

  @override
  String greet({required String name, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kGreetConstMeta,
      argValues: [name],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  String helloworld({dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kHelloworldConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kHelloworldConstMeta => const TaskConstMeta(
        debugName: "helloworld",
        argNames: [],
      );

  @override
  Future<void> initApp({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kInitAppConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<AddressBalance> addressClientGetAddressBalance(
      {required AddressClient that, required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
            that, serializer);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kAddressClientGetAddressBalanceConstMeta,
      argValues: [that, address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddressClientGetAddressBalanceConstMeta =>
      const TaskConstMeta(
        debugName: "AddressClient_get_address_balance",
        argNames: ["that", "address"],
      );

  @override
  Future<List<ApiTx>> addressClientGetScripthashTransactions(
      {required AddressClient that, required String scriptHash, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
            that, serializer);
        sse_encode_String(scriptHash, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kAddressClientGetScripthashTransactionsConstMeta,
      argValues: [that, scriptHash],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddressClientGetScripthashTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "AddressClient_get_scripthash_transactions",
        argNames: ["that", "scriptHash"],
      );

  @override
  Future<List<ApiTx>> addressClientGetScripthashTransactionsAtTransactionId(
      {required AddressClient that,
      required String scriptHash,
      required String transactionId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
            that, serializer);
        sse_encode_String(scriptHash, serializer);
        sse_encode_String(transactionId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta:
          kAddressClientGetScripthashTransactionsAtTransactionIdConstMeta,
      argValues: [that, scriptHash, transactionId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta
      get kAddressClientGetScripthashTransactionsAtTransactionIdConstMeta =>
          const TaskConstMeta(
            debugName:
                "AddressClient_get_scripthash_transactions_at_transaction_id",
            argNames: ["that", "scriptHash", "transactionId"],
          );

  @override
  Future<AddressClient> addressClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient,
        decodeErrorData: null,
      ),
      constMeta: kAddressClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddressClientNewConstMeta => const TaskConstMeta(
        debugName: "AddressClient_new",
        argNames: ["service"],
      );

  @override
  Future<List<ApiWalletBitcoinAddress>> bitcoinAddressClientAddBitcoinAddresses(
      {required BitcoinAddressClient that,
      required String walletId,
      required String walletAccountId,
      required List<BitcoinAddress> bitcoinAddresses,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_list_bitcoin_address(bitcoinAddresses, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kBitcoinAddressClientAddBitcoinAddressesConstMeta,
      argValues: [that, walletId, walletAccountId, bitcoinAddresses],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBitcoinAddressClientAddBitcoinAddressesConstMeta =>
      const TaskConstMeta(
        debugName: "BitcoinAddressClient_add_bitcoin_addresses",
        argNames: ["that", "walletId", "walletAccountId", "bitcoinAddresses"],
      );

  @override
  Future<int> bitcoinAddressClientGetBitcoinAddressLatestIndex(
      {required BitcoinAddressClient that,
      required String walletId,
      required String walletAccountId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kBitcoinAddressClientGetBitcoinAddressLatestIndexConstMeta,
      argValues: [that, walletId, walletAccountId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta
      get kBitcoinAddressClientGetBitcoinAddressLatestIndexConstMeta =>
          const TaskConstMeta(
            debugName: "BitcoinAddressClient_get_bitcoin_address_latest_index",
            argNames: ["that", "walletId", "walletAccountId"],
          );

  @override
  Future<List<ApiWalletBitcoinAddress>>
      bitcoinAddressClientGetWalletBitcoinAddress(
          {required BitcoinAddressClient that,
          required String walletId,
          required String walletAccountId,
          int? onlyRequest,
          dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_opt_box_autoadd_u_8(onlyRequest, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kBitcoinAddressClientGetWalletBitcoinAddressConstMeta,
      argValues: [that, walletId, walletAccountId, onlyRequest],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBitcoinAddressClientGetWalletBitcoinAddressConstMeta =>
      const TaskConstMeta(
        debugName: "BitcoinAddressClient_get_wallet_bitcoin_address",
        argNames: ["that", "walletId", "walletAccountId", "onlyRequest"],
      );

  @override
  Future<BitcoinAddressClient> bitcoinAddressClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient,
        decodeErrorData: null,
      ),
      constMeta: kBitcoinAddressClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBitcoinAddressClientNewConstMeta => const TaskConstMeta(
        debugName: "BitcoinAddressClient_new",
        argNames: ["service"],
      );

  @override
  Future<ApiWalletBitcoinAddress> bitcoinAddressClientUpdateBitcoinAddress(
      {required BitcoinAddressClient that,
      required String walletId,
      required String walletAccountId,
      required String walletAccountBitcoinAddressId,
      required BitcoinAddress bitcoinAddress,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(walletAccountBitcoinAddressId, serializer);
        sse_encode_box_autoadd_bitcoin_address(bitcoinAddress, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kBitcoinAddressClientUpdateBitcoinAddressConstMeta,
      argValues: [
        that,
        walletId,
        walletAccountId,
        walletAccountBitcoinAddressId,
        bitcoinAddress
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBitcoinAddressClientUpdateBitcoinAddressConstMeta =>
      const TaskConstMeta(
        debugName: "BitcoinAddressClient_update_bitcoin_address",
        argNames: [
          "that",
          "walletId",
          "walletAccountId",
          "walletAccountBitcoinAddressId",
          "bitcoinAddress"
        ],
      );

  @override
  Future<EmailIntegrationBitcoinAddress>
      emailIntegrationClientLookupBitcoinAddress(
          {required EmailIntegrationClient that,
          required String email,
          dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
            that, serializer);
        sse_encode_String(email, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_email_integration_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kEmailIntegrationClientLookupBitcoinAddressConstMeta,
      argValues: [that, email],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kEmailIntegrationClientLookupBitcoinAddressConstMeta =>
      const TaskConstMeta(
        debugName: "EmailIntegrationClient_lookup_bitcoin_address",
        argNames: ["that", "email"],
      );

  @override
  Future<EmailIntegrationClient> emailIntegrationClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient,
        decodeErrorData: null,
      ),
      constMeta: kEmailIntegrationClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kEmailIntegrationClientNewConstMeta => const TaskConstMeta(
        debugName: "EmailIntegrationClient_new",
        argNames: ["service"],
      );

  @override
  Future<List<ProtonEvent>> eventClientCollectEvents(
      {required EventClient that,
      required String latestEventId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
            that, serializer);
        sse_encode_String(latestEventId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_proton_event,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kEventClientCollectEventsConstMeta,
      argValues: [that, latestEventId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kEventClientCollectEventsConstMeta => const TaskConstMeta(
        debugName: "EventClient_collect_events",
        argNames: ["that", "latestEventId"],
      );

  @override
  Future<String> eventClientGetLatestEventId(
      {required EventClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kEventClientGetLatestEventIdConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kEventClientGetLatestEventIdConstMeta =>
      const TaskConstMeta(
        debugName: "EventClient_get_latest_event_id",
        argNames: ["that"],
      );

  @override
  Future<bool> eventClientIsValidToken(
      {required EventClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kEventClientIsValidTokenConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kEventClientIsValidTokenConstMeta => const TaskConstMeta(
        debugName: "EventClient_is_valid_token",
        argNames: ["that"],
      );

  @override
  Future<EventClient> eventClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient,
        decodeErrorData: null,
      ),
      constMeta: kEventClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kEventClientNewConstMeta => const TaskConstMeta(
        debugName: "EventClient_new",
        argNames: ["service"],
      );

  @override
  Future<ProtonExchangeRate> exchangeRateClientGetExchangeRate(
      {required ExchangeRateClient that,
      required FiatCurrency fiatCurrency,
      int? time,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
            that, serializer);
        sse_encode_fiat_currency(fiatCurrency, serializer);
        sse_encode_opt_box_autoadd_u_64(time, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_proton_exchange_rate,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kExchangeRateClientGetExchangeRateConstMeta,
      argValues: [that, fiatCurrency, time],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kExchangeRateClientGetExchangeRateConstMeta =>
      const TaskConstMeta(
        debugName: "ExchangeRateClient_get_exchange_rate",
        argNames: ["that", "fiatCurrency", "time"],
      );

  @override
  Future<ExchangeRateClient> exchangeRateClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient,
        decodeErrorData: null,
      ),
      constMeta: kExchangeRateClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kExchangeRateClientNewConstMeta => const TaskConstMeta(
        debugName: "ExchangeRateClient_new",
        argNames: ["service"],
      );

  @override
  Future<String> onRampGatewayClientCreateOnRampCheckout(
      {required OnRampGatewayClient that,
      required String amount,
      required String btcAddress,
      required FiatCurrency fiatCurrency,
      required PaymentMethod payMethod,
      required GatewayProvider provider,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
            that, serializer);
        sse_encode_String(amount, serializer);
        sse_encode_String(btcAddress, serializer);
        sse_encode_fiat_currency(fiatCurrency, serializer);
        sse_encode_payment_method(payMethod, serializer);
        sse_encode_gateway_provider(provider, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kOnRampGatewayClientCreateOnRampCheckoutConstMeta,
      argValues: [that, amount, btcAddress, fiatCurrency, payMethod, provider],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kOnRampGatewayClientCreateOnRampCheckoutConstMeta =>
      const TaskConstMeta(
        debugName: "OnRampGatewayClient_create_on_ramp_checkout",
        argNames: [
          "that",
          "amount",
          "btcAddress",
          "fiatCurrency",
          "payMethod",
          "provider"
        ],
      );

  @override
  Future<Map<GatewayProvider, List<ApiCountry>>>
      onRampGatewayClientGetCountries(
          {required OnRampGatewayClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_gateway_provider_list_api_country,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kOnRampGatewayClientGetCountriesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kOnRampGatewayClientGetCountriesConstMeta =>
      const TaskConstMeta(
        debugName: "OnRampGatewayClient_get_countries",
        argNames: ["that"],
      );

  @override
  Future<Map<GatewayProvider, List<ApiCountryFiatCurrency>>>
      onRampGatewayClientGetFiatCurrencies(
          {required OnRampGatewayClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Map_gateway_provider_list_api_country_fiat_currency,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kOnRampGatewayClientGetFiatCurrenciesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kOnRampGatewayClientGetFiatCurrenciesConstMeta =>
      const TaskConstMeta(
        debugName: "OnRampGatewayClient_get_fiat_currencies",
        argNames: ["that"],
      );

  @override
  Future<Map<GatewayProvider, List<PaymentMethod>>>
      onRampGatewayClientGetPaymentMethods(
          {required OnRampGatewayClient that,
          required FiatCurrency fiatSymbol,
          dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
            that, serializer);
        sse_encode_fiat_currency(fiatSymbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_gateway_provider_list_payment_method,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kOnRampGatewayClientGetPaymentMethodsConstMeta,
      argValues: [that, fiatSymbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kOnRampGatewayClientGetPaymentMethodsConstMeta =>
      const TaskConstMeta(
        debugName: "OnRampGatewayClient_get_payment_methods",
        argNames: ["that", "fiatSymbol"],
      );

  @override
  Future<Map<GatewayProvider, List<Quote>>> onRampGatewayClientGetQuotes(
      {required OnRampGatewayClient that,
      required String amount,
      required FiatCurrency fiatCurrency,
      PaymentMethod? payMethod,
      GatewayProvider? provider,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
            that, serializer);
        sse_encode_String(amount, serializer);
        sse_encode_fiat_currency(fiatCurrency, serializer);
        sse_encode_opt_box_autoadd_payment_method(payMethod, serializer);
        sse_encode_opt_box_autoadd_gateway_provider(provider, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_gateway_provider_list_quote,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kOnRampGatewayClientGetQuotesConstMeta,
      argValues: [that, amount, fiatCurrency, payMethod, provider],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kOnRampGatewayClientGetQuotesConstMeta =>
      const TaskConstMeta(
        debugName: "OnRampGatewayClient_get_quotes",
        argNames: ["that", "amount", "fiatCurrency", "payMethod", "provider"],
      );

  @override
  Future<OnRampGatewayClient> onRampGatewayClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient,
        decodeErrorData: null,
      ),
      constMeta: kOnRampGatewayClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kOnRampGatewayClientNewConstMeta => const TaskConstMeta(
        debugName: "OnRampGatewayClient_new",
        argNames: ["service"],
      );

  @override
  AddressClient protonApiServiceGetAddressClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetAddressClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetAddressClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_address_client",
        argNames: ["that"],
      );

  @override
  BitcoinAddressClient protonApiServiceGetBitcoinAddrClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetBitcoinAddrClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetBitcoinAddrClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_bitcoin_addr_client",
        argNames: ["that"],
      );

  @override
  EmailIntegrationClient protonApiServiceGetEmailIntegrationClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetEmailIntegrationClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetEmailIntegrationClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_email_integration_client",
        argNames: ["that"],
      );

  @override
  EventClient protonApiServiceGetEventClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetEventClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetEventClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_event_client",
        argNames: ["that"],
      );

  @override
  ExchangeRateClient protonApiServiceGetExchangeRateClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetExchangeRateClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetExchangeRateClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_exchange_rate_client",
        argNames: ["that"],
      );

  @override
  OnRampGatewayClient protonApiServiceGetOnRampGatewayClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetOnRampGatewayClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetOnRampGatewayClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_on_ramp_gateway_client",
        argNames: ["that"],
      );

  @override
  ContactsClient protonApiServiceGetProtonContactsClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetProtonContactsClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetProtonContactsClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_proton_contacts_client",
        argNames: ["that"],
      );

  @override
  ProtonEmailAddressClient protonApiServiceGetProtonEmailAddrClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetProtonEmailAddrClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetProtonEmailAddrClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_proton_email_addr_client",
        argNames: ["that"],
      );

  @override
  SettingsClient protonApiServiceGetSettingsClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetSettingsClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetSettingsClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_settings_client",
        argNames: ["that"],
      );

  @override
  TransactionClient protonApiServiceGetTransactionClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetTransactionClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetTransactionClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_transaction_client",
        argNames: ["that"],
      );

  @override
  WalletClient protonApiServiceGetWalletClient(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceGetWalletClientConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetWalletClientConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_get_wallet_client",
        argNames: ["that"],
      );

  @override
  Future<List<ApiWalletData>> protonApiServiceGetWallets(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_data,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonApiServiceGetWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetWalletsConstMeta => const TaskConstMeta(
        debugName: "ProtonApiService_get_wallets",
        argNames: ["that"],
      );

  @override
  Future<AuthCredential> protonApiServiceLogin(
      {required ProtonApiService that,
      required String username,
      required String password,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_auth_credential,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonApiServiceLoginConstMeta,
      argValues: [that, username, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceLoginConstMeta => const TaskConstMeta(
        debugName: "ProtonApiService_login",
        argNames: ["that", "username", "password"],
      );

  @override
  Future<void> protonApiServiceLogout(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceLogoutConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceLogoutConstMeta => const TaskConstMeta(
        debugName: "ProtonApiService_logout",
        argNames: ["that"],
      );

  @override
  ProtonApiService protonApiServiceNew(
      {required String env,
      required String appVersion,
      required String userAgent,
      required ProtonWalletAuthStore store,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(env, serializer);
        sse_encode_String(appVersion, serializer);
        sse_encode_String(userAgent, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
            store, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonApiServiceNewConstMeta,
      argValues: [env, appVersion, userAgent, store],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceNewConstMeta => const TaskConstMeta(
        debugName: "ProtonApiService_new",
        argNames: ["env", "appVersion", "userAgent", "store"],
      );

  @override
  Future<void> protonApiServiceSetProtonApi(
      {required ProtonApiService that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceSetProtonApiConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceSetProtonApiConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonApiService_set_proton_api",
        argNames: ["that"],
      );

  @override
  Future<void> protonApiServiceUpdateAuth(
      {required ProtonApiService that,
      required String uid,
      required String access,
      required String refresh,
      required List<String> scopes,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            that, serializer);
        sse_encode_String(uid, serializer);
        sse_encode_String(access, serializer);
        sse_encode_String(refresh, serializer);
        sse_encode_list_String(scopes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceUpdateAuthConstMeta,
      argValues: [that, uid, access, refresh, scopes],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceUpdateAuthConstMeta => const TaskConstMeta(
        debugName: "ProtonApiService_update_auth",
        argNames: ["that", "uid", "access", "refresh", "scopes"],
      );

  @override
  Future<List<ApiContactEmails>> contactsClientGetContacts(
      {required ContactsClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_contact_emails,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kContactsClientGetContactsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kContactsClientGetContactsConstMeta => const TaskConstMeta(
        debugName: "ContactsClient_get_contacts",
        argNames: ["that"],
      );

  @override
  Future<ContactsClient> contactsClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient,
        decodeErrorData: null,
      ),
      constMeta: kContactsClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kContactsClientNewConstMeta => const TaskConstMeta(
        debugName: "ContactsClient_new",
        argNames: ["service"],
      );

  @override
  Future<List<AllKeyAddressKey>> protonEmailAddressClientGetAllPublicKeys(
      {required ProtonEmailAddressClient that,
      required String email,
      required int internalOnly,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
            that, serializer);
        sse_encode_String(email, serializer);
        sse_encode_u_8(internalOnly, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_all_key_address_key,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonEmailAddressClientGetAllPublicKeysConstMeta,
      argValues: [that, email, internalOnly],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonEmailAddressClientGetAllPublicKeysConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonEmailAddressClient_get_all_public_keys",
        argNames: ["that", "email", "internalOnly"],
      );

  @override
  Future<List<ProtonAddress>> protonEmailAddressClientGetProtonAddress(
      {required ProtonEmailAddressClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_proton_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonEmailAddressClientGetProtonAddressConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonEmailAddressClientGetProtonAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonEmailAddressClient_get_proton_address",
        argNames: ["that"],
      );

  @override
  Future<ProtonEmailAddressClient> protonEmailAddressClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonEmailAddressClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonEmailAddressClientNewConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonEmailAddressClient_new",
        argNames: ["service"],
      );

  @override
  Future<ProtonUsersClient> protonUsersClientNew(
      {required ArcProtonApiService client, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient,
        decodeErrorData: null,
      ),
      constMeta: kProtonUsersClientNewConstMeta,
      argValues: [client],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonUsersClientNewConstMeta => const TaskConstMeta(
        debugName: "ProtonUsersClient_new",
        argNames: ["client"],
      );

  @override
  Future<ApiWalletUserSettings> settingsClientBitcoinUnit(
      {required SettingsClient that,
      required BitcoinUnit symbol,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
            that, serializer);
        sse_encode_bitcoin_unit(symbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kSettingsClientBitcoinUnitConstMeta,
      argValues: [that, symbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSettingsClientBitcoinUnitConstMeta => const TaskConstMeta(
        debugName: "SettingsClient_bitcoin_unit",
        argNames: ["that", "symbol"],
      );

  @override
  Future<ApiWalletUserSettings> settingsClientFiatCurrency(
      {required SettingsClient that,
      required FiatCurrency symbol,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
            that, serializer);
        sse_encode_fiat_currency(symbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kSettingsClientFiatCurrencyConstMeta,
      argValues: [that, symbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSettingsClientFiatCurrencyConstMeta => const TaskConstMeta(
        debugName: "SettingsClient_fiat_currency",
        argNames: ["that", "symbol"],
      );

  @override
  Future<ApiWalletUserSettings> settingsClientGetUserSettings(
      {required SettingsClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kSettingsClientGetUserSettingsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSettingsClientGetUserSettingsConstMeta =>
      const TaskConstMeta(
        debugName: "SettingsClient_get_user_settings",
        argNames: ["that"],
      );

  @override
  Future<ApiWalletUserSettings> settingsClientHideEmptyUsedAddresses(
      {required SettingsClient that,
      required bool hideEmptyUsedAddresses,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
            that, serializer);
        sse_encode_bool(hideEmptyUsedAddresses, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kSettingsClientHideEmptyUsedAddressesConstMeta,
      argValues: [that, hideEmptyUsedAddresses],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSettingsClientHideEmptyUsedAddressesConstMeta =>
      const TaskConstMeta(
        debugName: "SettingsClient_hide_empty_used_addresses",
        argNames: ["that", "hideEmptyUsedAddresses"],
      );

  @override
  Future<SettingsClient> settingsClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient,
        decodeErrorData: null,
      ),
      constMeta: kSettingsClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSettingsClientNewConstMeta => const TaskConstMeta(
        debugName: "SettingsClient_new",
        argNames: ["service"],
      );

  @override
  Future<ApiWalletUserSettings> settingsClientTwoFaThreshold(
      {required SettingsClient that, required int amount, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
            that, serializer);
        sse_encode_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kSettingsClientTwoFaThresholdConstMeta,
      argValues: [that, amount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSettingsClientTwoFaThresholdConstMeta =>
      const TaskConstMeta(
        debugName: "SettingsClient_two_fa_threshold",
        argNames: ["that", "amount"],
      );

  @override
  Future<String> transactionClientBroadcastRawTransaction(
      {required TransactionClient that,
      required String signedTransactionHex,
      required String walletId,
      required String walletAccountId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      String? addressId,
      String? subject,
      String? body,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
            that, serializer);
        sse_encode_String(signedTransactionHex, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_opt_String(label, serializer);
        sse_encode_opt_String(exchangeRateId, serializer);
        sse_encode_opt_String(transactionTime, serializer);
        sse_encode_opt_String(addressId, serializer);
        sse_encode_opt_String(subject, serializer);
        sse_encode_opt_String(body, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kTransactionClientBroadcastRawTransactionConstMeta,
      argValues: [
        that,
        signedTransactionHex,
        walletId,
        walletAccountId,
        label,
        exchangeRateId,
        transactionTime,
        addressId,
        subject,
        body
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTransactionClientBroadcastRawTransactionConstMeta =>
      const TaskConstMeta(
        debugName: "TransactionClient_broadcast_raw_transaction",
        argNames: [
          "that",
          "signedTransactionHex",
          "walletId",
          "walletAccountId",
          "label",
          "exchangeRateId",
          "transactionTime",
          "addressId",
          "subject",
          "body"
        ],
      );

  @override
  Future<BdkTransaction> transactionClientGetRawTransaction(
      {required TransactionClient that, required String txid, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
            that, serializer);
        sse_encode_String(txid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kTransactionClientGetRawTransactionConstMeta,
      argValues: [that, txid],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTransactionClientGetRawTransactionConstMeta =>
      const TaskConstMeta(
        debugName: "TransactionClient_get_raw_transaction",
        argNames: ["that", "txid"],
      );

  @override
  Future<TransactionClient> transactionClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient,
        decodeErrorData: null,
      ),
      constMeta: kTransactionClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTransactionClientNewConstMeta => const TaskConstMeta(
        debugName: "TransactionClient_new",
        argNames: ["service"],
      );

  @override
  Future<void> protonWalletAuthStoreClearAuthDartCallback(
      {required ProtonWalletAuthStore that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonWalletAuthStoreClearAuthDartCallbackConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonWalletAuthStoreClearAuthDartCallbackConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonWalletAuthStore_clear_auth_dart_callback",
        argNames: ["that"],
      );

  @override
  ProtonWalletAuthStore protonWalletAuthStoreFromSession(
      {required String env,
      required String uid,
      required String access,
      required String refresh,
      required List<String> scopes,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(env, serializer);
        sse_encode_String(uid, serializer);
        sse_encode_String(access, serializer);
        sse_encode_String(refresh, serializer);
        sse_encode_list_String(scopes, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonWalletAuthStoreFromSessionConstMeta,
      argValues: [env, uid, access, refresh, scopes],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonWalletAuthStoreFromSessionConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonWalletAuthStore_from_session",
        argNames: ["env", "uid", "access", "refresh", "scopes"],
      );

  @override
  Future<void> protonWalletAuthStoreLogout(
      {required ProtonWalletAuthStore that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kProtonWalletAuthStoreLogoutConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonWalletAuthStoreLogoutConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonWalletAuthStore_logout",
        argNames: ["that"],
      );

  @override
  ProtonWalletAuthStore protonWalletAuthStoreNew(
      {required String env, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(env, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonWalletAuthStoreNewConstMeta,
      argValues: [env],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonWalletAuthStoreNewConstMeta => const TaskConstMeta(
        debugName: "ProtonWalletAuthStore_new",
        argNames: ["env"],
      );

  @override
  Future<void> protonWalletAuthStoreSetAuthDartCallback(
      {required ProtonWalletAuthStore that,
      required FutureOr<String> Function(ChildSession) callback,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
            that, serializer);
        sse_encode_DartFn_Inputs_child_session_Output_String(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonWalletAuthStoreSetAuthDartCallbackConstMeta,
      argValues: [that, callback],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonWalletAuthStoreSetAuthDartCallbackConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonWalletAuthStore_set_auth_dart_callback",
        argNames: ["that", "callback"],
      );

  @override
  void protonWalletAuthStoreSetAuthSync(
      {required ProtonWalletAuthStore that,
      required String uid,
      required String access,
      required String refresh,
      required List<String> scopes,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
            that, serializer);
        sse_encode_String(uid, serializer);
        sse_encode_String(access, serializer);
        sse_encode_String(refresh, serializer);
        sse_encode_list_String(scopes, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kProtonWalletAuthStoreSetAuthSyncConstMeta,
      argValues: [that, uid, access, refresh, scopes],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonWalletAuthStoreSetAuthSyncConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonWalletAuthStore_set_auth_sync",
        argNames: ["that", "uid", "access", "refresh", "scopes"],
      );

  @override
  Future<ApiWalletAccount> walletClientAddEmailAddress(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(addressId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientAddEmailAddressConstMeta,
      argValues: [that, walletId, walletAccountId, addressId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientAddEmailAddressConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_add_email_address",
        argNames: ["that", "walletId", "walletAccountId", "addressId"],
      );

  @override
  Future<ApiWalletData> walletClientCreateWallet(
      {required WalletClient that,
      required CreateWalletReq walletReq,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_box_autoadd_create_wallet_req(walletReq, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_data,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientCreateWalletConstMeta,
      argValues: [that, walletReq],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientCreateWalletConstMeta => const TaskConstMeta(
        debugName: "WalletClient_create_wallet",
        argNames: ["that", "walletReq"],
      );

  @override
  Future<ApiWalletAccount> walletClientCreateWalletAccount(
      {required WalletClient that,
      required String walletId,
      required CreateWalletAccountReq req,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_create_wallet_account_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientCreateWalletAccountConstMeta,
      argValues: [that, walletId, req],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientCreateWalletAccountConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_create_wallet_account",
        argNames: ["that", "walletId", "req"],
      );

  @override
  Future<WalletTransaction> walletClientCreateWalletTransactions(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String transactionId,
      required String hashedTransactionId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(transactionId, serializer);
        sse_encode_String(hashedTransactionId, serializer);
        sse_encode_opt_String(label, serializer);
        sse_encode_opt_String(exchangeRateId, serializer);
        sse_encode_opt_String(transactionTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 79, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_transaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientCreateWalletTransactionsConstMeta,
      argValues: [
        that,
        walletId,
        walletAccountId,
        transactionId,
        hashedTransactionId,
        label,
        exchangeRateId,
        transactionTime
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientCreateWalletTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_create_wallet_transactions",
        argNames: [
          "that",
          "walletId",
          "walletAccountId",
          "transactionId",
          "hashedTransactionId",
          "label",
          "exchangeRateId",
          "transactionTime"
        ],
      );

  @override
  Future<void> walletClientDeleteWallet(
      {required WalletClient that, required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientDeleteWalletConstMeta,
      argValues: [that, walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientDeleteWalletConstMeta => const TaskConstMeta(
        debugName: "WalletClient_delete_wallet",
        argNames: ["that", "walletId"],
      );

  @override
  Future<void> walletClientDeleteWalletAccount(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientDeleteWalletAccountConstMeta,
      argValues: [that, walletId, walletAccountId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientDeleteWalletAccountConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_delete_wallet_account",
        argNames: ["that", "walletId", "walletAccountId"],
      );

  @override
  Future<void> walletClientDeleteWalletTransactions(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(walletTransactionId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientDeleteWalletTransactionsConstMeta,
      argValues: [that, walletId, walletAccountId, walletTransactionId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientDeleteWalletTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_delete_wallet_transactions",
        argNames: [
          "that",
          "walletId",
          "walletAccountId",
          "walletTransactionId"
        ],
      );

  @override
  Future<List<ApiWalletAccount>> walletClientGetWalletAccounts(
      {required WalletClient that, required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientGetWalletAccountsConstMeta,
      argValues: [that, walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientGetWalletAccountsConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_get_wallet_accounts",
        argNames: ["that", "walletId"],
      );

  @override
  Future<List<WalletTransaction>> walletClientGetWalletTransactions(
      {required WalletClient that,
      required String walletId,
      String? walletAccountId,
      List<String>? hashedTxids,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_opt_String(walletAccountId, serializer);
        sse_encode_opt_list_String(hashedTxids, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wallet_transaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientGetWalletTransactionsConstMeta,
      argValues: [that, walletId, walletAccountId, hashedTxids],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientGetWalletTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_get_wallet_transactions",
        argNames: ["that", "walletId", "walletAccountId", "hashedTxids"],
      );

  @override
  Future<List<ApiWalletData>> walletClientGetWallets(
      {required WalletClient that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_data,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientGetWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientGetWalletsConstMeta => const TaskConstMeta(
        debugName: "WalletClient_get_wallets",
        argNames: ["that"],
      );

  @override
  Future<WalletClient> walletClientNew(
      {required ProtonApiService service, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
            service, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient,
        decodeErrorData: null,
      ),
      constMeta: kWalletClientNewConstMeta,
      argValues: [service],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientNewConstMeta => const TaskConstMeta(
        debugName: "WalletClient_new",
        argNames: ["service"],
      );

  @override
  Future<ApiWalletAccount> walletClientRemoveEmailAddress(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(addressId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientRemoveEmailAddressConstMeta,
      argValues: [that, walletId, walletAccountId, addressId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientRemoveEmailAddressConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_remove_email_address",
        argNames: ["that", "walletId", "walletAccountId", "addressId"],
      );

  @override
  Future<ApiWalletAccount> walletClientUpdateWalletAccountLabel(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String newLabel,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(newLabel, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 74, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientUpdateWalletAccountLabelConstMeta,
      argValues: [that, walletId, walletAccountId, newLabel],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientUpdateWalletAccountLabelConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_update_wallet_account_label",
        argNames: ["that", "walletId", "walletAccountId", "newLabel"],
      );

  @override
  Future<ApiWallet> walletClientUpdateWalletName(
      {required WalletClient that,
      required String walletId,
      required String newName,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(newName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientUpdateWalletNameConstMeta,
      argValues: [that, walletId, newName],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientUpdateWalletNameConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_update_wallet_name",
        argNames: ["that", "walletId", "newName"],
      );

  @override
  Future<WalletTransaction> walletClientUpdateWalletTransactionLabel(
      {required WalletClient that,
      required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      required String label,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
            that, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(walletTransactionId, serializer);
        sse_encode_String(label, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_transaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kWalletClientUpdateWalletTransactionLabelConstMeta,
      argValues: [that, walletId, walletAccountId, walletTransactionId, label],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kWalletClientUpdateWalletTransactionLabelConstMeta =>
      const TaskConstMeta(
        debugName: "WalletClient_update_wallet_transaction_label",
        argNames: [
          "that",
          "walletId",
          "walletAccountId",
          "walletTransactionId",
          "label"
        ],
      );

  @override
  String bdkWalletManagerFingerprint(
      {required BdkWalletManager that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 83)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kBdkWalletManagerFingerprintConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletManagerFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "BdkWalletManager_fingerprint",
        argNames: ["that"],
      );

  @override
  Future<BdkWalletManager> bdkWalletManagerNew(
      {required Network network,
      required String bip39Mnemonic,
      String? bip38Passphrase,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_network(network, serializer);
        sse_encode_String(bip39Mnemonic, serializer);
        sse_encode_opt_String(bip38Passphrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kBdkWalletManagerNewConstMeta,
      argValues: [network, bip39Mnemonic, bip38Passphrase],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBdkWalletManagerNewConstMeta => const TaskConstMeta(
        debugName: "BdkWalletManager_new",
        argNames: ["network", "bip39Mnemonic", "bip38Passphrase"],
      );

  @override
  Stream<LogEntry> infoLogger({dynamic hint}) {
    final sink = RustStreamSink<LogEntry>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_log_entry_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kInfoLoggerConstMeta,
      argValues: [sink],
      apiImpl: this,
      hint: hint,
    )));
    return sink.stream;
  }

  TaskConstMeta get kInfoLoggerConstMeta => const TaskConstMeta(
        debugName: "info_logger",
        argNames: ["sink"],
      );

  @override
  Future<void> panic({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kPanicConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kPanicConstMeta => const TaskConstMeta(
        debugName: "panic",
        argNames: [],
      );

  @override
  Future<void> test({required int i, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(i, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kTestConstMeta,
      argValues: [i],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTestConstMeta => const TaskConstMeta(
        debugName: "test",
        argNames: ["i"],
      );

  @override
  Future<int> addTwo({required int left, required int right, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(left, serializer);
        sse_encode_usize(right, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kAddTwoConstMeta,
      argValues: [left, right],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddTwoConstMeta => const TaskConstMeta(
        debugName: "add_two",
        argNames: ["left", "right"],
      );

  @override
  Future<String> testOne({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kTestOneConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTestOneConstMeta => const TaskConstMeta(
        debugName: "test_one",
        argNames: [],
      );

  @override
  Future<List<ApiWalletBitcoinAddress>> addBitcoinAddresses(
      {required String walletId,
      required String walletAccountId,
      required List<BitcoinAddress> bitcoinAddresses,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_list_bitcoin_address(bitcoinAddresses, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 111, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kAddBitcoinAddressesConstMeta,
      argValues: [walletId, walletAccountId, bitcoinAddresses],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddBitcoinAddressesConstMeta => const TaskConstMeta(
        debugName: "add_bitcoin_addresses",
        argNames: ["walletId", "walletAccountId", "bitcoinAddresses"],
      );

  @override
  Future<ApiWalletAccount> addEmailAddress(
      {required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(addressId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 108, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kAddEmailAddressConstMeta,
      argValues: [walletId, walletAccountId, addressId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddEmailAddressConstMeta => const TaskConstMeta(
        debugName: "add_email_address",
        argNames: ["walletId", "walletAccountId", "addressId"],
      );

  @override
  Future<ApiWalletUserSettings> bitcoinUnit(
      {required BitcoinUnit symbol, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bitcoin_unit(symbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 99, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kBitcoinUnitConstMeta,
      argValues: [symbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBitcoinUnitConstMeta => const TaskConstMeta(
        debugName: "bitcoin_unit",
        argNames: ["symbol"],
      );

  @override
  Future<String> broadcastRawTransaction(
      {required String signedTransactionHex,
      required String walletId,
      required String walletAccountId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      String? addressId,
      String? subject,
      String? body,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(signedTransactionHex, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_opt_String(label, serializer);
        sse_encode_opt_String(exchangeRateId, serializer);
        sse_encode_opt_String(transactionTime, serializer);
        sse_encode_opt_String(addressId, serializer);
        sse_encode_opt_String(subject, serializer);
        sse_encode_opt_String(body, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 119, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kBroadcastRawTransactionConstMeta,
      argValues: [
        signedTransactionHex,
        walletId,
        walletAccountId,
        label,
        exchangeRateId,
        transactionTime,
        addressId,
        subject,
        body
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBroadcastRawTransactionConstMeta => const TaskConstMeta(
        debugName: "broadcast_raw_transaction",
        argNames: [
          "signedTransactionHex",
          "walletId",
          "walletAccountId",
          "label",
          "exchangeRateId",
          "transactionTime",
          "addressId",
          "subject",
          "body"
        ],
      );

  @override
  Future<List<ProtonEvent>> collectEvents(
      {required String latestEventId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(latestEventId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 105, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_proton_event,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kCollectEventsConstMeta,
      argValues: [latestEventId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCollectEventsConstMeta => const TaskConstMeta(
        debugName: "collect_events",
        argNames: ["latestEventId"],
      );

  @override
  Future<ApiWalletData> createWallet(
      {required CreateWalletReq walletReq, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_create_wallet_req(walletReq, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 90, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_data,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kCreateWalletConstMeta,
      argValues: [walletReq],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCreateWalletConstMeta => const TaskConstMeta(
        debugName: "create_wallet",
        argNames: ["walletReq"],
      );

  @override
  Future<ApiWalletAccount> createWalletAccount(
      {required String walletId,
      required CreateWalletAccountReq req,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_create_wallet_account_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 94, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kCreateWalletAccountConstMeta,
      argValues: [walletId, req],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCreateWalletAccountConstMeta => const TaskConstMeta(
        debugName: "create_wallet_account",
        argNames: ["walletId", "req"],
      );

  @override
  Future<WalletTransaction> createWalletTransactions(
      {required String walletId,
      required String walletAccountId,
      required String transactionId,
      required String hashedTransactionId,
      String? label,
      String? exchangeRateId,
      String? transactionTime,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(transactionId, serializer);
        sse_encode_String(hashedTransactionId, serializer);
        sse_encode_opt_String(label, serializer);
        sse_encode_opt_String(exchangeRateId, serializer);
        sse_encode_opt_String(transactionTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 116, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_transaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kCreateWalletTransactionsConstMeta,
      argValues: [
        walletId,
        walletAccountId,
        transactionId,
        hashedTransactionId,
        label,
        exchangeRateId,
        transactionTime
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCreateWalletTransactionsConstMeta => const TaskConstMeta(
        debugName: "create_wallet_transactions",
        argNames: [
          "walletId",
          "walletAccountId",
          "transactionId",
          "hashedTransactionId",
          "label",
          "exchangeRateId",
          "transactionTime"
        ],
      );

  @override
  Future<void> deleteWallet({required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 92, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kDeleteWalletConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDeleteWalletConstMeta => const TaskConstMeta(
        debugName: "delete_wallet",
        argNames: ["walletId"],
      );

  @override
  Future<void> deleteWalletAccount(
      {required String walletId,
      required String walletAccountId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 97, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kDeleteWalletAccountConstMeta,
      argValues: [walletId, walletAccountId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDeleteWalletAccountConstMeta => const TaskConstMeta(
        debugName: "delete_wallet_account",
        argNames: ["walletId", "walletAccountId"],
      );

  @override
  Future<void> deleteWalletTransactions(
      {required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(walletTransactionId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 118, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kDeleteWalletTransactionsConstMeta,
      argValues: [walletId, walletAccountId, walletTransactionId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDeleteWalletTransactionsConstMeta => const TaskConstMeta(
        debugName: "delete_wallet_transactions",
        argNames: ["walletId", "walletAccountId", "walletTransactionId"],
      );

  @override
  Future<ApiWalletUserSettings> fiatCurrency(
      {required FiatCurrency symbol, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_fiat_currency(symbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kFiatCurrencyConstMeta,
      argValues: [symbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kFiatCurrencyConstMeta => const TaskConstMeta(
        debugName: "fiat_currency",
        argNames: ["symbol"],
      );

  @override
  Future<ChildSession> fork({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 122, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_child_session,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kForkConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kForkConstMeta => const TaskConstMeta(
        debugName: "fork",
        argNames: [],
      );

  @override
  Future<List<AllKeyAddressKey>> getAllPublicKeys(
      {required String email, required int internalOnly, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(email, serializer);
        sse_encode_u_8(internalOnly, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 120, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_all_key_address_key,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetAllPublicKeysConstMeta,
      argValues: [email, internalOnly],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetAllPublicKeysConstMeta => const TaskConstMeta(
        debugName: "get_all_public_keys",
        argNames: ["email", "internalOnly"],
      );

  @override
  Future<int> getBitcoinAddressLatestIndex(
      {required String walletId,
      required String walletAccountId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 114, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetBitcoinAddressLatestIndexConstMeta,
      argValues: [walletId, walletAccountId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetBitcoinAddressLatestIndexConstMeta =>
      const TaskConstMeta(
        debugName: "get_bitcoin_address_latest_index",
        argNames: ["walletId", "walletAccountId"],
      );

  @override
  Future<List<ApiContactEmails>> getContacts({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 106, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_contact_emails,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetContactsConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetContactsConstMeta => const TaskConstMeta(
        debugName: "get_contacts",
        argNames: [],
      );

  @override
  Future<ProtonExchangeRate> getExchangeRate(
      {required FiatCurrency fiatCurrency, int? time, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_fiat_currency(fiatCurrency, serializer);
        sse_encode_opt_box_autoadd_u_64(time, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 103, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_proton_exchange_rate,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetExchangeRateConstMeta,
      argValues: [fiatCurrency, time],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetExchangeRateConstMeta => const TaskConstMeta(
        debugName: "get_exchange_rate",
        argNames: ["fiatCurrency", "time"],
      );

  @override
  Future<String> getLatestEventId({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 104, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetLatestEventIdConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetLatestEventIdConstMeta => const TaskConstMeta(
        debugName: "get_latest_event_id",
        argNames: [],
      );

  @override
  Future<List<ProtonAddress>> getProtonAddress({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 107, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_proton_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetProtonAddressConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetProtonAddressConstMeta => const TaskConstMeta(
        debugName: "get_proton_address",
        argNames: [],
      );

  @override
  Future<ApiWalletUserSettings> getUserSettings({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 98, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetUserSettingsConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetUserSettingsConstMeta => const TaskConstMeta(
        debugName: "get_user_settings",
        argNames: [],
      );

  @override
  Future<List<ApiWalletAccount>> getWalletAccounts(
      {required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 93, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetWalletAccountsConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetWalletAccountsConstMeta => const TaskConstMeta(
        debugName: "get_wallet_accounts",
        argNames: ["walletId"],
      );

  @override
  Future<List<ApiWalletBitcoinAddress>> getWalletBitcoinAddress(
      {required String walletId,
      required String walletAccountId,
      int? onlyRequest,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_opt_box_autoadd_u_8(onlyRequest, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 113, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetWalletBitcoinAddressConstMeta,
      argValues: [walletId, walletAccountId, onlyRequest],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetWalletBitcoinAddressConstMeta => const TaskConstMeta(
        debugName: "get_wallet_bitcoin_address",
        argNames: ["walletId", "walletAccountId", "onlyRequest"],
      );

  @override
  Future<List<WalletTransaction>> getWalletTransactions(
      {required String walletId,
      String? walletAccountId,
      List<String>? hashedTxids,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_opt_String(walletAccountId, serializer);
        sse_encode_opt_list_String(hashedTxids, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 115, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wallet_transaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetWalletTransactionsConstMeta,
      argValues: [walletId, walletAccountId, hashedTxids],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetWalletTransactionsConstMeta => const TaskConstMeta(
        debugName: "get_wallet_transactions",
        argNames: ["walletId", "walletAccountId", "hashedTxids"],
      );

  @override
  Future<List<ApiWalletData>> getWallets({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 89, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_api_wallet_data,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kGetWalletsConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetWalletsConstMeta => const TaskConstMeta(
        debugName: "get_wallets",
        argNames: [],
      );

  @override
  Future<ApiWalletUserSettings> hideEmptyUsedAddresses(
      {required bool hideEmptyUsedAddresses, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(hideEmptyUsedAddresses, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 102, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kHideEmptyUsedAddressesConstMeta,
      argValues: [hideEmptyUsedAddresses],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kHideEmptyUsedAddressesConstMeta => const TaskConstMeta(
        debugName: "hide_empty_used_addresses",
        argNames: ["hideEmptyUsedAddresses"],
      );

  @override
  Future<bool> isValidToken({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 121, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kIsValidTokenConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kIsValidTokenConstMeta => const TaskConstMeta(
        debugName: "is_valid_token",
        argNames: [],
      );

  @override
  Future<EmailIntegrationBitcoinAddress> lookupBitcoinAddress(
      {required String email, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(email, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 112, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_email_integration_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kLookupBitcoinAddressConstMeta,
      argValues: [email],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLookupBitcoinAddressConstMeta => const TaskConstMeta(
        debugName: "lookup_bitcoin_address",
        argNames: ["email"],
      );

  @override
  Future<ApiWalletAccount> removeEmailAddress(
      {required String walletId,
      required String walletAccountId,
      required String addressId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(addressId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 109, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kRemoveEmailAddressConstMeta,
      argValues: [walletId, walletAccountId, addressId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kRemoveEmailAddressConstMeta => const TaskConstMeta(
        debugName: "remove_email_address",
        argNames: ["walletId", "walletAccountId", "addressId"],
      );

  @override
  Future<ApiWalletUserSettings> twoFaThreshold(
      {required int amount, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 101, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_user_settings,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kTwoFaThresholdConstMeta,
      argValues: [amount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTwoFaThresholdConstMeta => const TaskConstMeta(
        debugName: "two_fa_threshold",
        argNames: ["amount"],
      );

  @override
  Future<ApiWalletBitcoinAddress> updateBitcoinAddress(
      {required String walletId,
      required String walletAccountId,
      required String walletAccountBitcoinAddressId,
      required BitcoinAddress bitcoinAddress,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(walletAccountBitcoinAddressId, serializer);
        sse_encode_box_autoadd_bitcoin_address(bitcoinAddress, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 110, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_bitcoin_address,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kUpdateBitcoinAddressConstMeta,
      argValues: [
        walletId,
        walletAccountId,
        walletAccountBitcoinAddressId,
        bitcoinAddress
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateBitcoinAddressConstMeta => const TaskConstMeta(
        debugName: "update_bitcoin_address",
        argNames: [
          "walletId",
          "walletAccountId",
          "walletAccountBitcoinAddressId",
          "bitcoinAddress"
        ],
      );

  @override
  Future<ApiWalletAccount> updateWalletAccountFiatCurrency(
      {required String walletId,
      required String walletAccountId,
      required FiatCurrency newFiatCurrency,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_fiat_currency(newFiatCurrency, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 96, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kUpdateWalletAccountFiatCurrencyConstMeta,
      argValues: [walletId, walletAccountId, newFiatCurrency],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateWalletAccountFiatCurrencyConstMeta =>
      const TaskConstMeta(
        debugName: "update_wallet_account_fiat_currency",
        argNames: ["walletId", "walletAccountId", "newFiatCurrency"],
      );

  @override
  Future<ApiWalletAccount> updateWalletAccountLabel(
      {required String walletId,
      required String walletAccountId,
      required String newLabel,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(newLabel, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 95, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet_account,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kUpdateWalletAccountLabelConstMeta,
      argValues: [walletId, walletAccountId, newLabel],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateWalletAccountLabelConstMeta => const TaskConstMeta(
        debugName: "update_wallet_account_label",
        argNames: ["walletId", "walletAccountId", "newLabel"],
      );

  @override
  Future<ApiWallet> updateWalletName(
      {required String walletId, required String newName, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(newName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_wallet,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kUpdateWalletNameConstMeta,
      argValues: [walletId, newName],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateWalletNameConstMeta => const TaskConstMeta(
        debugName: "update_wallet_name",
        argNames: ["walletId", "newName"],
      );

  @override
  Future<WalletTransaction> updateWalletTransactionLabel(
      {required String walletId,
      required String walletAccountId,
      required String walletTransactionId,
      required String label,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(walletTransactionId, serializer);
        sse_encode_String(label, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 117, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_transaction,
        decodeErrorData: sse_decode_bridge_error,
      ),
      constMeta: kUpdateWalletTransactionLabelConstMeta,
      argValues: [walletId, walletAccountId, walletTransactionId, label],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateWalletTransactionLabelConstMeta =>
      const TaskConstMeta(
        debugName: "update_wallet_transaction_label",
        argNames: [
          "walletId",
          "walletAccountId",
          "walletTransactionId",
          "label"
        ],
      );

  @override
  Future<String> apiAddressFromScript(
      {required Script script, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script(script, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 169, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiAddressFromScriptConstMeta,
      argValues: [script, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiAddressFromScriptConstMeta => const TaskConstMeta(
        debugName: "api_address_from_script",
        argNames: ["script", "network"],
      );

  @override
  Future<Network> apiAddressNetwork({required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 171, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiAddressNetworkConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiAddressNetworkConstMeta => const TaskConstMeta(
        debugName: "api_address_network",
        argNames: ["address"],
      );

  @override
  Future<Script> apiAddressToScriptPubkey(
      {required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 170, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_script,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiAddressToScriptPubkeyConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiAddressToScriptPubkeyConstMeta => const TaskConstMeta(
        debugName: "api_address_to_script_pubkey",
        argNames: ["address"],
      );

  @override
  Future<String> apiBroadcast(
      {required String tx, required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 127, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiBroadcastConstMeta,
      argValues: [tx, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiBroadcastConstMeta => const TaskConstMeta(
        debugName: "api_broadcast",
        argNames: ["tx", "blockchainId"],
      );

  @override
  Future<(String, TransactionDetails)> apiBumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required String walletId,
      required bool enableRbf,
      int? nSequence,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(txid, serializer);
        sse_encode_f_32(feeRate, serializer);
        sse_encode_opt_String(allowShrinking, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_bool(enableRbf, serializer);
        sse_encode_opt_box_autoadd_u_32(nSequence, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 148, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_transaction_details,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiBumpFeeTxBuilderFinishConstMeta,
      argValues: [
        txid,
        feeRate,
        allowShrinking,
        walletId,
        enableRbf,
        nSequence
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiBumpFeeTxBuilderFinishConstMeta => const TaskConstMeta(
        debugName: "api_bump_fee_tx_builder_finish",
        argNames: [
          "txid",
          "feeRate",
          "allowShrinking",
          "walletId",
          "enableRbf",
          "nSequence"
        ],
      );

  @override
  Future<String> apiCombinePsbt(
      {required String psbtStr, required String other, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        sse_encode_String(other, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 145, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCombinePsbtConstMeta,
      argValues: [psbtStr, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCombinePsbtConstMeta => const TaskConstMeta(
        debugName: "api_combine_psbt",
        argNames: ["psbtStr", "other"],
      );

  @override
  Future<String> apiCreateAddress({required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 168, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateAddressConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateAddressConstMeta => const TaskConstMeta(
        debugName: "api_create_address",
        argNames: ["address"],
      );

  @override
  Future<String> apiCreateDerivationPath({required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 165, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDerivationPathConstMeta,
      argValues: [path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDerivationPathConstMeta => const TaskConstMeta(
        debugName: "api_create_derivation_path",
        argNames: ["path"],
      );

  @override
  Future<String> apiCreateDescriptor(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 149, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDescriptorConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDescriptorConstMeta => const TaskConstMeta(
        debugName: "api_create_descriptor",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiCreateDescriptorPublic(
      {String? xpub,
      required String path,
      required bool derive,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_String(xpub, serializer);
        sse_encode_String(path, serializer);
        sse_encode_bool(derive, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 167, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDescriptorPublicConstMeta,
      argValues: [xpub, path, derive],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDescriptorPublicConstMeta => const TaskConstMeta(
        debugName: "api_create_descriptor_public",
        argNames: ["xpub", "path", "derive"],
      );

  @override
  Future<String> apiCreateDescriptorSecret(
      {required Network network,
      required String mnemonic,
      String? password,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_network(network, serializer);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 159, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDescriptorSecretConstMeta,
      argValues: [network, mnemonic, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDescriptorSecretConstMeta => const TaskConstMeta(
        debugName: "api_create_descriptor_secret",
        argNames: ["network", "mnemonic", "password"],
      );

  @override
  Future<String> apiCreateEsploraBlockchainWithApi(
      {required EsploraConfig config, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_esplora_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 123, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateEsploraBlockchainWithApiConstMeta,
      argValues: [config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateEsploraBlockchainWithApiConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_esplora_blockchain_with_api",
        argNames: ["config"],
      );

  @override
  Future<String> apiCreateTransaction({required List<int> tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 128, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateTransactionConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateTransactionConstMeta => const TaskConstMeta(
        debugName: "api_create_transaction",
        argNames: ["tx"],
      );

  @override
  Future<String> apiCreateWallet(
      {required String descriptor,
      String? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_opt_String(changeDescriptor, serializer);
        sse_encode_network(network, serializer);
        sse_encode_box_autoadd_database_config(databaseConfig, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 172, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateWalletConstMeta,
      argValues: [descriptor, changeDescriptor, network, databaseConfig],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateWalletConstMeta => const TaskConstMeta(
        debugName: "api_create_wallet",
        argNames: [
          "descriptor",
          "changeDescriptor",
          "network",
          "databaseConfig"
        ],
      );

  @override
  Future<String> apiDeriveDescriptorSecret(
      {required String secret, required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 162, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kApiDeriveDescriptorSecretConstMeta,
      argValues: [secret, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDeriveDescriptorSecretConstMeta => const TaskConstMeta(
        debugName: "api_derive_descriptor_secret",
        argNames: ["secret", "path"],
      );

  @override
  Future<String> apiDescriptorAsString(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 157, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorAsStringConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorAsStringConstMeta => const TaskConstMeta(
        debugName: "api_descriptor_as_string",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiDescriptorAsStringPrivate(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 156, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorAsStringPrivateConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorAsStringPrivateConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_as_string_private",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiDescriptorPublicFromString(
      {required String publicKey, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(publicKey, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 166, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorPublicFromStringConstMeta,
      argValues: [publicKey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorPublicFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_public_from_string",
        argNames: ["publicKey"],
      );

  @override
  Future<String> apiDescriptorSecretAsPublic(
      {required String secret, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 164, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorSecretAsPublicConstMeta,
      argValues: [secret],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorSecretAsPublicConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_secret_as_public",
        argNames: ["secret"],
      );

  @override
  Future<Uint8List> apiDescriptorSecretAsSecretBytes(
      {required String secret, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 163, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorSecretAsSecretBytesConstMeta,
      argValues: [secret],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorSecretAsSecretBytesConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_secret_as_secret_bytes",
        argNames: ["secret"],
      );

  @override
  Future<String> apiDescriptorSecretFromString(
      {required String secret, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 160, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorSecretFromStringConstMeta,
      argValues: [secret],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorSecretFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_secret_from_string",
        argNames: ["secret"],
      );

  @override
  Future<double> apiEstimateFee(
      {required int target, required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(target, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 126, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiEstimateFeeConstMeta,
      argValues: [target, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiEstimateFeeConstMeta => const TaskConstMeta(
        debugName: "api_estimate_fee",
        argNames: ["target", "blockchainId"],
      );

  @override
  Future<String> apiExtendDescriptorSecret(
      {required String secret, required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 161, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kApiExtendDescriptorSecretConstMeta,
      argValues: [secret, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiExtendDescriptorSecretConstMeta => const TaskConstMeta(
        debugName: "api_extend_descriptor_secret",
        argNames: ["secret", "path"],
      );

  @override
  Future<String> apiExtractTx({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 142, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiExtractTxConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiExtractTxConstMeta => const TaskConstMeta(
        debugName: "api_extract_tx",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> apiGenerateSeedFromEntropy(
      {required List<int> entropy, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(entropy, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 187, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGenerateSeedFromEntropyConstMeta,
      argValues: [entropy],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGenerateSeedFromEntropyConstMeta => const TaskConstMeta(
        debugName: "api_generate_seed_from_entropy",
        argNames: ["entropy"],
      );

  @override
  Future<String> apiGenerateSeedFromString(
      {required String mnemonic, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 186, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGenerateSeedFromStringConstMeta,
      argValues: [mnemonic],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGenerateSeedFromStringConstMeta => const TaskConstMeta(
        debugName: "api_generate_seed_from_string",
        argNames: ["mnemonic"],
      );

  @override
  Future<String> apiGenerateSeedFromWordCount(
      {required WordCount wordCount, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_word_count(wordCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 185, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kApiGenerateSeedFromWordCountConstMeta,
      argValues: [wordCount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGenerateSeedFromWordCountConstMeta =>
      const TaskConstMeta(
        debugName: "api_generate_seed_from_word_count",
        argNames: ["wordCount"],
      );

  @override
  Future<AddressInfo> apiGetAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_address_index(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 173, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetAddressConstMeta,
      argValues: [walletId, addressIndex],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetAddressConstMeta => const TaskConstMeta(
        debugName: "api_get_address",
        argNames: ["walletId", "addressIndex"],
      );

  @override
  Future<Balance> apiGetBalance({required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 177, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_balance,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetBalanceConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetBalanceConstMeta => const TaskConstMeta(
        debugName: "api_get_balance",
        argNames: ["walletId"],
      );

  @override
  Future<String> apiGetBlockchainHash(
      {required int blockchainHeight,
      required String blockchainId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(blockchainHeight, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 125, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetBlockchainHashConstMeta,
      argValues: [blockchainHeight, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetBlockchainHashConstMeta => const TaskConstMeta(
        debugName: "api_get_blockchain_hash",
        argNames: ["blockchainHeight", "blockchainId"],
      );

  @override
  Future<(String, Network)> apiGetDescriptorForKeychain(
      {required String walletId,
      required KeychainKind keychain,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_keychain_kind(keychain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 184, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_network,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetDescriptorForKeychainConstMeta,
      argValues: [walletId, keychain],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetDescriptorForKeychainConstMeta =>
      const TaskConstMeta(
        debugName: "api_get_descriptor_for_keychain",
        argNames: ["walletId", "keychain"],
      );

  @override
  Future<int> apiGetHeight({required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 124, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetHeightConstMeta,
      argValues: [blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetHeightConstMeta => const TaskConstMeta(
        debugName: "api_get_height",
        argNames: ["blockchainId"],
      );

  @override
  Future<AddressInfo> apiGetInternalAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_address_index(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 175, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetInternalAddressConstMeta,
      argValues: [walletId, addressIndex],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetInternalAddressConstMeta => const TaskConstMeta(
        debugName: "api_get_internal_address",
        argNames: ["walletId", "addressIndex"],
      );

  @override
  Future<String> apiGetPsbtInput(
      {required String walletId,
      required LocalUtxo utxo,
      required bool onlyWitnessUtxo,
      PsbtSigHashType? psbtSighashType,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_local_utxo(utxo, serializer);
        sse_encode_bool(onlyWitnessUtxo, serializer);
        sse_encode_opt_box_autoadd_psbt_sig_hash_type(
            psbtSighashType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 183, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetPsbtInputConstMeta,
      argValues: [walletId, utxo, onlyWitnessUtxo, psbtSighashType],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetPsbtInputConstMeta => const TaskConstMeta(
        debugName: "api_get_psbt_input",
        argNames: ["walletId", "utxo", "onlyWitnessUtxo", "psbtSighashType"],
      );

  @override
  Future<List<TransactionDetails>> apiGetTransactions(
      {required String walletId, required bool includeRaw, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_bool(includeRaw, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 179, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_transaction_details,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetTransactionsConstMeta,
      argValues: [walletId, includeRaw],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetTransactionsConstMeta => const TaskConstMeta(
        debugName: "api_get_transactions",
        argNames: ["walletId", "includeRaw"],
      );

  @override
  Future<List<TxIn>> apiInput({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 138, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_in,
        decodeErrorData: null,
      ),
      constMeta: kApiInputConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiInputConstMeta => const TaskConstMeta(
        debugName: "api_input",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsCoinBase({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 133, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kApiIsCoinBaseConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsCoinBaseConstMeta => const TaskConstMeta(
        debugName: "api_is_coin_base",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsExplicitlyRbf({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 134, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kApiIsExplicitlyRbfConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsExplicitlyRbfConstMeta => const TaskConstMeta(
        debugName: "api_is_explicitly_rbf",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsLockTimeEnabled({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 135, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kApiIsLockTimeEnabledConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsLockTimeEnabledConstMeta => const TaskConstMeta(
        debugName: "api_is_lock_time_enabled",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsMine(
      {required Script script, required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script(script, serializer);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 174, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiIsMineConstMeta,
      argValues: [script, walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsMineConstMeta => const TaskConstMeta(
        debugName: "api_is_mine",
        argNames: ["script", "walletId"],
      );

  @override
  Future<String> apiJsonSerialize({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 146, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiJsonSerializeConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiJsonSerializeConstMeta => const TaskConstMeta(
        debugName: "api_json_serialize",
        argNames: ["psbtStr"],
      );

  @override
  Future<List<LocalUtxo>> apiListUnspent(
      {required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 182, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_local_utxo,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiListUnspentConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiListUnspentConstMeta => const TaskConstMeta(
        debugName: "api_list_unspent",
        argNames: ["walletId"],
      );

  @override
  Future<List<LocalUtxo>> apiListUnspentOutputs(
      {required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 178, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_local_utxo,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiListUnspentOutputsConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiListUnspentOutputsConstMeta => const TaskConstMeta(
        debugName: "api_list_unspent_outputs",
        argNames: ["walletId"],
      );

  @override
  Future<int> apiLockTime({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 137, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kApiLockTimeConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiLockTimeConstMeta => const TaskConstMeta(
        debugName: "api_lock_time",
        argNames: ["tx"],
      );

  @override
  Future<int> apiMaxSatisfactionWeight(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 158, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiMaxSatisfactionWeightConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiMaxSatisfactionWeightConstMeta => const TaskConstMeta(
        debugName: "api_max_satisfaction_weight",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiNewBip44Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 150, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip44DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip44DescriptorConstMeta => const TaskConstMeta(
        debugName: "api_new_bip44_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<String> apiNewBip44Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 151, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip44PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip44PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip44_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<String> apiNewBip49Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 152, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip49DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip49DescriptorConstMeta => const TaskConstMeta(
        debugName: "api_new_bip49_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<String> apiNewBip49Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 153, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip49PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip49PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip49_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<String> apiNewBip84Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 154, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip84DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip84DescriptorConstMeta => const TaskConstMeta(
        debugName: "api_new_bip84_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<String> apiNewBip84Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 155, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip84PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip84PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip84_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<List<TxOut>> apiOutput({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 139, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_out,
        decodeErrorData: null,
      ),
      constMeta: kApiOutputConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiOutputConstMeta => const TaskConstMeta(
        debugName: "api_output",
        argNames: ["tx"],
      );

  @override
  Future<int?> apiPsbtFeeAmount({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 144, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiPsbtFeeAmountConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPsbtFeeAmountConstMeta => const TaskConstMeta(
        debugName: "api_psbt_fee_amount",
        argNames: ["psbtStr"],
      );

  @override
  Future<double?> apiPsbtFeeRate({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 143, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_32,
        decodeErrorData: null,
      ),
      constMeta: kApiPsbtFeeRateConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPsbtFeeRateConstMeta => const TaskConstMeta(
        debugName: "api_psbt_fee_rate",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> apiPsbtTxid({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 141, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiPsbtTxidConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPsbtTxidConstMeta => const TaskConstMeta(
        debugName: "api_psbt_txid",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> apiSerializePsbt({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 140, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiSerializePsbtConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSerializePsbtConstMeta => const TaskConstMeta(
        debugName: "api_serialize_psbt",
        argNames: ["psbtStr"],
      );

  @override
  Future<String?> apiSign(
      {required String walletId,
      required String psbtStr,
      SignOptions? signOptions,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(psbtStr, serializer);
        sse_encode_opt_box_autoadd_sign_options(signOptions, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 180, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiSignConstMeta,
      argValues: [walletId, psbtStr, signOptions],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSignConstMeta => const TaskConstMeta(
        debugName: "api_sign",
        argNames: ["walletId", "psbtStr", "signOptions"],
      );

  @override
  Future<int> apiSize({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 131, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiSizeConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSizeConstMeta => const TaskConstMeta(
        debugName: "api_size",
        argNames: ["tx"],
      );

  @override
  Future<void> apiSyncWallet(
      {required String walletId, required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 176, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kApiSyncWalletConstMeta,
      argValues: [walletId, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSyncWalletConstMeta => const TaskConstMeta(
        debugName: "api_sync_wallet",
        argNames: ["walletId", "blockchainId"],
      );

  @override
  Future<(String, TransactionDetails)> apiTxBuilderFinish(
      {required String walletId,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      (OutPoint, String, int)? foreignUtxo,
      required List<OutPoint> unspendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_list_script_amount(recipients, serializer);
        sse_encode_list_out_point(utxos, serializer);
        sse_encode_opt_box_autoadd_record_out_point_string_usize(
            foreignUtxo, serializer);
        sse_encode_list_out_point(unspendable, serializer);
        sse_encode_change_spend_policy(changePolicy, serializer);
        sse_encode_bool(manuallySelectedOnly, serializer);
        sse_encode_opt_box_autoadd_f_32(feeRate, serializer);
        sse_encode_opt_box_autoadd_u_64(feeAbsolute, serializer);
        sse_encode_bool(drainWallet, serializer);
        sse_encode_opt_box_autoadd_script(drainTo, serializer);
        sse_encode_opt_box_autoadd_rbf_value(rbf, serializer);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 147, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_transaction_details,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiTxBuilderFinishConstMeta,
      argValues: [
        walletId,
        recipients,
        utxos,
        foreignUtxo,
        unspendable,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiTxBuilderFinishConstMeta => const TaskConstMeta(
        debugName: "api_tx_builder_finish",
        argNames: [
          "walletId",
          "recipients",
          "utxos",
          "foreignUtxo",
          "unspendable",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data"
        ],
      );

  @override
  Future<String> apiTxTxid({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 129, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiTxTxidConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiTxTxidConstMeta => const TaskConstMeta(
        debugName: "api_tx_txid",
        argNames: ["tx"],
      );

  @override
  Future<int> apiVersion({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 136, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kApiVersionConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiVersionConstMeta => const TaskConstMeta(
        debugName: "api_version",
        argNames: ["tx"],
      );

  @override
  Future<int> apiVsize({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 132, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiVsizeConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiVsizeConstMeta => const TaskConstMeta(
        debugName: "api_vsize",
        argNames: ["tx"],
      );

  @override
  Future<Network> apiWalletNetwork({required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 181, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kApiWalletNetworkConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiWalletNetworkConstMeta => const TaskConstMeta(
        debugName: "api_wallet_network",
        argNames: ["walletId"],
      );

  @override
  Future<int> apiWeight({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 130, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiWeightConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiWeightConstMeta => const TaskConstMeta(
        debugName: "api_weight",
        argNames: ["tx"],
      );

  @override
  Future<MyTestObject> myTestObjectNew({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 188, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_my_test_object,
        decodeErrorData: null,
      ),
      constMeta: kMyTestObjectNewConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kMyTestObjectNewConstMeta => const TaskConstMeta(
        debugName: "my_test_object_new",
        argNames: [],
      );

  @override
  Future<String> myTestObjectReadText(
      {required MyTestObject that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_my_test_object(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 189, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kMyTestObjectReadTextConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kMyTestObjectReadTextConstMeta => const TaskConstMeta(
        debugName: "my_test_object_read_text",
        argNames: ["that"],
      );

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_child_session_Output_String(
          FutureOr<String> Function(ChildSession) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_child_session(rawArg0);

      final rawOutput = await raw(arg0);

      final serializer = SseSerializer(generalizedFrbRustBinding);
      sse_encode_String(rawOutput, serializer);
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AddressBalance => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AddressBalance => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AddressClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AddressClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ApiTx =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ApiTx =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcProtonApiService => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcProtonApiService => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkWalletManager => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkWalletManager => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BitcoinAddressClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BitcoinAddressClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ContactsClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ContactsClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EmailIntegrationClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EmailIntegrationClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExchangeRateClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExchangeRateClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OnRampGatewayClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OnRampGatewayClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonApiService => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonApiService => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonEmailAddressClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonEmailAddressClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonUsersClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonUsersClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtonWalletAuthStore => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtonWalletAuthStore => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SettingsClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SettingsClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_TransactionClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_TransactionClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WalletClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WalletClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkTransaction => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkTransaction => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction;

  @protected
  AddressBalance
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressBalance.dcoDecode(raw as List<dynamic>);
  }

  @protected
  AddressClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ApiTx
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ApiTx.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcProtonApiService
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcProtonApiService.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkWalletManager
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkWalletManager.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BitcoinAddressClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BitcoinAddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ContactsClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ContactsClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  EmailIntegrationClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EmailIntegrationClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  EventClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ExchangeRateClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExchangeRateClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  OnRampGatewayClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnRampGatewayClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonApiService
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonApiService.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonEmailAddressClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonEmailAddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonUsersClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonUsersClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonWalletAuthStore
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonWalletAuthStore.dcoDecode(raw as List<dynamic>);
  }

  @protected
  SettingsClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SettingsClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  TransactionClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TransactionClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  WalletClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WalletClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkTransaction
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkTransaction.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonApiService
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonApiService.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonWalletAuthStore
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonWalletAuthStore.dcoDecode(raw as List<dynamic>);
  }

  @protected
  AddressClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkWalletManager
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkWalletManager.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BitcoinAddressClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BitcoinAddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ContactsClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ContactsClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  EmailIntegrationClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EmailIntegrationClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  EventClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ExchangeRateClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExchangeRateClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  OnRampGatewayClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnRampGatewayClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonApiService
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonApiService.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonEmailAddressClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonEmailAddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonWalletAuthStore
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonWalletAuthStore.dcoDecode(raw as List<dynamic>);
  }

  @protected
  SettingsClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SettingsClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  TransactionClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TransactionClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  WalletClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WalletClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  FutureOr<String> Function(ChildSession)
      dco_decode_DartFn_Inputs_child_session_Output_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  Map<GatewayProvider, List<ApiCountry>>
      dco_decode_Map_gateway_provider_list_api_country(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
        dco_decode_list_record_gateway_provider_list_api_country(raw)
            .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<GatewayProvider, List<ApiCountryFiatCurrency>>
      dco_decode_Map_gateway_provider_list_api_country_fiat_currency(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
        dco_decode_list_record_gateway_provider_list_api_country_fiat_currency(
                raw)
            .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<GatewayProvider, List<PaymentMethod>>
      dco_decode_Map_gateway_provider_list_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
        dco_decode_list_record_gateway_provider_list_payment_method(raw)
            .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<GatewayProvider, List<Quote>> dco_decode_Map_gateway_provider_list_quote(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
        dco_decode_list_record_gateway_provider_list_quote(raw)
            .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AddressBalance
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressBalance.dcoDecode(raw as List<dynamic>);
  }

  @protected
  AddressClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ApiTx
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ApiTx.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcProtonApiService
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcProtonApiService.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkWalletManager
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkWalletManager.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BitcoinAddressClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BitcoinAddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ContactsClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ContactsClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  EmailIntegrationClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EmailIntegrationClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  EventClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ExchangeRateClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExchangeRateClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  OnRampGatewayClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnRampGatewayClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonApiService
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonApiService.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonEmailAddressClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonEmailAddressClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonUsersClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonUsersClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtonWalletAuthStore
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtonWalletAuthStore.dcoDecode(raw as List<dynamic>);
  }

  @protected
  SettingsClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SettingsClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  TransactionClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TransactionClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  WalletClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WalletClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  BdkTransaction
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkTransaction.dcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressIndex dco_decode_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressIndex_New();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        return AddressIndex_Peek(
          index: dco_decode_u_32(raw[1]),
        );
      case 3:
        return AddressIndex_Reset(
          index: dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AddressInfo dco_decode_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AddressInfo(
      index: dco_decode_u_32(arr[0]),
      address: dco_decode_String(arr[1]),
    );
  }

  @protected
  AllKeyAddressKey dco_decode_all_key_address_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AllKeyAddressKey(
      flags: dco_decode_u_32(arr[0]),
      publicKey: dco_decode_String(arr[1]),
      source: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  Api dco_decode_api(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 0)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return Api();
  }

  @protected
  ApiContactEmails dco_decode_api_contact_emails(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ApiContactEmails(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      email: dco_decode_String(arr[2]),
      canonicalEmail: dco_decode_String(arr[3]),
      isProton: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  ApiCountry dco_decode_api_country(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ApiCountry(
      code: dco_decode_String(arr[0]),
      fiatCurrency: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
    );
  }

  @protected
  ApiCountryFiatCurrency dco_decode_api_country_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiCountryFiatCurrency(
      name: dco_decode_String(arr[0]),
      symbol: dco_decode_String(arr[1]),
    );
  }

  @protected
  ApiEmailAddress dco_decode_api_email_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ApiEmailAddress(
      id: dco_decode_String(arr[0]),
      email: dco_decode_String(arr[1]),
    );
  }

  @protected
  ApiWallet dco_decode_api_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return ApiWallet(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      isImported: dco_decode_u_8(arr[2]),
      priority: dco_decode_u_8(arr[3]),
      type: dco_decode_u_8(arr[4]),
      hasPassphrase: dco_decode_u_8(arr[5]),
      status: dco_decode_u_8(arr[6]),
      mnemonic: dco_decode_opt_String(arr[7]),
      fingerprint: dco_decode_opt_String(arr[8]),
      publicKey: dco_decode_opt_String(arr[9]),
    );
  }

  @protected
  ApiWalletAccount dco_decode_api_wallet_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ApiWalletAccount(
      id: dco_decode_String(arr[0]),
      walletId: dco_decode_String(arr[1]),
      fiatCurrency: dco_decode_fiat_currency(arr[2]),
      derivationPath: dco_decode_String(arr[3]),
      label: dco_decode_String(arr[4]),
      scriptType: dco_decode_u_8(arr[5]),
      addresses: dco_decode_list_api_email_address(arr[6]),
    );
  }

  @protected
  ApiWalletBitcoinAddress dco_decode_api_wallet_bitcoin_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ApiWalletBitcoinAddress(
      id: dco_decode_String(arr[0]),
      walletId: dco_decode_String(arr[1]),
      walletAccountId: dco_decode_String(arr[2]),
      fetched: dco_decode_u_8(arr[3]),
      used: dco_decode_u_8(arr[4]),
      bitcoinAddress: dco_decode_opt_String(arr[5]),
      bitcoinAddressSignature: dco_decode_opt_String(arr[6]),
      bitcoinAddressIndex: dco_decode_opt_box_autoadd_u_64(arr[7]),
    );
  }

  @protected
  ApiWalletData dco_decode_api_wallet_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ApiWalletData(
      wallet: dco_decode_api_wallet(arr[0]),
      walletKey: dco_decode_api_wallet_key(arr[1]),
      walletSettings: dco_decode_api_wallet_settings(arr[2]),
    );
  }

  @protected
  ApiWalletKey dco_decode_api_wallet_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ApiWalletKey(
      walletId: dco_decode_String(arr[0]),
      userKeyId: dco_decode_String(arr[1]),
      walletKey: dco_decode_String(arr[2]),
      walletKeySignature: dco_decode_String(arr[3]),
    );
  }

  @protected
  ApiWalletSettings dco_decode_api_wallet_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ApiWalletSettings(
      walletId: dco_decode_String(arr[0]),
      hideAccounts: dco_decode_u_8(arr[1]),
      invoiceDefaultDescription: dco_decode_opt_String(arr[2]),
      invoiceExpirationTime: dco_decode_u_64(arr[3]),
      maxChannelOpeningFee: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  ApiWalletUserSettings dco_decode_api_wallet_user_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ApiWalletUserSettings(
      bitcoinUnit: dco_decode_bitcoin_unit(arr[0]),
      fiatCurrency: dco_decode_fiat_currency(arr[1]),
      hideEmptyUsedAddresses: dco_decode_u_8(arr[2]),
      showWalletRecovery: dco_decode_u_8(arr[3]),
      twoFactorAmountThreshold: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  AuthCredential dco_decode_auth_credential(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return AuthCredential(
      sessionId: dco_decode_String(arr[0]),
      userId: dco_decode_String(arr[1]),
      accessToken: dco_decode_String(arr[2]),
      refreshToken: dco_decode_String(arr[3]),
      eventId: dco_decode_String(arr[4]),
      userMail: dco_decode_String(arr[5]),
      userName: dco_decode_String(arr[6]),
      displayName: dco_decode_String(arr[7]),
      scops: dco_decode_list_String(arr[8]),
      userKeyId: dco_decode_String(arr[9]),
      userPrivateKey: dco_decode_String(arr[10]),
      userPassphrase: dco_decode_String(arr[11]),
    );
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: dco_decode_u_64(arr[0]),
      trustedPending: dco_decode_u_64(arr[1]),
      untrustedPending: dco_decode_u_64(arr[2]),
      confirmed: dco_decode_u_64(arr[3]),
      spendable: dco_decode_u_64(arr[4]),
      total: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  BitcoinAddress dco_decode_bitcoin_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return BitcoinAddress(
      bitcoinAddress: dco_decode_String(arr[0]),
      bitcoinAddressSignature: dco_decode_String(arr[1]),
      bitcoinAddressIndex: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  BitcoinUnit dco_decode_bitcoin_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BitcoinUnit.values[raw as int];
  }

  @protected
  BlockTime dco_decode_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddressIndex dco_decode_box_autoadd_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_index(raw);
  }

  @protected
  ApiContactEmails dco_decode_box_autoadd_api_contact_emails(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_contact_emails(raw);
  }

  @protected
  ApiWallet dco_decode_box_autoadd_api_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_wallet(raw);
  }

  @protected
  ApiWalletAccount dco_decode_box_autoadd_api_wallet_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_wallet_account(raw);
  }

  @protected
  ApiWalletKey dco_decode_box_autoadd_api_wallet_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_wallet_key(raw);
  }

  @protected
  ApiWalletSettings dco_decode_box_autoadd_api_wallet_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_wallet_settings(raw);
  }

  @protected
  ApiWalletUserSettings dco_decode_box_autoadd_api_wallet_user_settings(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_api_wallet_user_settings(raw);
  }

  @protected
  BitcoinAddress dco_decode_box_autoadd_bitcoin_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bitcoin_address(raw);
  }

  @protected
  BlockTime dco_decode_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_block_time(raw);
  }

  @protected
  CreateWalletAccountReq dco_decode_box_autoadd_create_wallet_account_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_create_wallet_account_req(raw);
  }

  @protected
  CreateWalletReq dco_decode_box_autoadd_create_wallet_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_create_wallet_req(raw);
  }

  @protected
  DatabaseConfig dco_decode_box_autoadd_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_database_config(raw);
  }

  @protected
  EsploraConfig dco_decode_box_autoadd_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_esplora_config(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GatewayProvider dco_decode_box_autoadd_gateway_provider(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gateway_provider(raw);
  }

  @protected
  LocalUtxo dco_decode_box_autoadd_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_local_utxo(raw);
  }

  @protected
  MyTestObject dco_decode_box_autoadd_my_test_object(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_my_test_object(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PaymentMethod dco_decode_box_autoadd_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_method(raw);
  }

  @protected
  ProtonExchangeRate dco_decode_box_autoadd_proton_exchange_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_proton_exchange_rate(raw);
  }

  @protected
  PsbtSigHashType dco_decode_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue dco_decode_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rbf_value(raw);
  }

  @protected
  (OutPoint, String, int) dco_decode_box_autoadd_record_out_point_string_usize(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as (OutPoint, String, int);
  }

  @protected
  Script dco_decode_box_autoadd_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_script(raw);
  }

  @protected
  SignOptions dco_decode_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_options(raw);
  }

  @protected
  SqliteDbConfiguration dco_decode_box_autoadd_sqlite_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sqlite_db_configuration(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  WalletTransaction dco_decode_box_autoadd_wallet_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wallet_transaction(raw);
  }

  @protected
  BridgeError dco_decode_bridge_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BridgeError_AndromedaApi(
          dco_decode_String(raw[1]),
        );
      case 1:
        return BridgeError_Generic(
          dco_decode_String(raw[1]),
        );
      case 2:
        return BridgeError_MuonSession(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChangeSpendPolicy dco_decode_change_spend_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChangeSpendPolicy.values[raw as int];
  }

  @protected
  ChildSession dco_decode_child_session(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ChildSession(
      sessionId: dco_decode_String(arr[0]),
      accessToken: dco_decode_String(arr[1]),
      refreshToken: dco_decode_String(arr[2]),
      scopes: dco_decode_list_String(arr[3]),
    );
  }

  @protected
  ContactEmailEvent dco_decode_contact_email_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ContactEmailEvent(
      id: dco_decode_String(arr[0]),
      action: dco_decode_u_32(arr[1]),
      contactEmail: dco_decode_opt_box_autoadd_api_contact_emails(arr[2]),
    );
  }

  @protected
  CreateWalletAccountReq dco_decode_create_wallet_account_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CreateWalletAccountReq(
      label: dco_decode_String(arr[0]),
      derivationPath: dco_decode_String(arr[1]),
      scriptType: dco_decode_u_8(arr[2]),
    );
  }

  @protected
  CreateWalletReq dco_decode_create_wallet_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return CreateWalletReq(
      name: dco_decode_String(arr[0]),
      isImported: dco_decode_u_8(arr[1]),
      type: dco_decode_u_8(arr[2]),
      hasPassphrase: dco_decode_u_8(arr[3]),
      userKeyId: dco_decode_String(arr[4]),
      walletKey: dco_decode_String(arr[5]),
      mnemonic: dco_decode_opt_String(arr[6]),
      publicKey: dco_decode_opt_String(arr[7]),
      fingerprint: dco_decode_opt_String(arr[8]),
      walletKeySignature: dco_decode_String(arr[9]),
    );
  }

  @protected
  DatabaseConfig dco_decode_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        return DatabaseConfig_Sqlite(
          config: dco_decode_box_autoadd_sqlite_db_configuration(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EmailIntegrationBitcoinAddress dco_decode_email_integration_bitcoin_address(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return EmailIntegrationBitcoinAddress(
      bitcoinAddress: dco_decode_opt_String(arr[0]),
      bitcoinAddressSignature: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  Error dco_decode_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Error_InvalidU32Bytes(
          dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 1:
        return Error_Generic(
          dco_decode_String(raw[1]),
        );
      case 2:
        return Error_ScriptDoesntHaveAddressForm();
      case 3:
        return Error_NoRecipients();
      case 4:
        return Error_NoUtxosSelected();
      case 5:
        return Error_OutputBelowDustLimit(
          dco_decode_usize(raw[1]),
        );
      case 6:
        return Error_InsufficientFunds(
          needed: dco_decode_u_64(raw[1]),
          available: dco_decode_u_64(raw[2]),
        );
      case 7:
        return Error_BnBTotalTriesExceeded();
      case 8:
        return Error_BnBNoExactMatch();
      case 9:
        return Error_UnknownUtxo();
      case 10:
        return Error_TransactionNotFound();
      case 11:
        return Error_TransactionConfirmed();
      case 12:
        return Error_IrreplaceableTransaction();
      case 13:
        return Error_FeeRateTooLow(
          required: dco_decode_f_32(raw[1]),
        );
      case 14:
        return Error_FeeTooLow(
          required: dco_decode_u_64(raw[1]),
        );
      case 15:
        return Error_FeeRateUnavailable();
      case 16:
        return Error_MissingKeyOrigin(
          dco_decode_String(raw[1]),
        );
      case 17:
        return Error_Key(
          dco_decode_String(raw[1]),
        );
      case 18:
        return Error_ChecksumMismatch();
      case 19:
        return Error_SpendingPolicyRequired(
          dco_decode_keychain_kind(raw[1]),
        );
      case 20:
        return Error_InvalidPolicyPathError(
          dco_decode_String(raw[1]),
        );
      case 21:
        return Error_Signer(
          dco_decode_String(raw[1]),
        );
      case 22:
        return Error_InvalidNetwork(
          requested: dco_decode_network(raw[1]),
          found: dco_decode_network(raw[2]),
        );
      case 23:
        return Error_InvalidOutpoint(
          dco_decode_box_autoadd_out_point(raw[1]),
        );
      case 24:
        return Error_Descriptor(
          dco_decode_String(raw[1]),
        );
      case 25:
        return Error_Encode(
          dco_decode_String(raw[1]),
        );
      case 26:
        return Error_Miniscript(
          dco_decode_String(raw[1]),
        );
      case 27:
        return Error_MiniscriptPsbt(
          dco_decode_String(raw[1]),
        );
      case 28:
        return Error_Bip32(
          dco_decode_String(raw[1]),
        );
      case 29:
        return Error_Secp256k1(
          dco_decode_String(raw[1]),
        );
      case 30:
        return Error_Json(
          dco_decode_String(raw[1]),
        );
      case 31:
        return Error_Hex(
          dco_decode_String(raw[1]),
        );
      case 32:
        return Error_Psbt(
          dco_decode_String(raw[1]),
        );
      case 33:
        return Error_PsbtParse(
          dco_decode_String(raw[1]),
        );
      case 34:
        return Error_MissingCachedScripts(
          dco_decode_usize(raw[1]),
          dco_decode_usize(raw[2]),
        );
      case 35:
        return Error_Electrum(
          dco_decode_String(raw[1]),
        );
      case 36:
        return Error_Esplora(
          dco_decode_String(raw[1]),
        );
      case 37:
        return Error_Sled(
          dco_decode_String(raw[1]),
        );
      case 38:
        return Error_Rpc(
          dco_decode_String(raw[1]),
        );
      case 39:
        return Error_Rusqlite(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EsploraConfig dco_decode_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return EsploraConfig(
      baseUrl: dco_decode_String(arr[0]),
      proxy: dco_decode_opt_String(arr[1]),
      concurrency: dco_decode_opt_box_autoadd_u_8(arr[2]),
      stopGap: dco_decode_u_64(arr[3]),
      timeout: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FiatCurrency dco_decode_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FiatCurrency.values[raw as int];
  }

  @protected
  GatewayProvider dco_decode_gateway_provider(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GatewayProvider.values[raw as int];
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  KeychainKind dco_decode_keychain_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeychainKind.values[raw as int];
  }

  @protected
  Level dco_decode_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Level.values[raw as int];
  }

  @protected
  List<ApiTx>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<AllKeyAddressKey> dco_decode_list_all_key_address_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_all_key_address_key).toList();
  }

  @protected
  List<ApiContactEmails> dco_decode_list_api_contact_emails(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_contact_emails).toList();
  }

  @protected
  List<ApiCountry> dco_decode_list_api_country(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_country).toList();
  }

  @protected
  List<ApiCountryFiatCurrency> dco_decode_list_api_country_fiat_currency(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_api_country_fiat_currency)
        .toList();
  }

  @protected
  List<ApiEmailAddress> dco_decode_list_api_email_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_email_address).toList();
  }

  @protected
  List<ApiWalletAccount> dco_decode_list_api_wallet_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_wallet_account).toList();
  }

  @protected
  List<ApiWalletBitcoinAddress> dco_decode_list_api_wallet_bitcoin_address(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_api_wallet_bitcoin_address)
        .toList();
  }

  @protected
  List<ApiWalletData> dco_decode_list_api_wallet_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_api_wallet_data).toList();
  }

  @protected
  List<BitcoinAddress> dco_decode_list_bitcoin_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bitcoin_address).toList();
  }

  @protected
  List<ContactEmailEvent> dco_decode_list_contact_email_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_contact_email_event).toList();
  }

  @protected
  List<Uint8List> dco_decode_list_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_prim_u_8_strict).toList();
  }

  @protected
  List<LocalUtxo> dco_decode_list_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_utxo).toList();
  }

  @protected
  List<OutPoint> dco_decode_list_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_out_point).toList();
  }

  @protected
  List<PaymentMethod> dco_decode_list_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_method).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ProtonAddress> dco_decode_list_proton_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_proton_address).toList();
  }

  @protected
  List<ProtonAddressKey> dco_decode_list_proton_address_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_proton_address_key).toList();
  }

  @protected
  List<ProtonEvent> dco_decode_list_proton_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_proton_event).toList();
  }

  @protected
  List<Quote> dco_decode_list_quote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_quote).toList();
  }

  @protected
  List<(GatewayProvider, List<ApiCountry>)>
      dco_decode_list_record_gateway_provider_list_api_country(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_gateway_provider_list_api_country)
        .toList();
  }

  @protected
  List<(GatewayProvider, List<ApiCountryFiatCurrency>)>
      dco_decode_list_record_gateway_provider_list_api_country_fiat_currency(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_gateway_provider_list_api_country_fiat_currency)
        .toList();
  }

  @protected
  List<(GatewayProvider, List<PaymentMethod>)>
      dco_decode_list_record_gateway_provider_list_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_gateway_provider_list_payment_method)
        .toList();
  }

  @protected
  List<(GatewayProvider, List<Quote>)>
      dco_decode_list_record_gateway_provider_list_quote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_gateway_provider_list_quote)
        .toList();
  }

  @protected
  List<ScriptAmount> dco_decode_list_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_script_amount).toList();
  }

  @protected
  List<TransactionDetails> dco_decode_list_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_transaction_details).toList();
  }

  @protected
  List<TxIn> dco_decode_list_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_in).toList();
  }

  @protected
  List<TxOut> dco_decode_list_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_out).toList();
  }

  @protected
  List<WalletAccountEvent> dco_decode_list_wallet_account_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_account_event).toList();
  }

  @protected
  List<WalletEvent> dco_decode_list_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_event).toList();
  }

  @protected
  List<WalletKeyEvent> dco_decode_list_wallet_key_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_key_event).toList();
  }

  @protected
  List<WalletSettingsEvent> dco_decode_list_wallet_settings_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_wallet_settings_event)
        .toList();
  }

  @protected
  List<WalletTransaction> dco_decode_list_wallet_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_transaction).toList();
  }

  @protected
  List<WalletTransactionEvent> dco_decode_list_wallet_transaction_event(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_wallet_transaction_event)
        .toList();
  }

  @protected
  LocalUtxo dco_decode_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalUtxo(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_tx_out(arr[1]),
      isSpent: dco_decode_bool(arr[2]),
      keychain: dco_decode_keychain_kind(arr[3]),
    );
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LogEntry(
      timeMillis: dco_decode_i_64(arr[0]),
      msg: dco_decode_String(arr[1]),
      logLevel: dco_decode_level(arr[2]),
      lbl: dco_decode_String(arr[3]),
    );
  }

  @protected
  MyTestObject dco_decode_my_test_object(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 0)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return MyTestObject();
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ApiContactEmails? dco_decode_opt_box_autoadd_api_contact_emails(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_contact_emails(raw);
  }

  @protected
  ApiWallet? dco_decode_opt_box_autoadd_api_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_wallet(raw);
  }

  @protected
  ApiWalletAccount? dco_decode_opt_box_autoadd_api_wallet_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_wallet_account(raw);
  }

  @protected
  ApiWalletKey? dco_decode_opt_box_autoadd_api_wallet_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_wallet_key(raw);
  }

  @protected
  ApiWalletSettings? dco_decode_opt_box_autoadd_api_wallet_settings(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_api_wallet_settings(raw);
  }

  @protected
  ApiWalletUserSettings? dco_decode_opt_box_autoadd_api_wallet_user_settings(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_api_wallet_user_settings(raw);
  }

  @protected
  BlockTime? dco_decode_opt_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_block_time(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  GatewayProvider? dco_decode_opt_box_autoadd_gateway_provider(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_gateway_provider(raw);
  }

  @protected
  PaymentMethod? dco_decode_opt_box_autoadd_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_method(raw);
  }

  @protected
  ProtonExchangeRate? dco_decode_opt_box_autoadd_proton_exchange_rate(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_proton_exchange_rate(raw);
  }

  @protected
  PsbtSigHashType? dco_decode_opt_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue? dco_decode_opt_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rbf_value(raw);
  }

  @protected
  (OutPoint, String, int)?
      dco_decode_opt_box_autoadd_record_out_point_string_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_record_out_point_string_usize(raw);
  }

  @protected
  Script? dco_decode_opt_box_autoadd_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_script(raw);
  }

  @protected
  SignOptions? dco_decode_opt_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sign_options(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  WalletTransaction? dco_decode_opt_box_autoadd_wallet_transaction(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_wallet_transaction(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<ContactEmailEvent>? dco_decode_opt_list_contact_email_event(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_contact_email_event(raw);
  }

  @protected
  List<ProtonAddressKey>? dco_decode_opt_list_proton_address_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_proton_address_key(raw);
  }

  @protected
  List<WalletAccountEvent>? dco_decode_opt_list_wallet_account_event(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_wallet_account_event(raw);
  }

  @protected
  List<WalletEvent>? dco_decode_opt_list_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_wallet_event(raw);
  }

  @protected
  List<WalletKeyEvent>? dco_decode_opt_list_wallet_key_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_wallet_key_event(raw);
  }

  @protected
  List<WalletSettingsEvent>? dco_decode_opt_list_wallet_settings_event(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_wallet_settings_event(raw);
  }

  @protected
  List<WalletTransactionEvent>? dco_decode_opt_list_wallet_transaction_event(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_wallet_transaction_event(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PaymentMethod dco_decode_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentMethod.values[raw as int];
  }

  @protected
  ProtonAddress dco_decode_proton_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ProtonAddress(
      id: dco_decode_String(arr[0]),
      domainId: dco_decode_String(arr[1]),
      email: dco_decode_String(arr[2]),
      status: dco_decode_u_32(arr[3]),
      type: dco_decode_u_32(arr[4]),
      receive: dco_decode_u_32(arr[5]),
      send: dco_decode_u_32(arr[6]),
      displayName: dco_decode_String(arr[7]),
      keys: dco_decode_opt_list_proton_address_key(arr[8]),
    );
  }

  @protected
  ProtonAddressKey dco_decode_proton_address_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ProtonAddressKey(
      id: dco_decode_String(arr[0]),
      version: dco_decode_u_32(arr[1]),
      publicKey: dco_decode_String(arr[2]),
      privateKey: dco_decode_opt_String(arr[3]),
      token: dco_decode_opt_String(arr[4]),
      signature: dco_decode_opt_String(arr[5]),
      primary: dco_decode_u_32(arr[6]),
      active: dco_decode_u_32(arr[7]),
      flags: dco_decode_u_32(arr[8]),
    );
  }

  @protected
  ProtonEvent dco_decode_proton_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return ProtonEvent(
      code: dco_decode_u_16(arr[0]),
      eventId: dco_decode_String(arr[1]),
      refresh: dco_decode_u_32(arr[2]),
      more: dco_decode_u_32(arr[3]),
      contactEmailEvents: dco_decode_opt_list_contact_email_event(arr[4]),
      walletEvents: dco_decode_opt_list_wallet_event(arr[5]),
      walletAccountEvents: dco_decode_opt_list_wallet_account_event(arr[6]),
      walletKeyEvents: dco_decode_opt_list_wallet_key_event(arr[7]),
      walletSettingEvents: dco_decode_opt_list_wallet_settings_event(arr[8]),
      walletTransactionEvents:
          dco_decode_opt_list_wallet_transaction_event(arr[9]),
      walletUserSettings:
          dco_decode_opt_box_autoadd_api_wallet_user_settings(arr[10]),
    );
  }

  @protected
  ProtonExchangeRate dco_decode_proton_exchange_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ProtonExchangeRate(
      id: dco_decode_String(arr[0]),
      bitcoinUnit: dco_decode_bitcoin_unit(arr[1]),
      fiatCurrency: dco_decode_fiat_currency(arr[2]),
      exchangeRateTime: dco_decode_String(arr[3]),
      exchangeRate: dco_decode_u_64(arr[4]),
      cents: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  PsbtSigHashType dco_decode_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PsbtSigHashType(
      inner: dco_decode_u_32(arr[0]),
    );
  }

  @protected
  Quote dco_decode_quote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Quote(
      bitcoinAmount: dco_decode_String(arr[0]),
      fiatAmount: dco_decode_String(arr[1]),
      fiatCurrencySymbol: dco_decode_fiat_currency(arr[2]),
      networkFee: dco_decode_String(arr[3]),
      paymentGatewayFee: dco_decode_String(arr[4]),
      paymentMethod: dco_decode_payment_method(arr[5]),
    );
  }

  @protected
  RbfValue dco_decode_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        return RbfValue_Value(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (GatewayProvider, List<ApiCountry>)
      dco_decode_record_gateway_provider_list_api_country(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_gateway_provider(arr[0]),
      dco_decode_list_api_country(arr[1]),
    );
  }

  @protected
  (GatewayProvider, List<ApiCountryFiatCurrency>)
      dco_decode_record_gateway_provider_list_api_country_fiat_currency(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_gateway_provider(arr[0]),
      dco_decode_list_api_country_fiat_currency(arr[1]),
    );
  }

  @protected
  (GatewayProvider, List<PaymentMethod>)
      dco_decode_record_gateway_provider_list_payment_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_gateway_provider(arr[0]),
      dco_decode_list_payment_method(arr[1]),
    );
  }

  @protected
  (GatewayProvider, List<Quote>) dco_decode_record_gateway_provider_list_quote(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_gateway_provider(arr[0]),
      dco_decode_list_quote(arr[1]),
    );
  }

  @protected
  (OutPoint, String, int) dco_decode_record_out_point_string_usize(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_out_point(arr[0]),
      dco_decode_String(arr[1]),
      dco_decode_usize(arr[2]),
    );
  }

  @protected
  (String, Network) dco_decode_record_string_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_network(arr[1]),
    );
  }

  @protected
  (String, TransactionDetails) dco_decode_record_string_transaction_details(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_transaction_details(arr[1]),
    );
  }

  @protected
  Script dco_decode_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Script(
      internal: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  ScriptAmount dco_decode_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ScriptAmount(
      script: dco_decode_script(arr[0]),
      amount: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SignOptions dco_decode_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return SignOptions(
      isMultiSig: dco_decode_bool(arr[0]),
      trustWitnessUtxo: dco_decode_bool(arr[1]),
      assumeHeight: dco_decode_opt_box_autoadd_u_32(arr[2]),
      allowAllSighashes: dco_decode_bool(arr[3]),
      removePartialSigs: dco_decode_bool(arr[4]),
      tryFinalize: dco_decode_bool(arr[5]),
      signWithTapInternalKey: dco_decode_bool(arr[6]),
      allowGrinding: dco_decode_bool(arr[7]),
    );
  }

  @protected
  SqliteDbConfiguration dco_decode_sqlite_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SqliteDbConfiguration(
      path: dco_decode_String(arr[0]),
    );
  }

  @protected
  TransactionDetails dco_decode_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TransactionDetails(
      serializedTx: dco_decode_opt_String(arr[0]),
      txid: dco_decode_String(arr[1]),
      received: dco_decode_u_64(arr[2]),
      sent: dco_decode_u_64(arr[3]),
      fee: dco_decode_opt_box_autoadd_u_64(arr[4]),
      confirmationTime: dco_decode_opt_box_autoadd_block_time(arr[5]),
    );
  }

  @protected
  TxIn dco_decode_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxIn(
      previousOutput: dco_decode_out_point(arr[0]),
      scriptSig: dco_decode_script(arr[1]),
      sequence: dco_decode_u_32(arr[2]),
      witness: dco_decode_list_list_prim_u_8_strict(arr[3]),
    );
  }

  @protected
  TxOut dco_decode_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_script(arr[1]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  WalletAccountEvent dco_decode_wallet_account_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletAccountEvent(
      id: dco_decode_String(arr[0]),
      action: dco_decode_u_32(arr[1]),
      walletAccount: dco_decode_opt_box_autoadd_api_wallet_account(arr[2]),
    );
  }

  @protected
  WalletEvent dco_decode_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletEvent(
      id: dco_decode_String(arr[0]),
      action: dco_decode_u_32(arr[1]),
      wallet: dco_decode_opt_box_autoadd_api_wallet(arr[2]),
    );
  }

  @protected
  WalletKeyEvent dco_decode_wallet_key_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletKeyEvent(
      id: dco_decode_String(arr[0]),
      action: dco_decode_u_32(arr[1]),
      walletKey: dco_decode_opt_box_autoadd_api_wallet_key(arr[2]),
    );
  }

  @protected
  WalletSettingsEvent dco_decode_wallet_settings_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletSettingsEvent(
      id: dco_decode_String(arr[0]),
      action: dco_decode_u_32(arr[1]),
      walletSettings: dco_decode_opt_box_autoadd_api_wallet_settings(arr[2]),
    );
  }

  @protected
  WalletTransaction dco_decode_wallet_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return WalletTransaction(
      id: dco_decode_String(arr[0]),
      walletId: dco_decode_String(arr[1]),
      walletAccountId: dco_decode_opt_String(arr[2]),
      label: dco_decode_opt_String(arr[3]),
      transactionId: dco_decode_String(arr[4]),
      transactionTime: dco_decode_String(arr[5]),
      exchangeRate: dco_decode_opt_box_autoadd_proton_exchange_rate(arr[6]),
      hashedTransactionId: dco_decode_opt_String(arr[7]),
      subject: dco_decode_opt_String(arr[8]),
      body: dco_decode_opt_String(arr[9]),
      sender: dco_decode_opt_String(arr[10]),
      tolist: dco_decode_opt_String(arr[11]),
    );
  }

  @protected
  WalletTransactionEvent dco_decode_wallet_transaction_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletTransactionEvent(
      id: dco_decode_String(arr[0]),
      action: dco_decode_u_32(arr[1]),
      walletTransaction: dco_decode_opt_box_autoadd_wallet_transaction(arr[2]),
    );
  }

  @protected
  WordCount dco_decode_word_count(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WordCount.values[raw as int];
  }

  @protected
  AddressBalance
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressBalance.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AddressClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ApiTx
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ApiTx.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcProtonApiService
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcProtonApiService.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkWalletManager
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkWalletManager.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BitcoinAddressClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BitcoinAddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ContactsClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ContactsClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EmailIntegrationClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EmailIntegrationClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExchangeRateClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExchangeRateClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OnRampGatewayClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OnRampGatewayClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonApiService
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonApiService.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonEmailAddressClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonEmailAddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonUsersClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonUsersClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonWalletAuthStore
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonWalletAuthStore.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SettingsClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SettingsClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TransactionClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TransactionClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WalletClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WalletClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkTransaction
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkTransaction.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonApiService
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonApiService.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonWalletAuthStore
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonWalletAuthStore.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AddressClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkWalletManager
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkWalletManager.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BitcoinAddressClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BitcoinAddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ContactsClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ContactsClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EmailIntegrationClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EmailIntegrationClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExchangeRateClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExchangeRateClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OnRampGatewayClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OnRampGatewayClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonApiService
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonApiService.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonEmailAddressClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonEmailAddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonWalletAuthStore
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonWalletAuthStore.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SettingsClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SettingsClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TransactionClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TransactionClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WalletClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WalletClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_usize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  Map<GatewayProvider, List<ApiCountry>>
      sse_decode_Map_gateway_provider_list_api_country(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_list_record_gateway_provider_list_api_country(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<GatewayProvider, List<ApiCountryFiatCurrency>>
      sse_decode_Map_gateway_provider_list_api_country_fiat_currency(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_list_record_gateway_provider_list_api_country_fiat_currency(
            deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<GatewayProvider, List<PaymentMethod>>
      sse_decode_Map_gateway_provider_list_payment_method(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_gateway_provider_list_payment_method(
        deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<GatewayProvider, List<Quote>> sse_decode_Map_gateway_provider_list_quote(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_list_record_gateway_provider_list_quote(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AddressBalance
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressBalance.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AddressClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ApiTx
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ApiTx.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcProtonApiService
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcProtonApiService.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkWalletManager
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkWalletManager.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BitcoinAddressClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BitcoinAddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ContactsClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ContactsClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EmailIntegrationClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EmailIntegrationClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExchangeRateClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExchangeRateClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OnRampGatewayClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OnRampGatewayClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonApiService
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonApiService.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonEmailAddressClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonEmailAddressClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonUsersClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonUsersClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtonWalletAuthStore
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtonWalletAuthStore.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SettingsClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SettingsClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TransactionClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TransactionClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WalletClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WalletClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BdkTransaction
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkTransaction.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressIndex sse_decode_address_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AddressIndex_New();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Peek(index: var_index);
      case 3:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Reset(index: var_index);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AddressInfo sse_decode_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_address = sse_decode_String(deserializer);
    return AddressInfo(index: var_index, address: var_address);
  }

  @protected
  AllKeyAddressKey sse_decode_all_key_address_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_flags = sse_decode_u_32(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    var var_source = sse_decode_u_32(deserializer);
    return AllKeyAddressKey(
        flags: var_flags, publicKey: var_publicKey, source: var_source);
  }

  @protected
  Api sse_decode_api(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Api();
  }

  @protected
  ApiContactEmails sse_decode_api_contact_emails(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_email = sse_decode_String(deserializer);
    var var_canonicalEmail = sse_decode_String(deserializer);
    var var_isProton = sse_decode_u_32(deserializer);
    return ApiContactEmails(
        id: var_id,
        name: var_name,
        email: var_email,
        canonicalEmail: var_canonicalEmail,
        isProton: var_isProton);
  }

  @protected
  ApiCountry sse_decode_api_country(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_code = sse_decode_String(deserializer);
    var var_fiatCurrency = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return ApiCountry(
        code: var_code, fiatCurrency: var_fiatCurrency, name: var_name);
  }

  @protected
  ApiCountryFiatCurrency sse_decode_api_country_fiat_currency(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_symbol = sse_decode_String(deserializer);
    return ApiCountryFiatCurrency(name: var_name, symbol: var_symbol);
  }

  @protected
  ApiEmailAddress sse_decode_api_email_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_email = sse_decode_String(deserializer);
    return ApiEmailAddress(id: var_id, email: var_email);
  }

  @protected
  ApiWallet sse_decode_api_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_isImported = sse_decode_u_8(deserializer);
    var var_priority = sse_decode_u_8(deserializer);
    var var_type = sse_decode_u_8(deserializer);
    var var_hasPassphrase = sse_decode_u_8(deserializer);
    var var_status = sse_decode_u_8(deserializer);
    var var_mnemonic = sse_decode_opt_String(deserializer);
    var var_fingerprint = sse_decode_opt_String(deserializer);
    var var_publicKey = sse_decode_opt_String(deserializer);
    return ApiWallet(
        id: var_id,
        name: var_name,
        isImported: var_isImported,
        priority: var_priority,
        type: var_type,
        hasPassphrase: var_hasPassphrase,
        status: var_status,
        mnemonic: var_mnemonic,
        fingerprint: var_fingerprint,
        publicKey: var_publicKey);
  }

  @protected
  ApiWalletAccount sse_decode_api_wallet_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_walletId = sse_decode_String(deserializer);
    var var_fiatCurrency = sse_decode_fiat_currency(deserializer);
    var var_derivationPath = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_scriptType = sse_decode_u_8(deserializer);
    var var_addresses = sse_decode_list_api_email_address(deserializer);
    return ApiWalletAccount(
        id: var_id,
        walletId: var_walletId,
        fiatCurrency: var_fiatCurrency,
        derivationPath: var_derivationPath,
        label: var_label,
        scriptType: var_scriptType,
        addresses: var_addresses);
  }

  @protected
  ApiWalletBitcoinAddress sse_decode_api_wallet_bitcoin_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_walletId = sse_decode_String(deserializer);
    var var_walletAccountId = sse_decode_String(deserializer);
    var var_fetched = sse_decode_u_8(deserializer);
    var var_used = sse_decode_u_8(deserializer);
    var var_bitcoinAddress = sse_decode_opt_String(deserializer);
    var var_bitcoinAddressSignature = sse_decode_opt_String(deserializer);
    var var_bitcoinAddressIndex = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ApiWalletBitcoinAddress(
        id: var_id,
        walletId: var_walletId,
        walletAccountId: var_walletAccountId,
        fetched: var_fetched,
        used: var_used,
        bitcoinAddress: var_bitcoinAddress,
        bitcoinAddressSignature: var_bitcoinAddressSignature,
        bitcoinAddressIndex: var_bitcoinAddressIndex);
  }

  @protected
  ApiWalletData sse_decode_api_wallet_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_wallet = sse_decode_api_wallet(deserializer);
    var var_walletKey = sse_decode_api_wallet_key(deserializer);
    var var_walletSettings = sse_decode_api_wallet_settings(deserializer);
    return ApiWalletData(
        wallet: var_wallet,
        walletKey: var_walletKey,
        walletSettings: var_walletSettings);
  }

  @protected
  ApiWalletKey sse_decode_api_wallet_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_walletId = sse_decode_String(deserializer);
    var var_userKeyId = sse_decode_String(deserializer);
    var var_walletKey = sse_decode_String(deserializer);
    var var_walletKeySignature = sse_decode_String(deserializer);
    return ApiWalletKey(
        walletId: var_walletId,
        userKeyId: var_userKeyId,
        walletKey: var_walletKey,
        walletKeySignature: var_walletKeySignature);
  }

  @protected
  ApiWalletSettings sse_decode_api_wallet_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_walletId = sse_decode_String(deserializer);
    var var_hideAccounts = sse_decode_u_8(deserializer);
    var var_invoiceDefaultDescription = sse_decode_opt_String(deserializer);
    var var_invoiceExpirationTime = sse_decode_u_64(deserializer);
    var var_maxChannelOpeningFee = sse_decode_u_64(deserializer);
    return ApiWalletSettings(
        walletId: var_walletId,
        hideAccounts: var_hideAccounts,
        invoiceDefaultDescription: var_invoiceDefaultDescription,
        invoiceExpirationTime: var_invoiceExpirationTime,
        maxChannelOpeningFee: var_maxChannelOpeningFee);
  }

  @protected
  ApiWalletUserSettings sse_decode_api_wallet_user_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinUnit = sse_decode_bitcoin_unit(deserializer);
    var var_fiatCurrency = sse_decode_fiat_currency(deserializer);
    var var_hideEmptyUsedAddresses = sse_decode_u_8(deserializer);
    var var_showWalletRecovery = sse_decode_u_8(deserializer);
    var var_twoFactorAmountThreshold =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return ApiWalletUserSettings(
        bitcoinUnit: var_bitcoinUnit,
        fiatCurrency: var_fiatCurrency,
        hideEmptyUsedAddresses: var_hideEmptyUsedAddresses,
        showWalletRecovery: var_showWalletRecovery,
        twoFactorAmountThreshold: var_twoFactorAmountThreshold);
  }

  @protected
  AuthCredential sse_decode_auth_credential(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sessionId = sse_decode_String(deserializer);
    var var_userId = sse_decode_String(deserializer);
    var var_accessToken = sse_decode_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_eventId = sse_decode_String(deserializer);
    var var_userMail = sse_decode_String(deserializer);
    var var_userName = sse_decode_String(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_scops = sse_decode_list_String(deserializer);
    var var_userKeyId = sse_decode_String(deserializer);
    var var_userPrivateKey = sse_decode_String(deserializer);
    var var_userPassphrase = sse_decode_String(deserializer);
    return AuthCredential(
        sessionId: var_sessionId,
        userId: var_userId,
        accessToken: var_accessToken,
        refreshToken: var_refreshToken,
        eventId: var_eventId,
        userMail: var_userMail,
        userName: var_userName,
        displayName: var_displayName,
        scops: var_scops,
        userKeyId: var_userKeyId,
        userPrivateKey: var_userPrivateKey,
        userPassphrase: var_userPassphrase);
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_immature = sse_decode_u_64(deserializer);
    var var_trustedPending = sse_decode_u_64(deserializer);
    var var_untrustedPending = sse_decode_u_64(deserializer);
    var var_confirmed = sse_decode_u_64(deserializer);
    var var_spendable = sse_decode_u_64(deserializer);
    var var_total = sse_decode_u_64(deserializer);
    return Balance(
        immature: var_immature,
        trustedPending: var_trustedPending,
        untrustedPending: var_untrustedPending,
        confirmed: var_confirmed,
        spendable: var_spendable,
        total: var_total);
  }

  @protected
  BitcoinAddress sse_decode_bitcoin_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinAddress = sse_decode_String(deserializer);
    var var_bitcoinAddressSignature = sse_decode_String(deserializer);
    var var_bitcoinAddressIndex = sse_decode_u_64(deserializer);
    return BitcoinAddress(
        bitcoinAddress: var_bitcoinAddress,
        bitcoinAddressSignature: var_bitcoinAddressSignature,
        bitcoinAddressIndex: var_bitcoinAddressIndex);
  }

  @protected
  BitcoinUnit sse_decode_bitcoin_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BitcoinUnit.values[inner];
  }

  @protected
  BlockTime sse_decode_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    return BlockTime(height: var_height, timestamp: var_timestamp);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddressIndex sse_decode_box_autoadd_address_index(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_index(deserializer));
  }

  @protected
  ApiContactEmails sse_decode_box_autoadd_api_contact_emails(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_contact_emails(deserializer));
  }

  @protected
  ApiWallet sse_decode_box_autoadd_api_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_wallet(deserializer));
  }

  @protected
  ApiWalletAccount sse_decode_box_autoadd_api_wallet_account(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_wallet_account(deserializer));
  }

  @protected
  ApiWalletKey sse_decode_box_autoadd_api_wallet_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_wallet_key(deserializer));
  }

  @protected
  ApiWalletSettings sse_decode_box_autoadd_api_wallet_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_wallet_settings(deserializer));
  }

  @protected
  ApiWalletUserSettings sse_decode_box_autoadd_api_wallet_user_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_api_wallet_user_settings(deserializer));
  }

  @protected
  BitcoinAddress sse_decode_box_autoadd_bitcoin_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bitcoin_address(deserializer));
  }

  @protected
  BlockTime sse_decode_box_autoadd_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_block_time(deserializer));
  }

  @protected
  CreateWalletAccountReq sse_decode_box_autoadd_create_wallet_account_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_create_wallet_account_req(deserializer));
  }

  @protected
  CreateWalletReq sse_decode_box_autoadd_create_wallet_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_create_wallet_req(deserializer));
  }

  @protected
  DatabaseConfig sse_decode_box_autoadd_database_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_database_config(deserializer));
  }

  @protected
  EsploraConfig sse_decode_box_autoadd_esplora_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_esplora_config(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  GatewayProvider sse_decode_box_autoadd_gateway_provider(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gateway_provider(deserializer));
  }

  @protected
  LocalUtxo sse_decode_box_autoadd_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_local_utxo(deserializer));
  }

  @protected
  MyTestObject sse_decode_box_autoadd_my_test_object(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_my_test_object(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PaymentMethod sse_decode_box_autoadd_payment_method(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_method(deserializer));
  }

  @protected
  ProtonExchangeRate sse_decode_box_autoadd_proton_exchange_rate(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_proton_exchange_rate(deserializer));
  }

  @protected
  PsbtSigHashType sse_decode_box_autoadd_psbt_sig_hash_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_psbt_sig_hash_type(deserializer));
  }

  @protected
  RbfValue sse_decode_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rbf_value(deserializer));
  }

  @protected
  (OutPoint, String, int) sse_decode_box_autoadd_record_out_point_string_usize(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_record_out_point_string_usize(deserializer));
  }

  @protected
  Script sse_decode_box_autoadd_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_script(deserializer));
  }

  @protected
  SignOptions sse_decode_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_options(deserializer));
  }

  @protected
  SqliteDbConfiguration sse_decode_box_autoadd_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sqlite_db_configuration(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  WalletTransaction sse_decode_box_autoadd_wallet_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wallet_transaction(deserializer));
  }

  @protected
  BridgeError sse_decode_bridge_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return BridgeError_AndromedaApi(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return BridgeError_Generic(var_field0);
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return BridgeError_MuonSession(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChangeSpendPolicy sse_decode_change_spend_policy(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChangeSpendPolicy.values[inner];
  }

  @protected
  ChildSession sse_decode_child_session(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sessionId = sse_decode_String(deserializer);
    var var_accessToken = sse_decode_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_scopes = sse_decode_list_String(deserializer);
    return ChildSession(
        sessionId: var_sessionId,
        accessToken: var_accessToken,
        refreshToken: var_refreshToken,
        scopes: var_scopes);
  }

  @protected
  ContactEmailEvent sse_decode_contact_email_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_action = sse_decode_u_32(deserializer);
    var var_contactEmail =
        sse_decode_opt_box_autoadd_api_contact_emails(deserializer);
    return ContactEmailEvent(
        id: var_id, action: var_action, contactEmail: var_contactEmail);
  }

  @protected
  CreateWalletAccountReq sse_decode_create_wallet_account_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_derivationPath = sse_decode_String(deserializer);
    var var_scriptType = sse_decode_u_8(deserializer);
    return CreateWalletAccountReq(
        label: var_label,
        derivationPath: var_derivationPath,
        scriptType: var_scriptType);
  }

  @protected
  CreateWalletReq sse_decode_create_wallet_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_isImported = sse_decode_u_8(deserializer);
    var var_type = sse_decode_u_8(deserializer);
    var var_hasPassphrase = sse_decode_u_8(deserializer);
    var var_userKeyId = sse_decode_String(deserializer);
    var var_walletKey = sse_decode_String(deserializer);
    var var_mnemonic = sse_decode_opt_String(deserializer);
    var var_publicKey = sse_decode_opt_String(deserializer);
    var var_fingerprint = sse_decode_opt_String(deserializer);
    var var_walletKeySignature = sse_decode_String(deserializer);
    return CreateWalletReq(
        name: var_name,
        isImported: var_isImported,
        type: var_type,
        hasPassphrase: var_hasPassphrase,
        userKeyId: var_userKeyId,
        walletKey: var_walletKey,
        mnemonic: var_mnemonic,
        publicKey: var_publicKey,
        fingerprint: var_fingerprint,
        walletKeySignature: var_walletKeySignature);
  }

  @protected
  DatabaseConfig sse_decode_database_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        var var_config =
            sse_decode_box_autoadd_sqlite_db_configuration(deserializer);
        return DatabaseConfig_Sqlite(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EmailIntegrationBitcoinAddress sse_decode_email_integration_bitcoin_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinAddress = sse_decode_opt_String(deserializer);
    var var_bitcoinAddressSignature = sse_decode_opt_String(deserializer);
    return EmailIntegrationBitcoinAddress(
        bitcoinAddress: var_bitcoinAddress,
        bitcoinAddressSignature: var_bitcoinAddressSignature);
  }

  @protected
  Error sse_decode_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
        return Error_InvalidU32Bytes(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Generic(var_field0);
      case 2:
        return Error_ScriptDoesntHaveAddressForm();
      case 3:
        return Error_NoRecipients();
      case 4:
        return Error_NoUtxosSelected();
      case 5:
        var var_field0 = sse_decode_usize(deserializer);
        return Error_OutputBelowDustLimit(var_field0);
      case 6:
        var var_needed = sse_decode_u_64(deserializer);
        var var_available = sse_decode_u_64(deserializer);
        return Error_InsufficientFunds(
            needed: var_needed, available: var_available);
      case 7:
        return Error_BnBTotalTriesExceeded();
      case 8:
        return Error_BnBNoExactMatch();
      case 9:
        return Error_UnknownUtxo();
      case 10:
        return Error_TransactionNotFound();
      case 11:
        return Error_TransactionConfirmed();
      case 12:
        return Error_IrreplaceableTransaction();
      case 13:
        var var_required = sse_decode_f_32(deserializer);
        return Error_FeeRateTooLow(required: var_required);
      case 14:
        var var_required = sse_decode_u_64(deserializer);
        return Error_FeeTooLow(required: var_required);
      case 15:
        return Error_FeeRateUnavailable();
      case 16:
        var var_field0 = sse_decode_String(deserializer);
        return Error_MissingKeyOrigin(var_field0);
      case 17:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Key(var_field0);
      case 18:
        return Error_ChecksumMismatch();
      case 19:
        var var_field0 = sse_decode_keychain_kind(deserializer);
        return Error_SpendingPolicyRequired(var_field0);
      case 20:
        var var_field0 = sse_decode_String(deserializer);
        return Error_InvalidPolicyPathError(var_field0);
      case 21:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Signer(var_field0);
      case 22:
        var var_requested = sse_decode_network(deserializer);
        var var_found = sse_decode_network(deserializer);
        return Error_InvalidNetwork(requested: var_requested, found: var_found);
      case 23:
        var var_field0 = sse_decode_box_autoadd_out_point(deserializer);
        return Error_InvalidOutpoint(var_field0);
      case 24:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Descriptor(var_field0);
      case 25:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Encode(var_field0);
      case 26:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Miniscript(var_field0);
      case 27:
        var var_field0 = sse_decode_String(deserializer);
        return Error_MiniscriptPsbt(var_field0);
      case 28:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Bip32(var_field0);
      case 29:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Secp256k1(var_field0);
      case 30:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Json(var_field0);
      case 31:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Hex(var_field0);
      case 32:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Psbt(var_field0);
      case 33:
        var var_field0 = sse_decode_String(deserializer);
        return Error_PsbtParse(var_field0);
      case 34:
        var var_field0 = sse_decode_usize(deserializer);
        var var_field1 = sse_decode_usize(deserializer);
        return Error_MissingCachedScripts(var_field0, var_field1);
      case 35:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Electrum(var_field0);
      case 36:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Esplora(var_field0);
      case 37:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Sled(var_field0);
      case 38:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Rpc(var_field0);
      case 39:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Rusqlite(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EsploraConfig sse_decode_esplora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseUrl = sse_decode_String(deserializer);
    var var_proxy = sse_decode_opt_String(deserializer);
    var var_concurrency = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_64(deserializer);
    return EsploraConfig(
        baseUrl: var_baseUrl,
        proxy: var_proxy,
        concurrency: var_concurrency,
        stopGap: var_stopGap,
        timeout: var_timeout);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  FiatCurrency sse_decode_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FiatCurrency.values[inner];
  }

  @protected
  GatewayProvider sse_decode_gateway_provider(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return GatewayProvider.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  int sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt64();
  }

  @protected
  KeychainKind sse_decode_keychain_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return KeychainKind.values[inner];
  }

  @protected
  Level sse_decode_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Level.values[inner];
  }

  @protected
  List<ApiTx>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiTx>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<AllKeyAddressKey> sse_decode_list_all_key_address_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AllKeyAddressKey>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_all_key_address_key(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiContactEmails> sse_decode_list_api_contact_emails(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiContactEmails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_contact_emails(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiCountry> sse_decode_list_api_country(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiCountry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_country(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiCountryFiatCurrency> sse_decode_list_api_country_fiat_currency(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiCountryFiatCurrency>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_country_fiat_currency(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiEmailAddress> sse_decode_list_api_email_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiEmailAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_email_address(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiWalletAccount> sse_decode_list_api_wallet_account(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiWalletAccount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_wallet_account(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiWalletBitcoinAddress> sse_decode_list_api_wallet_bitcoin_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiWalletBitcoinAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_wallet_bitcoin_address(deserializer));
    }
    return ans_;
  }

  @protected
  List<ApiWalletData> sse_decode_list_api_wallet_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ApiWalletData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_api_wallet_data(deserializer));
    }
    return ans_;
  }

  @protected
  List<BitcoinAddress> sse_decode_list_bitcoin_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BitcoinAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bitcoin_address(deserializer));
    }
    return ans_;
  }

  @protected
  List<ContactEmailEvent> sse_decode_list_contact_email_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ContactEmailEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_contact_email_event(deserializer));
    }
    return ans_;
  }

  @protected
  List<Uint8List> sse_decode_list_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Uint8List>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_prim_u_8_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalUtxo> sse_decode_list_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalUtxo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_utxo(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutPoint> sse_decode_list_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_out_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentMethod> sse_decode_list_payment_method(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentMethod>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_method(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ProtonAddress> sse_decode_list_proton_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProtonAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_proton_address(deserializer));
    }
    return ans_;
  }

  @protected
  List<ProtonAddressKey> sse_decode_list_proton_address_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProtonAddressKey>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_proton_address_key(deserializer));
    }
    return ans_;
  }

  @protected
  List<ProtonEvent> sse_decode_list_proton_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProtonEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_proton_event(deserializer));
    }
    return ans_;
  }

  @protected
  List<Quote> sse_decode_list_quote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Quote>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_quote(deserializer));
    }
    return ans_;
  }

  @protected
  List<(GatewayProvider, List<ApiCountry>)>
      sse_decode_list_record_gateway_provider_list_api_country(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(GatewayProvider, List<ApiCountry>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_record_gateway_provider_list_api_country(deserializer));
    }
    return ans_;
  }

  @protected
  List<(GatewayProvider, List<ApiCountryFiatCurrency>)>
      sse_decode_list_record_gateway_provider_list_api_country_fiat_currency(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(GatewayProvider, List<ApiCountryFiatCurrency>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_record_gateway_provider_list_api_country_fiat_currency(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<(GatewayProvider, List<PaymentMethod>)>
      sse_decode_list_record_gateway_provider_list_payment_method(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(GatewayProvider, List<PaymentMethod>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_record_gateway_provider_list_payment_method(deserializer));
    }
    return ans_;
  }

  @protected
  List<(GatewayProvider, List<Quote>)>
      sse_decode_list_record_gateway_provider_list_quote(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(GatewayProvider, List<Quote>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_gateway_provider_list_quote(deserializer));
    }
    return ans_;
  }

  @protected
  List<ScriptAmount> sse_decode_list_script_amount(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScriptAmount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_script_amount(deserializer));
    }
    return ans_;
  }

  @protected
  List<TransactionDetails> sse_decode_list_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TransactionDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxIn> sse_decode_list_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxIn>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_in(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxOut> sse_decode_list_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_out(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletAccountEvent> sse_decode_list_wallet_account_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletAccountEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_account_event(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletEvent> sse_decode_list_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_event(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletKeyEvent> sse_decode_list_wallet_key_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletKeyEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_key_event(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletSettingsEvent> sse_decode_list_wallet_settings_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletSettingsEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_settings_event(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletTransaction> sse_decode_list_wallet_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletTransaction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_transaction(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletTransactionEvent> sse_decode_list_wallet_transaction_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletTransactionEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_transaction_event(deserializer));
    }
    return ans_;
  }

  @protected
  LocalUtxo sse_decode_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_tx_out(deserializer);
    var var_isSpent = sse_decode_bool(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    return LocalUtxo(
        outpoint: var_outpoint,
        txout: var_txout,
        isSpent: var_isSpent,
        keychain: var_keychain);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timeMillis = sse_decode_i_64(deserializer);
    var var_msg = sse_decode_String(deserializer);
    var var_logLevel = sse_decode_level(deserializer);
    var var_lbl = sse_decode_String(deserializer);
    return LogEntry(
        timeMillis: var_timeMillis,
        msg: var_msg,
        logLevel: var_logLevel,
        lbl: var_lbl);
  }

  @protected
  MyTestObject sse_decode_my_test_object(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MyTestObject();
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiContactEmails? sse_decode_opt_box_autoadd_api_contact_emails(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_contact_emails(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiWallet? sse_decode_opt_box_autoadd_api_wallet(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_wallet(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiWalletAccount? sse_decode_opt_box_autoadd_api_wallet_account(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_wallet_account(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiWalletKey? sse_decode_opt_box_autoadd_api_wallet_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_wallet_key(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiWalletSettings? sse_decode_opt_box_autoadd_api_wallet_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_wallet_settings(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ApiWalletUserSettings? sse_decode_opt_box_autoadd_api_wallet_user_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_api_wallet_user_settings(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BlockTime? sse_decode_opt_box_autoadd_block_time(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_block_time(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GatewayProvider? sse_decode_opt_box_autoadd_gateway_provider(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_gateway_provider(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentMethod? sse_decode_opt_box_autoadd_payment_method(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_method(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ProtonExchangeRate? sse_decode_opt_box_autoadd_proton_exchange_rate(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_proton_exchange_rate(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PsbtSigHashType? sse_decode_opt_box_autoadd_psbt_sig_hash_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_psbt_sig_hash_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RbfValue? sse_decode_opt_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rbf_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (OutPoint, String, int)?
      sse_decode_opt_box_autoadd_record_out_point_string_usize(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_record_out_point_string_usize(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Script? sse_decode_opt_box_autoadd_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_script(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SignOptions? sse_decode_opt_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sign_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  WalletTransaction? sse_decode_opt_box_autoadd_wallet_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_wallet_transaction(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ContactEmailEvent>? sse_decode_opt_list_contact_email_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_contact_email_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ProtonAddressKey>? sse_decode_opt_list_proton_address_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_proton_address_key(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<WalletAccountEvent>? sse_decode_opt_list_wallet_account_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_wallet_account_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<WalletEvent>? sse_decode_opt_list_wallet_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_wallet_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<WalletKeyEvent>? sse_decode_opt_list_wallet_key_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_wallet_key_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<WalletSettingsEvent>? sse_decode_opt_list_wallet_settings_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_wallet_settings_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<WalletTransactionEvent>? sse_decode_opt_list_wallet_transaction_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_wallet_transaction_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  PaymentMethod sse_decode_payment_method(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentMethod.values[inner];
  }

  @protected
  ProtonAddress sse_decode_proton_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_domainId = sse_decode_String(deserializer);
    var var_email = sse_decode_String(deserializer);
    var var_status = sse_decode_u_32(deserializer);
    var var_type = sse_decode_u_32(deserializer);
    var var_receive = sse_decode_u_32(deserializer);
    var var_send = sse_decode_u_32(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_keys = sse_decode_opt_list_proton_address_key(deserializer);
    return ProtonAddress(
        id: var_id,
        domainId: var_domainId,
        email: var_email,
        status: var_status,
        type: var_type,
        receive: var_receive,
        send: var_send,
        displayName: var_displayName,
        keys: var_keys);
  }

  @protected
  ProtonAddressKey sse_decode_proton_address_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_version = sse_decode_u_32(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    var var_privateKey = sse_decode_opt_String(deserializer);
    var var_token = sse_decode_opt_String(deserializer);
    var var_signature = sse_decode_opt_String(deserializer);
    var var_primary = sse_decode_u_32(deserializer);
    var var_active = sse_decode_u_32(deserializer);
    var var_flags = sse_decode_u_32(deserializer);
    return ProtonAddressKey(
        id: var_id,
        version: var_version,
        publicKey: var_publicKey,
        privateKey: var_privateKey,
        token: var_token,
        signature: var_signature,
        primary: var_primary,
        active: var_active,
        flags: var_flags);
  }

  @protected
  ProtonEvent sse_decode_proton_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_code = sse_decode_u_16(deserializer);
    var var_eventId = sse_decode_String(deserializer);
    var var_refresh = sse_decode_u_32(deserializer);
    var var_more = sse_decode_u_32(deserializer);
    var var_contactEmailEvents =
        sse_decode_opt_list_contact_email_event(deserializer);
    var var_walletEvents = sse_decode_opt_list_wallet_event(deserializer);
    var var_walletAccountEvents =
        sse_decode_opt_list_wallet_account_event(deserializer);
    var var_walletKeyEvents =
        sse_decode_opt_list_wallet_key_event(deserializer);
    var var_walletSettingEvents =
        sse_decode_opt_list_wallet_settings_event(deserializer);
    var var_walletTransactionEvents =
        sse_decode_opt_list_wallet_transaction_event(deserializer);
    var var_walletUserSettings =
        sse_decode_opt_box_autoadd_api_wallet_user_settings(deserializer);
    return ProtonEvent(
        code: var_code,
        eventId: var_eventId,
        refresh: var_refresh,
        more: var_more,
        contactEmailEvents: var_contactEmailEvents,
        walletEvents: var_walletEvents,
        walletAccountEvents: var_walletAccountEvents,
        walletKeyEvents: var_walletKeyEvents,
        walletSettingEvents: var_walletSettingEvents,
        walletTransactionEvents: var_walletTransactionEvents,
        walletUserSettings: var_walletUserSettings);
  }

  @protected
  ProtonExchangeRate sse_decode_proton_exchange_rate(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_bitcoinUnit = sse_decode_bitcoin_unit(deserializer);
    var var_fiatCurrency = sse_decode_fiat_currency(deserializer);
    var var_exchangeRateTime = sse_decode_String(deserializer);
    var var_exchangeRate = sse_decode_u_64(deserializer);
    var var_cents = sse_decode_u_64(deserializer);
    return ProtonExchangeRate(
        id: var_id,
        bitcoinUnit: var_bitcoinUnit,
        fiatCurrency: var_fiatCurrency,
        exchangeRateTime: var_exchangeRateTime,
        exchangeRate: var_exchangeRate,
        cents: var_cents);
  }

  @protected
  PsbtSigHashType sse_decode_psbt_sig_hash_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inner = sse_decode_u_32(deserializer);
    return PsbtSigHashType(inner: var_inner);
  }

  @protected
  Quote sse_decode_quote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinAmount = sse_decode_String(deserializer);
    var var_fiatAmount = sse_decode_String(deserializer);
    var var_fiatCurrencySymbol = sse_decode_fiat_currency(deserializer);
    var var_networkFee = sse_decode_String(deserializer);
    var var_paymentGatewayFee = sse_decode_String(deserializer);
    var var_paymentMethod = sse_decode_payment_method(deserializer);
    return Quote(
        bitcoinAmount: var_bitcoinAmount,
        fiatAmount: var_fiatAmount,
        fiatCurrencySymbol: var_fiatCurrencySymbol,
        networkFee: var_networkFee,
        paymentGatewayFee: var_paymentGatewayFee,
        paymentMethod: var_paymentMethod);
  }

  @protected
  RbfValue sse_decode_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return RbfValue_Value(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (GatewayProvider, List<ApiCountry>)
      sse_decode_record_gateway_provider_list_api_country(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_gateway_provider(deserializer);
    var var_field1 = sse_decode_list_api_country(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (GatewayProvider, List<ApiCountryFiatCurrency>)
      sse_decode_record_gateway_provider_list_api_country_fiat_currency(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_gateway_provider(deserializer);
    var var_field1 = sse_decode_list_api_country_fiat_currency(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (GatewayProvider, List<PaymentMethod>)
      sse_decode_record_gateway_provider_list_payment_method(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_gateway_provider(deserializer);
    var var_field1 = sse_decode_list_payment_method(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (GatewayProvider, List<Quote>) sse_decode_record_gateway_provider_list_quote(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_gateway_provider(deserializer);
    var var_field1 = sse_decode_list_quote(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (OutPoint, String, int) sse_decode_record_out_point_string_usize(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_out_point(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    var var_field2 = sse_decode_usize(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  (String, Network) sse_decode_record_string_network(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_network(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, TransactionDetails) sse_decode_record_string_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_transaction_details(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  Script sse_decode_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_internal = sse_decode_list_prim_u_8_strict(deserializer);
    return Script(internal: var_internal);
  }

  @protected
  ScriptAmount sse_decode_script_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_script = sse_decode_script(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    return ScriptAmount(script: var_script, amount: var_amount);
  }

  @protected
  SignOptions sse_decode_sign_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isMultiSig = sse_decode_bool(deserializer);
    var var_trustWitnessUtxo = sse_decode_bool(deserializer);
    var var_assumeHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_allowAllSighashes = sse_decode_bool(deserializer);
    var var_removePartialSigs = sse_decode_bool(deserializer);
    var var_tryFinalize = sse_decode_bool(deserializer);
    var var_signWithTapInternalKey = sse_decode_bool(deserializer);
    var var_allowGrinding = sse_decode_bool(deserializer);
    return SignOptions(
        isMultiSig: var_isMultiSig,
        trustWitnessUtxo: var_trustWitnessUtxo,
        assumeHeight: var_assumeHeight,
        allowAllSighashes: var_allowAllSighashes,
        removePartialSigs: var_removePartialSigs,
        tryFinalize: var_tryFinalize,
        signWithTapInternalKey: var_signWithTapInternalKey,
        allowGrinding: var_allowGrinding);
  }

  @protected
  SqliteDbConfiguration sse_decode_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    return SqliteDbConfiguration(path: var_path);
  }

  @protected
  TransactionDetails sse_decode_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serializedTx = sse_decode_opt_String(deserializer);
    var var_txid = sse_decode_String(deserializer);
    var var_received = sse_decode_u_64(deserializer);
    var var_sent = sse_decode_u_64(deserializer);
    var var_fee = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_confirmationTime =
        sse_decode_opt_box_autoadd_block_time(deserializer);
    return TransactionDetails(
        serializedTx: var_serializedTx,
        txid: var_txid,
        received: var_received,
        sent: var_sent,
        fee: var_fee,
        confirmationTime: var_confirmationTime);
  }

  @protected
  TxIn sse_decode_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_previousOutput = sse_decode_out_point(deserializer);
    var var_scriptSig = sse_decode_script(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    var var_witness = sse_decode_list_list_prim_u_8_strict(deserializer);
    return TxIn(
        previousOutput: var_previousOutput,
        scriptSig: var_scriptSig,
        sequence: var_sequence,
        witness: var_witness);
  }

  @protected
  TxOut sse_decode_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_script(deserializer);
    return TxOut(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  WalletAccountEvent sse_decode_wallet_account_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_action = sse_decode_u_32(deserializer);
    var var_walletAccount =
        sse_decode_opt_box_autoadd_api_wallet_account(deserializer);
    return WalletAccountEvent(
        id: var_id, action: var_action, walletAccount: var_walletAccount);
  }

  @protected
  WalletEvent sse_decode_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_action = sse_decode_u_32(deserializer);
    var var_wallet = sse_decode_opt_box_autoadd_api_wallet(deserializer);
    return WalletEvent(id: var_id, action: var_action, wallet: var_wallet);
  }

  @protected
  WalletKeyEvent sse_decode_wallet_key_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_action = sse_decode_u_32(deserializer);
    var var_walletKey = sse_decode_opt_box_autoadd_api_wallet_key(deserializer);
    return WalletKeyEvent(
        id: var_id, action: var_action, walletKey: var_walletKey);
  }

  @protected
  WalletSettingsEvent sse_decode_wallet_settings_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_action = sse_decode_u_32(deserializer);
    var var_walletSettings =
        sse_decode_opt_box_autoadd_api_wallet_settings(deserializer);
    return WalletSettingsEvent(
        id: var_id, action: var_action, walletSettings: var_walletSettings);
  }

  @protected
  WalletTransaction sse_decode_wallet_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_walletId = sse_decode_String(deserializer);
    var var_walletAccountId = sse_decode_opt_String(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    var var_transactionId = sse_decode_String(deserializer);
    var var_transactionTime = sse_decode_String(deserializer);
    var var_exchangeRate =
        sse_decode_opt_box_autoadd_proton_exchange_rate(deserializer);
    var var_hashedTransactionId = sse_decode_opt_String(deserializer);
    var var_subject = sse_decode_opt_String(deserializer);
    var var_body = sse_decode_opt_String(deserializer);
    var var_sender = sse_decode_opt_String(deserializer);
    var var_tolist = sse_decode_opt_String(deserializer);
    return WalletTransaction(
        id: var_id,
        walletId: var_walletId,
        walletAccountId: var_walletAccountId,
        label: var_label,
        transactionId: var_transactionId,
        transactionTime: var_transactionTime,
        exchangeRate: var_exchangeRate,
        hashedTransactionId: var_hashedTransactionId,
        subject: var_subject,
        body: var_body,
        sender: var_sender,
        tolist: var_tolist);
  }

  @protected
  WalletTransactionEvent sse_decode_wallet_transaction_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_action = sse_decode_u_32(deserializer);
    var var_walletTransaction =
        sse_decode_opt_box_autoadd_wallet_transaction(deserializer);
    return WalletTransactionEvent(
        id: var_id,
        action: var_action,
        walletTransaction: var_walletTransaction);
  }

  @protected
  WordCount sse_decode_word_count(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WordCount.values[inner];
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
          AddressBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          AddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          ApiTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
          ArcProtonApiService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          BdkWalletManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          BitcoinAddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          ContactsClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          EmailIntegrationClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          EventClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          ExchangeRateClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          OnRampGatewayClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          ProtonApiService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          ProtonEmailAddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
          ProtonUsersClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          ProtonWalletAuthStore self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          SettingsClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          TransactionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          WalletClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
          BdkTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          ProtonApiService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          ProtonWalletAuthStore self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          AddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          BdkWalletManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          BitcoinAddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          ContactsClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          EmailIntegrationClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          EventClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          ExchangeRateClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          OnRampGatewayClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          ProtonApiService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          ProtonEmailAddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          ProtonWalletAuthStore self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          SettingsClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          TransactionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          WalletClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_child_session_Output_String(
      FutureOr<String> Function(ChildSession) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_child_session_Output_String(self), serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        PlatformPointerUtil.ptrToInt(encodeDartOpaque(
            self, portManager.dartHandlerPort, generalizedFrbRustBinding)),
        serializer);
  }

  @protected
  void sse_encode_Map_gateway_provider_list_api_country(
      Map<GatewayProvider, List<ApiCountry>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_gateway_provider_list_api_country(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_gateway_provider_list_api_country_fiat_currency(
      Map<GatewayProvider, List<ApiCountryFiatCurrency>> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_gateway_provider_list_api_country_fiat_currency(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_gateway_provider_list_payment_method(
      Map<GatewayProvider, List<PaymentMethod>> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_gateway_provider_list_payment_method(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_gateway_provider_list_quote(
      Map<GatewayProvider, List<Quote>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_gateway_provider_list_quote(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressBalance(
          AddressBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressClient(
          AddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          ApiTx self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcProtonAPIService(
          ArcProtonApiService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBdkWalletManager(
          BdkWalletManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressClient(
          BitcoinAddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerContactsClient(
          ContactsClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEmailIntegrationClient(
          EmailIntegrationClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventClient(
          EventClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExchangeRateClient(
          ExchangeRateClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnRampGatewayClient(
          OnRampGatewayClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonAPIService(
          ProtonApiService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonEmailAddressClient(
          ProtonEmailAddressClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonUsersClient(
          ProtonUsersClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtonWalletAuthStore(
          ProtonWalletAuthStore self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSettingsClient(
          SettingsClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransactionClient(
          TransactionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWalletClient(
          WalletClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerbdkTransaction(
          BdkTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_StreamSink_log_entry_Sse(
      RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
                decodeSuccessData: sse_decode_log_entry,
                decodeErrorData: null)),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_index(AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressIndex_New():
        sse_encode_i_32(0, serializer);
      case AddressIndex_LastUnused():
        sse_encode_i_32(1, serializer);
      case AddressIndex_Peek(index: final index):
        sse_encode_i_32(2, serializer);
        sse_encode_u_32(index, serializer);
      case AddressIndex_Reset(index: final index):
        sse_encode_i_32(3, serializer);
        sse_encode_u_32(index, serializer);
    }
  }

  @protected
  void sse_encode_address_info(AddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_all_key_address_key(
      AllKeyAddressKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.flags, serializer);
    sse_encode_String(self.publicKey, serializer);
    sse_encode_u_32(self.source, serializer);
  }

  @protected
  void sse_encode_api(Api self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_api_contact_emails(
      ApiContactEmails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.email, serializer);
    sse_encode_String(self.canonicalEmail, serializer);
    sse_encode_u_32(self.isProton, serializer);
  }

  @protected
  void sse_encode_api_country(ApiCountry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.code, serializer);
    sse_encode_String(self.fiatCurrency, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_api_country_fiat_currency(
      ApiCountryFiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.symbol, serializer);
  }

  @protected
  void sse_encode_api_email_address(
      ApiEmailAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.email, serializer);
  }

  @protected
  void sse_encode_api_wallet(ApiWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_u_8(self.isImported, serializer);
    sse_encode_u_8(self.priority, serializer);
    sse_encode_u_8(self.type, serializer);
    sse_encode_u_8(self.hasPassphrase, serializer);
    sse_encode_u_8(self.status, serializer);
    sse_encode_opt_String(self.mnemonic, serializer);
    sse_encode_opt_String(self.fingerprint, serializer);
    sse_encode_opt_String(self.publicKey, serializer);
  }

  @protected
  void sse_encode_api_wallet_account(
      ApiWalletAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.walletId, serializer);
    sse_encode_fiat_currency(self.fiatCurrency, serializer);
    sse_encode_String(self.derivationPath, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_u_8(self.scriptType, serializer);
    sse_encode_list_api_email_address(self.addresses, serializer);
  }

  @protected
  void sse_encode_api_wallet_bitcoin_address(
      ApiWalletBitcoinAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.walletId, serializer);
    sse_encode_String(self.walletAccountId, serializer);
    sse_encode_u_8(self.fetched, serializer);
    sse_encode_u_8(self.used, serializer);
    sse_encode_opt_String(self.bitcoinAddress, serializer);
    sse_encode_opt_String(self.bitcoinAddressSignature, serializer);
    sse_encode_opt_box_autoadd_u_64(self.bitcoinAddressIndex, serializer);
  }

  @protected
  void sse_encode_api_wallet_data(
      ApiWalletData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_wallet(self.wallet, serializer);
    sse_encode_api_wallet_key(self.walletKey, serializer);
    sse_encode_api_wallet_settings(self.walletSettings, serializer);
  }

  @protected
  void sse_encode_api_wallet_key(ApiWalletKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.walletId, serializer);
    sse_encode_String(self.userKeyId, serializer);
    sse_encode_String(self.walletKey, serializer);
    sse_encode_String(self.walletKeySignature, serializer);
  }

  @protected
  void sse_encode_api_wallet_settings(
      ApiWalletSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.walletId, serializer);
    sse_encode_u_8(self.hideAccounts, serializer);
    sse_encode_opt_String(self.invoiceDefaultDescription, serializer);
    sse_encode_u_64(self.invoiceExpirationTime, serializer);
    sse_encode_u_64(self.maxChannelOpeningFee, serializer);
  }

  @protected
  void sse_encode_api_wallet_user_settings(
      ApiWalletUserSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bitcoin_unit(self.bitcoinUnit, serializer);
    sse_encode_fiat_currency(self.fiatCurrency, serializer);
    sse_encode_u_8(self.hideEmptyUsedAddresses, serializer);
    sse_encode_u_8(self.showWalletRecovery, serializer);
    sse_encode_opt_box_autoadd_u_64(self.twoFactorAmountThreshold, serializer);
  }

  @protected
  void sse_encode_auth_credential(
      AuthCredential self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sessionId, serializer);
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.accessToken, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_String(self.eventId, serializer);
    sse_encode_String(self.userMail, serializer);
    sse_encode_String(self.userName, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_list_String(self.scops, serializer);
    sse_encode_String(self.userKeyId, serializer);
    sse_encode_String(self.userPrivateKey, serializer);
    sse_encode_String(self.userPassphrase, serializer);
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.immature, serializer);
    sse_encode_u_64(self.trustedPending, serializer);
    sse_encode_u_64(self.untrustedPending, serializer);
    sse_encode_u_64(self.confirmed, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.total, serializer);
  }

  @protected
  void sse_encode_bitcoin_address(
      BitcoinAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bitcoinAddress, serializer);
    sse_encode_String(self.bitcoinAddressSignature, serializer);
    sse_encode_u_64(self.bitcoinAddressIndex, serializer);
  }

  @protected
  void sse_encode_bitcoin_unit(BitcoinUnit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_block_time(BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address_index(
      AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_index(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_contact_emails(
      ApiContactEmails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_contact_emails(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_wallet(
      ApiWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_wallet(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_wallet_account(
      ApiWalletAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_wallet_account(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_wallet_key(
      ApiWalletKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_wallet_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_wallet_settings(
      ApiWalletSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_wallet_settings(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_api_wallet_user_settings(
      ApiWalletUserSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_api_wallet_user_settings(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bitcoin_address(
      BitcoinAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bitcoin_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_block_time(
      BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_create_wallet_account_req(
      CreateWalletAccountReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_create_wallet_account_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_create_wallet_req(
      CreateWalletReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_create_wallet_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_database_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_esplora_config(
      EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_esplora_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gateway_provider(
      GatewayProvider self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gateway_provider(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_local_utxo(
      LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_local_utxo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_my_test_object(
      MyTestObject self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_my_test_object(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_method(
      PaymentMethod self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_method(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_proton_exchange_rate(
      ProtonExchangeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_proton_exchange_rate(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_psbt_sig_hash_type(
      PsbtSigHashType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_psbt_sig_hash_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rbf_value(
      RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rbf_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_record_out_point_string_usize(
      (OutPoint, String, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_out_point_string_usize(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_script(Script self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_options(
      SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sqlite_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wallet_transaction(
      WalletTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wallet_transaction(self, serializer);
  }

  @protected
  void sse_encode_bridge_error(BridgeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BridgeError_AndromedaApi(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case BridgeError_Generic(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case BridgeError_MuonSession(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_change_spend_policy(
      ChangeSpendPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_child_session(ChildSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sessionId, serializer);
    sse_encode_String(self.accessToken, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_list_String(self.scopes, serializer);
  }

  @protected
  void sse_encode_contact_email_event(
      ContactEmailEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.action, serializer);
    sse_encode_opt_box_autoadd_api_contact_emails(
        self.contactEmail, serializer);
  }

  @protected
  void sse_encode_create_wallet_account_req(
      CreateWalletAccountReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.derivationPath, serializer);
    sse_encode_u_8(self.scriptType, serializer);
  }

  @protected
  void sse_encode_create_wallet_req(
      CreateWalletReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_8(self.isImported, serializer);
    sse_encode_u_8(self.type, serializer);
    sse_encode_u_8(self.hasPassphrase, serializer);
    sse_encode_String(self.userKeyId, serializer);
    sse_encode_String(self.walletKey, serializer);
    sse_encode_opt_String(self.mnemonic, serializer);
    sse_encode_opt_String(self.publicKey, serializer);
    sse_encode_opt_String(self.fingerprint, serializer);
    sse_encode_String(self.walletKeySignature, serializer);
  }

  @protected
  void sse_encode_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DatabaseConfig_Memory():
        sse_encode_i_32(0, serializer);
      case DatabaseConfig_Sqlite(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_sqlite_db_configuration(config, serializer);
    }
  }

  @protected
  void sse_encode_email_integration_bitcoin_address(
      EmailIntegrationBitcoinAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.bitcoinAddress, serializer);
    sse_encode_opt_String(self.bitcoinAddressSignature, serializer);
  }

  @protected
  void sse_encode_error(Error self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Error_InvalidU32Bytes(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_list_prim_u_8_strict(field0, serializer);
      case Error_Generic(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case Error_ScriptDoesntHaveAddressForm():
        sse_encode_i_32(2, serializer);
      case Error_NoRecipients():
        sse_encode_i_32(3, serializer);
      case Error_NoUtxosSelected():
        sse_encode_i_32(4, serializer);
      case Error_OutputBelowDustLimit(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_usize(field0, serializer);
      case Error_InsufficientFunds(
          needed: final needed,
          available: final available
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_u_64(needed, serializer);
        sse_encode_u_64(available, serializer);
      case Error_BnBTotalTriesExceeded():
        sse_encode_i_32(7, serializer);
      case Error_BnBNoExactMatch():
        sse_encode_i_32(8, serializer);
      case Error_UnknownUtxo():
        sse_encode_i_32(9, serializer);
      case Error_TransactionNotFound():
        sse_encode_i_32(10, serializer);
      case Error_TransactionConfirmed():
        sse_encode_i_32(11, serializer);
      case Error_IrreplaceableTransaction():
        sse_encode_i_32(12, serializer);
      case Error_FeeRateTooLow(required: final required):
        sse_encode_i_32(13, serializer);
        sse_encode_f_32(required, serializer);
      case Error_FeeTooLow(required: final required):
        sse_encode_i_32(14, serializer);
        sse_encode_u_64(required, serializer);
      case Error_FeeRateUnavailable():
        sse_encode_i_32(15, serializer);
      case Error_MissingKeyOrigin(field0: final field0):
        sse_encode_i_32(16, serializer);
        sse_encode_String(field0, serializer);
      case Error_Key(field0: final field0):
        sse_encode_i_32(17, serializer);
        sse_encode_String(field0, serializer);
      case Error_ChecksumMismatch():
        sse_encode_i_32(18, serializer);
      case Error_SpendingPolicyRequired(field0: final field0):
        sse_encode_i_32(19, serializer);
        sse_encode_keychain_kind(field0, serializer);
      case Error_InvalidPolicyPathError(field0: final field0):
        sse_encode_i_32(20, serializer);
        sse_encode_String(field0, serializer);
      case Error_Signer(field0: final field0):
        sse_encode_i_32(21, serializer);
        sse_encode_String(field0, serializer);
      case Error_InvalidNetwork(requested: final requested, found: final found):
        sse_encode_i_32(22, serializer);
        sse_encode_network(requested, serializer);
        sse_encode_network(found, serializer);
      case Error_InvalidOutpoint(field0: final field0):
        sse_encode_i_32(23, serializer);
        sse_encode_box_autoadd_out_point(field0, serializer);
      case Error_Descriptor(field0: final field0):
        sse_encode_i_32(24, serializer);
        sse_encode_String(field0, serializer);
      case Error_Encode(field0: final field0):
        sse_encode_i_32(25, serializer);
        sse_encode_String(field0, serializer);
      case Error_Miniscript(field0: final field0):
        sse_encode_i_32(26, serializer);
        sse_encode_String(field0, serializer);
      case Error_MiniscriptPsbt(field0: final field0):
        sse_encode_i_32(27, serializer);
        sse_encode_String(field0, serializer);
      case Error_Bip32(field0: final field0):
        sse_encode_i_32(28, serializer);
        sse_encode_String(field0, serializer);
      case Error_Secp256k1(field0: final field0):
        sse_encode_i_32(29, serializer);
        sse_encode_String(field0, serializer);
      case Error_Json(field0: final field0):
        sse_encode_i_32(30, serializer);
        sse_encode_String(field0, serializer);
      case Error_Hex(field0: final field0):
        sse_encode_i_32(31, serializer);
        sse_encode_String(field0, serializer);
      case Error_Psbt(field0: final field0):
        sse_encode_i_32(32, serializer);
        sse_encode_String(field0, serializer);
      case Error_PsbtParse(field0: final field0):
        sse_encode_i_32(33, serializer);
        sse_encode_String(field0, serializer);
      case Error_MissingCachedScripts(
          field0: final field0,
          field1: final field1
        ):
        sse_encode_i_32(34, serializer);
        sse_encode_usize(field0, serializer);
        sse_encode_usize(field1, serializer);
      case Error_Electrum(field0: final field0):
        sse_encode_i_32(35, serializer);
        sse_encode_String(field0, serializer);
      case Error_Esplora(field0: final field0):
        sse_encode_i_32(36, serializer);
        sse_encode_String(field0, serializer);
      case Error_Sled(field0: final field0):
        sse_encode_i_32(37, serializer);
        sse_encode_String(field0, serializer);
      case Error_Rpc(field0: final field0):
        sse_encode_i_32(38, serializer);
        sse_encode_String(field0, serializer);
      case Error_Rusqlite(field0: final field0):
        sse_encode_i_32(39, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_esplora_config(EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.proxy, serializer);
    sse_encode_opt_box_autoadd_u_8(self.concurrency, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_opt_box_autoadd_u_64(self.timeout, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_fiat_currency(FiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_gateway_provider(
      GatewayProvider self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt64(self);
  }

  @protected
  void sse_encode_keychain_kind(KeychainKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_level(Level self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          List<ApiTx> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerApiTx(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_all_key_address_key(
      List<AllKeyAddressKey> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_all_key_address_key(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_contact_emails(
      List<ApiContactEmails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_contact_emails(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_country(
      List<ApiCountry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_country(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_country_fiat_currency(
      List<ApiCountryFiatCurrency> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_country_fiat_currency(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_email_address(
      List<ApiEmailAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_email_address(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_wallet_account(
      List<ApiWalletAccount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_wallet_account(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_wallet_bitcoin_address(
      List<ApiWalletBitcoinAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_wallet_bitcoin_address(item, serializer);
    }
  }

  @protected
  void sse_encode_list_api_wallet_data(
      List<ApiWalletData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_api_wallet_data(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bitcoin_address(
      List<BitcoinAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bitcoin_address(item, serializer);
    }
  }

  @protected
  void sse_encode_list_contact_email_event(
      List<ContactEmailEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_contact_email_event(item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_prim_u_8_strict(
      List<Uint8List> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_prim_u_8_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_local_utxo(
      List<LocalUtxo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_utxo(item, serializer);
    }
  }

  @protected
  void sse_encode_list_out_point(
      List<OutPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_out_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_method(
      List<PaymentMethod> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_method(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_proton_address(
      List<ProtonAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_proton_address(item, serializer);
    }
  }

  @protected
  void sse_encode_list_proton_address_key(
      List<ProtonAddressKey> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_proton_address_key(item, serializer);
    }
  }

  @protected
  void sse_encode_list_proton_event(
      List<ProtonEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_proton_event(item, serializer);
    }
  }

  @protected
  void sse_encode_list_quote(List<Quote> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_quote(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_gateway_provider_list_api_country(
      List<(GatewayProvider, List<ApiCountry>)> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_gateway_provider_list_api_country(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_gateway_provider_list_api_country_fiat_currency(
      List<(GatewayProvider, List<ApiCountryFiatCurrency>)> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_gateway_provider_list_api_country_fiat_currency(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_gateway_provider_list_payment_method(
      List<(GatewayProvider, List<PaymentMethod>)> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_gateway_provider_list_payment_method(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_gateway_provider_list_quote(
      List<(GatewayProvider, List<Quote>)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_gateway_provider_list_quote(item, serializer);
    }
  }

  @protected
  void sse_encode_list_script_amount(
      List<ScriptAmount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_script_amount(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction_details(
      List<TransactionDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_in(List<TxIn> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_in(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_out(List<TxOut> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_out(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_account_event(
      List<WalletAccountEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_account_event(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_event(
      List<WalletEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_event(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_key_event(
      List<WalletKeyEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_key_event(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_settings_event(
      List<WalletSettingsEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_settings_event(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_transaction(
      List<WalletTransaction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_transaction(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_transaction_event(
      List<WalletTransactionEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_transaction_event(item, serializer);
    }
  }

  @protected
  void sse_encode_local_utxo(LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_tx_out(self.txout, serializer);
    sse_encode_bool(self.isSpent, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.timeMillis, serializer);
    sse_encode_String(self.msg, serializer);
    sse_encode_level(self.logLevel, serializer);
    sse_encode_String(self.lbl, serializer);
  }

  @protected
  void sse_encode_my_test_object(MyTestObject self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_contact_emails(
      ApiContactEmails? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_contact_emails(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_wallet(
      ApiWallet? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_wallet(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_wallet_account(
      ApiWalletAccount? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_wallet_account(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_wallet_key(
      ApiWalletKey? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_wallet_key(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_wallet_settings(
      ApiWalletSettings? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_wallet_settings(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_api_wallet_user_settings(
      ApiWalletUserSettings? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_api_wallet_user_settings(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_block_time(
      BlockTime? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_block_time(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_gateway_provider(
      GatewayProvider? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_gateway_provider(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_method(
      PaymentMethod? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_method(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_proton_exchange_rate(
      ProtonExchangeRate? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_proton_exchange_rate(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_psbt_sig_hash_type(
      PsbtSigHashType? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_psbt_sig_hash_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rbf_value(
      RbfValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rbf_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_record_out_point_string_usize(
      (OutPoint, String, int)? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_record_out_point_string_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_script(
      Script? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_script(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sign_options(
      SignOptions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sign_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_wallet_transaction(
      WalletTransaction? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_wallet_transaction(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
      List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_contact_email_event(
      List<ContactEmailEvent>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_contact_email_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_proton_address_key(
      List<ProtonAddressKey>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_proton_address_key(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_wallet_account_event(
      List<WalletAccountEvent>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_wallet_account_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_wallet_event(
      List<WalletEvent>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_wallet_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_wallet_key_event(
      List<WalletKeyEvent>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_wallet_key_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_wallet_settings_event(
      List<WalletSettingsEvent>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_wallet_settings_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_wallet_transaction_event(
      List<WalletTransactionEvent>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_wallet_transaction_event(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payment_method(PaymentMethod self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_proton_address(ProtonAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.domainId, serializer);
    sse_encode_String(self.email, serializer);
    sse_encode_u_32(self.status, serializer);
    sse_encode_u_32(self.type, serializer);
    sse_encode_u_32(self.receive, serializer);
    sse_encode_u_32(self.send, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_opt_list_proton_address_key(self.keys, serializer);
  }

  @protected
  void sse_encode_proton_address_key(
      ProtonAddressKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.version, serializer);
    sse_encode_String(self.publicKey, serializer);
    sse_encode_opt_String(self.privateKey, serializer);
    sse_encode_opt_String(self.token, serializer);
    sse_encode_opt_String(self.signature, serializer);
    sse_encode_u_32(self.primary, serializer);
    sse_encode_u_32(self.active, serializer);
    sse_encode_u_32(self.flags, serializer);
  }

  @protected
  void sse_encode_proton_event(ProtonEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.code, serializer);
    sse_encode_String(self.eventId, serializer);
    sse_encode_u_32(self.refresh, serializer);
    sse_encode_u_32(self.more, serializer);
    sse_encode_opt_list_contact_email_event(
        self.contactEmailEvents, serializer);
    sse_encode_opt_list_wallet_event(self.walletEvents, serializer);
    sse_encode_opt_list_wallet_account_event(
        self.walletAccountEvents, serializer);
    sse_encode_opt_list_wallet_key_event(self.walletKeyEvents, serializer);
    sse_encode_opt_list_wallet_settings_event(
        self.walletSettingEvents, serializer);
    sse_encode_opt_list_wallet_transaction_event(
        self.walletTransactionEvents, serializer);
    sse_encode_opt_box_autoadd_api_wallet_user_settings(
        self.walletUserSettings, serializer);
  }

  @protected
  void sse_encode_proton_exchange_rate(
      ProtonExchangeRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_bitcoin_unit(self.bitcoinUnit, serializer);
    sse_encode_fiat_currency(self.fiatCurrency, serializer);
    sse_encode_String(self.exchangeRateTime, serializer);
    sse_encode_u_64(self.exchangeRate, serializer);
    sse_encode_u_64(self.cents, serializer);
  }

  @protected
  void sse_encode_psbt_sig_hash_type(
      PsbtSigHashType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.inner, serializer);
  }

  @protected
  void sse_encode_quote(Quote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bitcoinAmount, serializer);
    sse_encode_String(self.fiatAmount, serializer);
    sse_encode_fiat_currency(self.fiatCurrencySymbol, serializer);
    sse_encode_String(self.networkFee, serializer);
    sse_encode_String(self.paymentGatewayFee, serializer);
    sse_encode_payment_method(self.paymentMethod, serializer);
  }

  @protected
  void sse_encode_rbf_value(RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RbfValue_RbfDefault():
        sse_encode_i_32(0, serializer);
      case RbfValue_Value(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_record_gateway_provider_list_api_country(
      (GatewayProvider, List<ApiCountry>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gateway_provider(self.$1, serializer);
    sse_encode_list_api_country(self.$2, serializer);
  }

  @protected
  void sse_encode_record_gateway_provider_list_api_country_fiat_currency(
      (GatewayProvider, List<ApiCountryFiatCurrency>) self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gateway_provider(self.$1, serializer);
    sse_encode_list_api_country_fiat_currency(self.$2, serializer);
  }

  @protected
  void sse_encode_record_gateway_provider_list_payment_method(
      (GatewayProvider, List<PaymentMethod>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gateway_provider(self.$1, serializer);
    sse_encode_list_payment_method(self.$2, serializer);
  }

  @protected
  void sse_encode_record_gateway_provider_list_quote(
      (GatewayProvider, List<Quote>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gateway_provider(self.$1, serializer);
    sse_encode_list_quote(self.$2, serializer);
  }

  @protected
  void sse_encode_record_out_point_string_usize(
      (OutPoint, String, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
    sse_encode_usize(self.$3, serializer);
  }

  @protected
  void sse_encode_record_string_network(
      (String, Network) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_network(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_transaction_details(
      (String, TransactionDetails) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_transaction_details(self.$2, serializer);
  }

  @protected
  void sse_encode_script(Script self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.internal, serializer);
  }

  @protected
  void sse_encode_script_amount(ScriptAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script(self.script, serializer);
    sse_encode_u_64(self.amount, serializer);
  }

  @protected
  void sse_encode_sign_options(SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isMultiSig, serializer);
    sse_encode_bool(self.trustWitnessUtxo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.assumeHeight, serializer);
    sse_encode_bool(self.allowAllSighashes, serializer);
    sse_encode_bool(self.removePartialSigs, serializer);
    sse_encode_bool(self.tryFinalize, serializer);
    sse_encode_bool(self.signWithTapInternalKey, serializer);
    sse_encode_bool(self.allowGrinding, serializer);
  }

  @protected
  void sse_encode_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_transaction_details(
      TransactionDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.serializedTx, serializer);
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.received, serializer);
    sse_encode_u_64(self.sent, serializer);
    sse_encode_opt_box_autoadd_u_64(self.fee, serializer);
    sse_encode_opt_box_autoadd_block_time(self.confirmationTime, serializer);
  }

  @protected
  void sse_encode_tx_in(TxIn self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.previousOutput, serializer);
    sse_encode_script(self.scriptSig, serializer);
    sse_encode_u_32(self.sequence, serializer);
    sse_encode_list_list_prim_u_8_strict(self.witness, serializer);
  }

  @protected
  void sse_encode_tx_out(TxOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_script(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_wallet_account_event(
      WalletAccountEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.action, serializer);
    sse_encode_opt_box_autoadd_api_wallet_account(
        self.walletAccount, serializer);
  }

  @protected
  void sse_encode_wallet_event(WalletEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.action, serializer);
    sse_encode_opt_box_autoadd_api_wallet(self.wallet, serializer);
  }

  @protected
  void sse_encode_wallet_key_event(
      WalletKeyEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.action, serializer);
    sse_encode_opt_box_autoadd_api_wallet_key(self.walletKey, serializer);
  }

  @protected
  void sse_encode_wallet_settings_event(
      WalletSettingsEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.action, serializer);
    sse_encode_opt_box_autoadd_api_wallet_settings(
        self.walletSettings, serializer);
  }

  @protected
  void sse_encode_wallet_transaction(
      WalletTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.walletId, serializer);
    sse_encode_opt_String(self.walletAccountId, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_String(self.transactionId, serializer);
    sse_encode_String(self.transactionTime, serializer);
    sse_encode_opt_box_autoadd_proton_exchange_rate(
        self.exchangeRate, serializer);
    sse_encode_opt_String(self.hashedTransactionId, serializer);
    sse_encode_opt_String(self.subject, serializer);
    sse_encode_opt_String(self.body, serializer);
    sse_encode_opt_String(self.sender, serializer);
    sse_encode_opt_String(self.tolist, serializer);
  }

  @protected
  void sse_encode_wallet_transaction_event(
      WalletTransactionEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.action, serializer);
    sse_encode_opt_box_autoadd_wallet_transaction(
        self.walletTransaction, serializer);
  }

  @protected
  void sse_encode_word_count(WordCount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}
