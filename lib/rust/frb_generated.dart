// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.24.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/api2.dart';
import 'api/ldk_api.dart';
import 'api/proton_api.dart';
import 'api/proton_api_service.dart';
import 'api/rust_api.dart';
import 'api/rust_objects.dart';
import 'bdk/blockchain.dart';
import 'bdk/error.dart';
import 'bdk/types.dart';
import 'bdk/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'proton_api/errors.dart';
import 'proton_api/user_settings.dart';
import 'proton_api/wallet.dart';
import 'proton_api/wallet_account.dart';
import 'proton_api/wallet_settings.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.initApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.24';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'proton_wallet_common',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<int> addOne({required int left, required int right, dynamic hint});

  Future<int> addThree({required int left, required int right, dynamic hint});

  String greet({required String name, dynamic hint});

  String helloworld({dynamic hint});

  Future<void> initApp({dynamic hint});

  Future<int> addTwo({required int left, required int right, dynamic hint});

  Future<ApiUserSettings> bitcoinUnit(
      {required CommonBitcoinUnit symbol, dynamic hint});

  Future<WalletData> createWallet(
      {required CreateWalletReq walletReq, dynamic hint});

  Future<WalletAccount> createWalletAccount(
      {required String walletId,
      required CreateWalletAccountReq req,
      dynamic hint});

  Future<void> deleteWallet({required String walletId, dynamic hint});

  Future<void> deleteWalletAccount(
      {required String walletId,
      required String walletAccountId,
      dynamic hint});

  Future<ApiUserSettings> fiatCurrency(
      {required ApiFiatCurrency symbol, dynamic hint});

  Future<ApiUserSettings> getUserSettings({dynamic hint});

  Future<List<WalletAccount>> getWalletAccounts(
      {required String walletId, dynamic hint});

  Future<List<WalletData>> getWallets({dynamic hint});

  Future<ApiUserSettings> hideEmptyUsedAddresses(
      {required bool hideEmptyUsedAddresses, dynamic hint});

  Future<void> initApiService(
      {required String userName, required String password, dynamic hint});

  Future<ApiUserSettings> twoFaThreshold({required int amount, dynamic hint});

  Future<WalletAccount> updateWalletAccountLabel(
      {required String walletId,
      required String walletAccountId,
      required String newLabel,
      dynamic hint});

  Future<ProtonWallet> updateWalletName(
      {required String walletId, required String newName, dynamic hint});

  Future<List<WalletData>> protonApiServiceGetWallets(
      {required ProtonAPIService that, dynamic hint});

  Future<void> protonApiServiceInitApiService(
      {required String userName, required String password, dynamic hint});

  Future<ProtonAPIService> protonApiServiceNew({dynamic hint});

  Future<String> protonApiServiceReadText(
      {required ProtonAPIService that, dynamic hint});

  Future<String> apiAddressFromScript(
      {required Script script, required Network network, dynamic hint});

  Future<Network> apiAddressNetwork({required String address, dynamic hint});

  Future<Script> apiAddressToScriptPubkey(
      {required String address, dynamic hint});

  Future<String> apiBroadcast(
      {required String tx, required String blockchainId, dynamic hint});

  Future<(String, TransactionDetails)> apiBumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required String walletId,
      required bool enableRbf,
      int? nSequence,
      dynamic hint});

  Future<String> apiCombinePsbt(
      {required String psbtStr, required String other, dynamic hint});

  Future<String> apiCreateAddress({required String address, dynamic hint});

  Future<String> apiCreateDerivationPath({required String path, dynamic hint});

  Future<String> apiCreateDescriptor(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiCreateDescriptorPublic(
      {String? xpub, required String path, required bool derive, dynamic hint});

  Future<String> apiCreateDescriptorSecret(
      {required Network network,
      required String mnemonic,
      String? password,
      dynamic hint});

  Future<String> apiCreateElectrumBlockchain(
      {required ElectrumConfig config, dynamic hint});

  Future<String> apiCreateEsploraBlockchain(
      {required EsploraConfig config, dynamic hint});

  Future<Script> apiCreateScript(
      {required List<int> rawOutputScript, dynamic hint});

  Future<String> apiCreateTransaction({required List<int> tx, dynamic hint});

  Future<String> apiCreateWallet(
      {required String descriptor,
      String? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint});

  Future<String> apiDeriveDescriptorSecret(
      {required String secret, required String path, dynamic hint});

  Future<String> apiDescriptorAsString(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiDescriptorAsStringPrivate(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiDescriptorPublicFromString(
      {required String publicKey, dynamic hint});

  Future<String> apiDescriptorSecretAsPublic(
      {required String secret, dynamic hint});

  Future<Uint8List> apiDescriptorSecretAsSecretBytes(
      {required String secret, dynamic hint});

  Future<String> apiDescriptorSecretFromString(
      {required String secret, dynamic hint});

  Future<double> apiEstimateFee(
      {required int target, required String blockchainId, dynamic hint});

  Future<String> apiExtendDescriptorSecret(
      {required String secret, required String path, dynamic hint});

  Future<String> apiExtractTx({required String psbtStr, dynamic hint});

  Future<String> apiGenerateSeedFromEntropy(
      {required List<int> entropy, dynamic hint});

  Future<String> apiGenerateSeedFromString(
      {required String mnemonic, dynamic hint});

  Future<String> apiGenerateSeedFromWordCount(
      {required WordCount wordCount, dynamic hint});

  Future<AddressInfo> apiGetAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint});

  Future<Balance> apiGetBalance({required String walletId, dynamic hint});

  Future<String> apiGetBlockchainHash(
      {required int blockchainHeight,
      required String blockchainId,
      dynamic hint});

  Future<(String, Network)> apiGetDescriptorForKeychain(
      {required String walletId, required KeychainKind keychain, dynamic hint});

  Future<int> apiGetHeight({required String blockchainId, dynamic hint});

  Future<AddressInfo> apiGetInternalAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint});

  Future<String> apiGetPsbtInput(
      {required String walletId,
      required LocalUtxo utxo,
      required bool onlyWitnessUtxo,
      PsbtSigHashType? psbtSighashType,
      dynamic hint});

  Future<List<TransactionDetails>> apiGetTransactions(
      {required String walletId, required bool includeRaw, dynamic hint});

  Future<List<TxIn>> apiInput({required String tx, dynamic hint});

  Future<bool> apiIsCoinBase({required String tx, dynamic hint});

  Future<bool> apiIsExplicitlyRbf({required String tx, dynamic hint});

  Future<bool> apiIsLockTimeEnabled({required String tx, dynamic hint});

  Future<bool> apiIsMine(
      {required Script script, required String walletId, dynamic hint});

  Future<String> apiJsonSerialize({required String psbtStr, dynamic hint});

  Future<List<LocalUtxo>> apiListUnspent(
      {required String walletId, dynamic hint});

  Future<List<LocalUtxo>> apiListUnspentOutputs(
      {required String walletId, dynamic hint});

  Future<int> apiLockTime({required String tx, dynamic hint});

  Future<int> apiMaxSatisfactionWeight(
      {required String descriptor, required Network network, dynamic hint});

  Future<String> apiNewBip44Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint});

  Future<String> apiNewBip44Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint});

  Future<String> apiNewBip49Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint});

  Future<String> apiNewBip49Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint});

  Future<String> apiNewBip84Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint});

  Future<String> apiNewBip84Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint});

  Future<List<TxOut>> apiOutput({required String tx, dynamic hint});

  Future<Payload> apiPayload({required String address, dynamic hint});

  Future<int?> apiPsbtFeeAmount({required String psbtStr, dynamic hint});

  Future<double?> apiPsbtFeeRate({required String psbtStr, dynamic hint});

  Future<String> apiPsbtTxid({required String psbtStr, dynamic hint});

  Future<String> apiSerializePsbt({required String psbtStr, dynamic hint});

  Future<Uint8List> apiSerializeTx({required String tx, dynamic hint});

  Future<String?> apiSign(
      {required String walletId,
      required String psbtStr,
      SignOptions? signOptions,
      dynamic hint});

  Future<int> apiSize({required String tx, dynamic hint});

  Future<void> apiSyncWallet(
      {required String walletId, required String blockchainId, dynamic hint});

  Future<(String, TransactionDetails)> apiTxBuilderFinish(
      {required String walletId,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      (OutPoint, String, int)? foreignUtxo,
      required List<OutPoint> unspendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      dynamic hint});

  Future<String> apiTxTxid({required String tx, dynamic hint});

  Future<int> apiVersion({required String tx, dynamic hint});

  Future<int> apiVsize({required String tx, dynamic hint});

  Future<Network> apiWalletNetwork({required String walletId, dynamic hint});

  Future<int> apiWeight({required String tx, dynamic hint});

  Future<MyTestObject> myTestObjectNew({dynamic hint});

  Future<String> myTestObjectReadText(
      {required MyTestObject that, dynamic hint});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AndromedaApiProtonWalletApiClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AndromedaApiProtonWalletApiClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AndromedaApiProtonWalletApiClientPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<int> addOne({required int left, required int right, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(left, serializer);
        sse_encode_usize(right, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kAddOneConstMeta,
      argValues: [left, right],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddOneConstMeta => const TaskConstMeta(
        debugName: "add_one",
        argNames: ["left", "right"],
      );

  @override
  Future<int> addThree({required int left, required int right, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(left, serializer);
        sse_encode_usize(right, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kAddThreeConstMeta,
      argValues: [left, right],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddThreeConstMeta => const TaskConstMeta(
        debugName: "add_three",
        argNames: ["left", "right"],
      );

  @override
  String greet({required String name, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kGreetConstMeta,
      argValues: [name],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  String helloworld({dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kHelloworldConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kHelloworldConstMeta => const TaskConstMeta(
        debugName: "helloworld",
        argNames: [],
      );

  @override
  Future<void> initApp({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kInitAppConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<int> addTwo({required int left, required int right, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(left, serializer);
        sse_encode_usize(right, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kAddTwoConstMeta,
      argValues: [left, right],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAddTwoConstMeta => const TaskConstMeta(
        debugName: "add_two",
        argNames: ["left", "right"],
      );

  @override
  Future<ApiUserSettings> bitcoinUnit(
      {required CommonBitcoinUnit symbol, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_common_bitcoin_unit(symbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_user_settings,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kBitcoinUnitConstMeta,
      argValues: [symbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBitcoinUnitConstMeta => const TaskConstMeta(
        debugName: "bitcoin_unit",
        argNames: ["symbol"],
      );

  @override
  Future<WalletData> createWallet(
      {required CreateWalletReq walletReq, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_create_wallet_req(walletReq, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_data,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kCreateWalletConstMeta,
      argValues: [walletReq],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCreateWalletConstMeta => const TaskConstMeta(
        debugName: "create_wallet",
        argNames: ["walletReq"],
      );

  @override
  Future<WalletAccount> createWalletAccount(
      {required String walletId,
      required CreateWalletAccountReq req,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_create_wallet_account_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_account,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kCreateWalletAccountConstMeta,
      argValues: [walletId, req],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kCreateWalletAccountConstMeta => const TaskConstMeta(
        debugName: "create_wallet_account",
        argNames: ["walletId", "req"],
      );

  @override
  Future<void> deleteWallet({required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kDeleteWalletConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDeleteWalletConstMeta => const TaskConstMeta(
        debugName: "delete_wallet",
        argNames: ["walletId"],
      );

  @override
  Future<void> deleteWalletAccount(
      {required String walletId,
      required String walletAccountId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kDeleteWalletAccountConstMeta,
      argValues: [walletId, walletAccountId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDeleteWalletAccountConstMeta => const TaskConstMeta(
        debugName: "delete_wallet_account",
        argNames: ["walletId", "walletAccountId"],
      );

  @override
  Future<ApiUserSettings> fiatCurrency(
      {required ApiFiatCurrency symbol, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_api_fiat_currency(symbol, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_user_settings,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kFiatCurrencyConstMeta,
      argValues: [symbol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kFiatCurrencyConstMeta => const TaskConstMeta(
        debugName: "fiat_currency",
        argNames: ["symbol"],
      );

  @override
  Future<ApiUserSettings> getUserSettings({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_user_settings,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kGetUserSettingsConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetUserSettingsConstMeta => const TaskConstMeta(
        debugName: "get_user_settings",
        argNames: [],
      );

  @override
  Future<List<WalletAccount>> getWalletAccounts(
      {required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wallet_account,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kGetWalletAccountsConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetWalletAccountsConstMeta => const TaskConstMeta(
        debugName: "get_wallet_accounts",
        argNames: ["walletId"],
      );

  @override
  Future<List<WalletData>> getWallets({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wallet_data,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kGetWalletsConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kGetWalletsConstMeta => const TaskConstMeta(
        debugName: "get_wallets",
        argNames: [],
      );

  @override
  Future<ApiUserSettings> hideEmptyUsedAddresses(
      {required bool hideEmptyUsedAddresses, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(hideEmptyUsedAddresses, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_user_settings,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kHideEmptyUsedAddressesConstMeta,
      argValues: [hideEmptyUsedAddresses],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kHideEmptyUsedAddressesConstMeta => const TaskConstMeta(
        debugName: "hide_empty_used_addresses",
        argNames: ["hideEmptyUsedAddresses"],
      );

  @override
  Future<void> initApiService(
      {required String userName, required String password, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(userName, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kInitApiServiceConstMeta,
      argValues: [userName, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kInitApiServiceConstMeta => const TaskConstMeta(
        debugName: "init_api_service",
        argNames: ["userName", "password"],
      );

  @override
  Future<ApiUserSettings> twoFaThreshold({required int amount, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_api_user_settings,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kTwoFaThresholdConstMeta,
      argValues: [amount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kTwoFaThresholdConstMeta => const TaskConstMeta(
        debugName: "two_fa_threshold",
        argNames: ["amount"],
      );

  @override
  Future<WalletAccount> updateWalletAccountLabel(
      {required String walletId,
      required String walletAccountId,
      required String newLabel,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(walletAccountId, serializer);
        sse_encode_String(newLabel, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_wallet_account,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kUpdateWalletAccountLabelConstMeta,
      argValues: [walletId, walletAccountId, newLabel],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateWalletAccountLabelConstMeta => const TaskConstMeta(
        debugName: "update_wallet_account_label",
        argNames: ["walletId", "walletAccountId", "newLabel"],
      );

  @override
  Future<ProtonWallet> updateWalletName(
      {required String walletId, required String newName, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(newName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_proton_wallet,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kUpdateWalletNameConstMeta,
      argValues: [walletId, newName],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kUpdateWalletNameConstMeta => const TaskConstMeta(
        debugName: "update_wallet_name",
        argNames: ["walletId", "newName"],
      );

  @override
  Future<List<WalletData>> protonApiServiceGetWallets(
      {required ProtonAPIService that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_proton_api_service(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wallet_data,
        decodeErrorData: sse_decode_api_error,
      ),
      constMeta: kProtonApiServiceGetWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceGetWalletsConstMeta => const TaskConstMeta(
        debugName: "ProtonAPIService_get_wallets",
        argNames: ["that"],
      );

  @override
  Future<void> protonApiServiceInitApiService(
      {required String userName, required String password, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(userName, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceInitApiServiceConstMeta,
      argValues: [userName, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceInitApiServiceConstMeta =>
      const TaskConstMeta(
        debugName: "ProtonAPIService_init_api_service",
        argNames: ["userName", "password"],
      );

  @override
  Future<ProtonAPIService> protonApiServiceNew({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_proton_api_service,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceNewConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceNewConstMeta => const TaskConstMeta(
        debugName: "ProtonAPIService_new",
        argNames: [],
      );

  @override
  Future<String> protonApiServiceReadText(
      {required ProtonAPIService that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_proton_api_service(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kProtonApiServiceReadTextConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kProtonApiServiceReadTextConstMeta => const TaskConstMeta(
        debugName: "ProtonAPIService_read_text",
        argNames: ["that"],
      );

  @override
  Future<String> apiAddressFromScript(
      {required Script script, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script(script, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 74, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiAddressFromScriptConstMeta,
      argValues: [script, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiAddressFromScriptConstMeta => const TaskConstMeta(
        debugName: "Api_address_from_script",
        argNames: ["script", "network"],
      );

  @override
  Future<Network> apiAddressNetwork({required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiAddressNetworkConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiAddressNetworkConstMeta => const TaskConstMeta(
        debugName: "Api_address_network",
        argNames: ["address"],
      );

  @override
  Future<Script> apiAddressToScriptPubkey(
      {required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_script,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiAddressToScriptPubkeyConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiAddressToScriptPubkeyConstMeta => const TaskConstMeta(
        debugName: "Api_address_to_script_pubkey",
        argNames: ["address"],
      );

  @override
  Future<String> apiBroadcast(
      {required String tx, required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiBroadcastConstMeta,
      argValues: [tx, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiBroadcastConstMeta => const TaskConstMeta(
        debugName: "Api_broadcast",
        argNames: ["tx", "blockchainId"],
      );

  @override
  Future<(String, TransactionDetails)> apiBumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required String walletId,
      required bool enableRbf,
      int? nSequence,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(txid, serializer);
        sse_encode_f_32(feeRate, serializer);
        sse_encode_opt_String(allowShrinking, serializer);
        sse_encode_String(walletId, serializer);
        sse_encode_bool(enableRbf, serializer);
        sse_encode_opt_box_autoadd_u_32(nSequence, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_transaction_details,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiBumpFeeTxBuilderFinishConstMeta,
      argValues: [
        txid,
        feeRate,
        allowShrinking,
        walletId,
        enableRbf,
        nSequence
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiBumpFeeTxBuilderFinishConstMeta => const TaskConstMeta(
        debugName: "Api_bump_fee_tx_builder_finish",
        argNames: [
          "txid",
          "feeRate",
          "allowShrinking",
          "walletId",
          "enableRbf",
          "nSequence"
        ],
      );

  @override
  Future<String> apiCombinePsbt(
      {required String psbtStr, required String other, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        sse_encode_String(other, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCombinePsbtConstMeta,
      argValues: [psbtStr, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCombinePsbtConstMeta => const TaskConstMeta(
        debugName: "Api_combine_psbt",
        argNames: ["psbtStr", "other"],
      );

  @override
  Future<String> apiCreateAddress({required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateAddressConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateAddressConstMeta => const TaskConstMeta(
        debugName: "Api_create_address",
        argNames: ["address"],
      );

  @override
  Future<String> apiCreateDerivationPath({required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDerivationPathConstMeta,
      argValues: [path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDerivationPathConstMeta => const TaskConstMeta(
        debugName: "Api_create_derivation_path",
        argNames: ["path"],
      );

  @override
  Future<String> apiCreateDescriptor(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDescriptorConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDescriptorConstMeta => const TaskConstMeta(
        debugName: "Api_create_descriptor",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiCreateDescriptorPublic(
      {String? xpub,
      required String path,
      required bool derive,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_String(xpub, serializer);
        sse_encode_String(path, serializer);
        sse_encode_bool(derive, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDescriptorPublicConstMeta,
      argValues: [xpub, path, derive],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDescriptorPublicConstMeta => const TaskConstMeta(
        debugName: "Api_create_descriptor_public",
        argNames: ["xpub", "path", "derive"],
      );

  @override
  Future<String> apiCreateDescriptorSecret(
      {required Network network,
      required String mnemonic,
      String? password,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_network(network, serializer);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateDescriptorSecretConstMeta,
      argValues: [network, mnemonic, password],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateDescriptorSecretConstMeta => const TaskConstMeta(
        debugName: "Api_create_descriptor_secret",
        argNames: ["network", "mnemonic", "password"],
      );

  @override
  Future<String> apiCreateElectrumBlockchain(
      {required ElectrumConfig config, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_electrum_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateElectrumBlockchainConstMeta,
      argValues: [config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateElectrumBlockchainConstMeta =>
      const TaskConstMeta(
        debugName: "Api_create_electrum_blockchain",
        argNames: ["config"],
      );

  @override
  Future<String> apiCreateEsploraBlockchain(
      {required EsploraConfig config, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_esplora_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateEsploraBlockchainConstMeta,
      argValues: [config],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateEsploraBlockchainConstMeta => const TaskConstMeta(
        debugName: "Api_create_esplora_blockchain",
        argNames: ["config"],
      );

  @override
  Future<Script> apiCreateScript(
      {required List<int> rawOutputScript, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(rawOutputScript, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_script,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateScriptConstMeta,
      argValues: [rawOutputScript],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateScriptConstMeta => const TaskConstMeta(
        debugName: "Api_create_script",
        argNames: ["rawOutputScript"],
      );

  @override
  Future<String> apiCreateTransaction({required List<int> tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateTransactionConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateTransactionConstMeta => const TaskConstMeta(
        debugName: "Api_create_transaction",
        argNames: ["tx"],
      );

  @override
  Future<String> apiCreateWallet(
      {required String descriptor,
      String? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_opt_String(changeDescriptor, serializer);
        sse_encode_network(network, serializer);
        sse_encode_box_autoadd_database_config(databaseConfig, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiCreateWalletConstMeta,
      argValues: [descriptor, changeDescriptor, network, databaseConfig],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiCreateWalletConstMeta => const TaskConstMeta(
        debugName: "Api_create_wallet",
        argNames: [
          "descriptor",
          "changeDescriptor",
          "network",
          "databaseConfig"
        ],
      );

  @override
  Future<String> apiDeriveDescriptorSecret(
      {required String secret, required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kApiDeriveDescriptorSecretConstMeta,
      argValues: [secret, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDeriveDescriptorSecretConstMeta => const TaskConstMeta(
        debugName: "Api_derive_descriptor_secret",
        argNames: ["secret", "path"],
      );

  @override
  Future<String> apiDescriptorAsString(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorAsStringConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorAsStringConstMeta => const TaskConstMeta(
        debugName: "Api_descriptor_as_string",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiDescriptorAsStringPrivate(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorAsStringPrivateConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorAsStringPrivateConstMeta =>
      const TaskConstMeta(
        debugName: "Api_descriptor_as_string_private",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiDescriptorPublicFromString(
      {required String publicKey, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(publicKey, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorPublicFromStringConstMeta,
      argValues: [publicKey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorPublicFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "Api_descriptor_public_from_string",
        argNames: ["publicKey"],
      );

  @override
  Future<String> apiDescriptorSecretAsPublic(
      {required String secret, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorSecretAsPublicConstMeta,
      argValues: [secret],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorSecretAsPublicConstMeta =>
      const TaskConstMeta(
        debugName: "Api_descriptor_secret_as_public",
        argNames: ["secret"],
      );

  @override
  Future<Uint8List> apiDescriptorSecretAsSecretBytes(
      {required String secret, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiDescriptorSecretAsSecretBytesConstMeta,
      argValues: [secret],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorSecretAsSecretBytesConstMeta =>
      const TaskConstMeta(
        debugName: "Api_descriptor_secret_as_secret_bytes",
        argNames: ["secret"],
      );

  @override
  Future<String> apiDescriptorSecretFromString(
      {required String secret, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kApiDescriptorSecretFromStringConstMeta,
      argValues: [secret],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiDescriptorSecretFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "Api_descriptor_secret_from_string",
        argNames: ["secret"],
      );

  @override
  Future<double> apiEstimateFee(
      {required int target, required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(target, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiEstimateFeeConstMeta,
      argValues: [target, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiEstimateFeeConstMeta => const TaskConstMeta(
        debugName: "Api_estimate_fee",
        argNames: ["target", "blockchainId"],
      );

  @override
  Future<String> apiExtendDescriptorSecret(
      {required String secret, required String path, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kApiExtendDescriptorSecretConstMeta,
      argValues: [secret, path],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiExtendDescriptorSecretConstMeta => const TaskConstMeta(
        debugName: "Api_extend_descriptor_secret",
        argNames: ["secret", "path"],
      );

  @override
  Future<String> apiExtractTx({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiExtractTxConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiExtractTxConstMeta => const TaskConstMeta(
        debugName: "Api_extract_tx",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> apiGenerateSeedFromEntropy(
      {required List<int> entropy, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(entropy, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 93, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGenerateSeedFromEntropyConstMeta,
      argValues: [entropy],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGenerateSeedFromEntropyConstMeta => const TaskConstMeta(
        debugName: "Api_generate_seed_from_entropy",
        argNames: ["entropy"],
      );

  @override
  Future<String> apiGenerateSeedFromString(
      {required String mnemonic, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 92, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGenerateSeedFromStringConstMeta,
      argValues: [mnemonic],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGenerateSeedFromStringConstMeta => const TaskConstMeta(
        debugName: "Api_generate_seed_from_string",
        argNames: ["mnemonic"],
      );

  @override
  Future<String> apiGenerateSeedFromWordCount(
      {required WordCount wordCount, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_word_count(wordCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kApiGenerateSeedFromWordCountConstMeta,
      argValues: [wordCount],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGenerateSeedFromWordCountConstMeta =>
      const TaskConstMeta(
        debugName: "Api_generate_seed_from_word_count",
        argNames: ["wordCount"],
      );

  @override
  Future<AddressInfo> apiGetAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_address_index(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 79, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetAddressConstMeta,
      argValues: [walletId, addressIndex],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetAddressConstMeta => const TaskConstMeta(
        debugName: "Api_get_address",
        argNames: ["walletId", "addressIndex"],
      );

  @override
  Future<Balance> apiGetBalance({required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_balance,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetBalanceConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetBalanceConstMeta => const TaskConstMeta(
        debugName: "Api_get_balance",
        argNames: ["walletId"],
      );

  @override
  Future<String> apiGetBlockchainHash(
      {required int blockchainHeight,
      required String blockchainId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(blockchainHeight, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetBlockchainHashConstMeta,
      argValues: [blockchainHeight, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetBlockchainHashConstMeta => const TaskConstMeta(
        debugName: "Api_get_blockchain_hash",
        argNames: ["blockchainHeight", "blockchainId"],
      );

  @override
  Future<(String, Network)> apiGetDescriptorForKeychain(
      {required String walletId,
      required KeychainKind keychain,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_keychain_kind(keychain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 90, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_network,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetDescriptorForKeychainConstMeta,
      argValues: [walletId, keychain],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetDescriptorForKeychainConstMeta =>
      const TaskConstMeta(
        debugName: "Api_get_descriptor_for_keychain",
        argNames: ["walletId", "keychain"],
      );

  @override
  Future<int> apiGetHeight({required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetHeightConstMeta,
      argValues: [blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetHeightConstMeta => const TaskConstMeta(
        debugName: "Api_get_height",
        argNames: ["blockchainId"],
      );

  @override
  Future<AddressInfo> apiGetInternalAddress(
      {required String walletId,
      required AddressIndex addressIndex,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_address_index(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetInternalAddressConstMeta,
      argValues: [walletId, addressIndex],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetInternalAddressConstMeta => const TaskConstMeta(
        debugName: "Api_get_internal_address",
        argNames: ["walletId", "addressIndex"],
      );

  @override
  Future<String> apiGetPsbtInput(
      {required String walletId,
      required LocalUtxo utxo,
      required bool onlyWitnessUtxo,
      PsbtSigHashType? psbtSighashType,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_box_autoadd_local_utxo(utxo, serializer);
        sse_encode_bool(onlyWitnessUtxo, serializer);
        sse_encode_opt_box_autoadd_psbt_sig_hash_type(
            psbtSighashType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 89, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetPsbtInputConstMeta,
      argValues: [walletId, utxo, onlyWitnessUtxo, psbtSighashType],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetPsbtInputConstMeta => const TaskConstMeta(
        debugName: "Api_get_psbt_input",
        argNames: ["walletId", "utxo", "onlyWitnessUtxo", "psbtSighashType"],
      );

  @override
  Future<List<TransactionDetails>> apiGetTransactions(
      {required String walletId, required bool includeRaw, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_bool(includeRaw, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_transaction_details,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiGetTransactionsConstMeta,
      argValues: [walletId, includeRaw],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiGetTransactionsConstMeta => const TaskConstMeta(
        debugName: "Api_get_transactions",
        argNames: ["walletId", "includeRaw"],
      );

  @override
  Future<List<TxIn>> apiInput({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_in,
        decodeErrorData: null,
      ),
      constMeta: kApiInputConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiInputConstMeta => const TaskConstMeta(
        debugName: "Api_input",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsCoinBase({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kApiIsCoinBaseConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsCoinBaseConstMeta => const TaskConstMeta(
        debugName: "Api_is_coin_base",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsExplicitlyRbf({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kApiIsExplicitlyRbfConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsExplicitlyRbfConstMeta => const TaskConstMeta(
        debugName: "Api_is_explicitly_rbf",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsLockTimeEnabled({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kApiIsLockTimeEnabledConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsLockTimeEnabledConstMeta => const TaskConstMeta(
        debugName: "Api_is_lock_time_enabled",
        argNames: ["tx"],
      );

  @override
  Future<bool> apiIsMine(
      {required Script script, required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script(script, serializer);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiIsMineConstMeta,
      argValues: [script, walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiIsMineConstMeta => const TaskConstMeta(
        debugName: "Api_is_mine",
        argNames: ["script", "walletId"],
      );

  @override
  Future<String> apiJsonSerialize({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiJsonSerializeConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiJsonSerializeConstMeta => const TaskConstMeta(
        debugName: "Api_json_serialize",
        argNames: ["psbtStr"],
      );

  @override
  Future<List<LocalUtxo>> apiListUnspent(
      {required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_local_utxo,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiListUnspentConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiListUnspentConstMeta => const TaskConstMeta(
        debugName: "Api_list_unspent",
        argNames: ["walletId"],
      );

  @override
  Future<List<LocalUtxo>> apiListUnspentOutputs(
      {required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_local_utxo,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiListUnspentOutputsConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiListUnspentOutputsConstMeta => const TaskConstMeta(
        debugName: "Api_list_unspent_outputs",
        argNames: ["walletId"],
      );

  @override
  Future<int> apiLockTime({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kApiLockTimeConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiLockTimeConstMeta => const TaskConstMeta(
        debugName: "Api_lock_time",
        argNames: ["tx"],
      );

  @override
  Future<int> apiMaxSatisfactionWeight(
      {required String descriptor, required Network network, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiMaxSatisfactionWeightConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiMaxSatisfactionWeightConstMeta => const TaskConstMeta(
        debugName: "Api_max_satisfaction_weight",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> apiNewBip44Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip44DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip44DescriptorConstMeta => const TaskConstMeta(
        debugName: "Api_new_bip44_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<String> apiNewBip44Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip44PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip44PublicConstMeta => const TaskConstMeta(
        debugName: "Api_new_bip44_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<String> apiNewBip49Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip49DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip49DescriptorConstMeta => const TaskConstMeta(
        debugName: "Api_new_bip49_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<String> apiNewBip49Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip49PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip49PublicConstMeta => const TaskConstMeta(
        debugName: "Api_new_bip49_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<String> apiNewBip84Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip84DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip84DescriptorConstMeta => const TaskConstMeta(
        debugName: "Api_new_bip84_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<String> apiNewBip84Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiNewBip84PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiNewBip84PublicConstMeta => const TaskConstMeta(
        debugName: "Api_new_bip84_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<List<TxOut>> apiOutput({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_out,
        decodeErrorData: null,
      ),
      constMeta: kApiOutputConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiOutputConstMeta => const TaskConstMeta(
        debugName: "Api_output",
        argNames: ["tx"],
      );

  @override
  Future<Payload> apiPayload({required String address, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_payload,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiPayloadConstMeta,
      argValues: [address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPayloadConstMeta => const TaskConstMeta(
        debugName: "Api_payload",
        argNames: ["address"],
      );

  @override
  Future<int?> apiPsbtFeeAmount({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiPsbtFeeAmountConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPsbtFeeAmountConstMeta => const TaskConstMeta(
        debugName: "Api_psbt_fee_amount",
        argNames: ["psbtStr"],
      );

  @override
  Future<double?> apiPsbtFeeRate({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_32,
        decodeErrorData: null,
      ),
      constMeta: kApiPsbtFeeRateConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPsbtFeeRateConstMeta => const TaskConstMeta(
        debugName: "Api_psbt_fee_rate",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> apiPsbtTxid({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiPsbtTxidConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiPsbtTxidConstMeta => const TaskConstMeta(
        debugName: "Api_psbt_txid",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> apiSerializePsbt({required String psbtStr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiSerializePsbtConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSerializePsbtConstMeta => const TaskConstMeta(
        debugName: "Api_serialize_psbt",
        argNames: ["psbtStr"],
      );

  @override
  Future<Uint8List> apiSerializeTx({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kApiSerializeTxConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSerializeTxConstMeta => const TaskConstMeta(
        debugName: "Api_serialize_tx",
        argNames: ["tx"],
      );

  @override
  Future<String?> apiSign(
      {required String walletId,
      required String psbtStr,
      SignOptions? signOptions,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(psbtStr, serializer);
        sse_encode_opt_box_autoadd_sign_options(signOptions, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiSignConstMeta,
      argValues: [walletId, psbtStr, signOptions],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSignConstMeta => const TaskConstMeta(
        debugName: "Api_sign",
        argNames: ["walletId", "psbtStr", "signOptions"],
      );

  @override
  Future<int> apiSize({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiSizeConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSizeConstMeta => const TaskConstMeta(
        debugName: "Api_size",
        argNames: ["tx"],
      );

  @override
  Future<void> apiSyncWallet(
      {required String walletId, required String blockchainId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_String(blockchainId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kApiSyncWalletConstMeta,
      argValues: [walletId, blockchainId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiSyncWalletConstMeta => const TaskConstMeta(
        debugName: "Api_sync_wallet",
        argNames: ["walletId", "blockchainId"],
      );

  @override
  Future<(String, TransactionDetails)> apiTxBuilderFinish(
      {required String walletId,
      required List<ScriptAmount> recipients,
      required List<OutPoint> utxos,
      (OutPoint, String, int)? foreignUtxo,
      required List<OutPoint> unspendable,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      int? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        sse_encode_list_script_amount(recipients, serializer);
        sse_encode_list_out_point(utxos, serializer);
        sse_encode_opt_box_autoadd_record_out_point_string_usize(
            foreignUtxo, serializer);
        sse_encode_list_out_point(unspendable, serializer);
        sse_encode_change_spend_policy(changePolicy, serializer);
        sse_encode_bool(manuallySelectedOnly, serializer);
        sse_encode_opt_box_autoadd_f_32(feeRate, serializer);
        sse_encode_opt_box_autoadd_u_64(feeAbsolute, serializer);
        sse_encode_bool(drainWallet, serializer);
        sse_encode_opt_box_autoadd_script(drainTo, serializer);
        sse_encode_opt_box_autoadd_rbf_value(rbf, serializer);
        sse_encode_list_prim_u_8_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_transaction_details,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiTxBuilderFinishConstMeta,
      argValues: [
        walletId,
        recipients,
        utxos,
        foreignUtxo,
        unspendable,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiTxBuilderFinishConstMeta => const TaskConstMeta(
        debugName: "Api_tx_builder_finish",
        argNames: [
          "walletId",
          "recipients",
          "utxos",
          "foreignUtxo",
          "unspendable",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data"
        ],
      );

  @override
  Future<String> apiTxTxid({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_error,
      ),
      constMeta: kApiTxTxidConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiTxTxidConstMeta => const TaskConstMeta(
        debugName: "Api_tx_txid",
        argNames: ["tx"],
      );

  @override
  Future<int> apiVersion({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kApiVersionConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiVersionConstMeta => const TaskConstMeta(
        debugName: "Api_version",
        argNames: ["tx"],
      );

  @override
  Future<int> apiVsize({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiVsizeConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiVsizeConstMeta => const TaskConstMeta(
        debugName: "Api_vsize",
        argNames: ["tx"],
      );

  @override
  Future<Network> apiWalletNetwork({required String walletId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(walletId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kApiWalletNetworkConstMeta,
      argValues: [walletId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiWalletNetworkConstMeta => const TaskConstMeta(
        debugName: "Api_wallet_network",
        argNames: ["walletId"],
      );

  @override
  Future<int> apiWeight({required String tx, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kApiWeightConstMeta,
      argValues: [tx],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kApiWeightConstMeta => const TaskConstMeta(
        debugName: "Api_weight",
        argNames: ["tx"],
      );

  @override
  Future<MyTestObject> myTestObjectNew({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 94, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_my_test_object,
        decodeErrorData: null,
      ),
      constMeta: kMyTestObjectNewConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kMyTestObjectNewConstMeta => const TaskConstMeta(
        debugName: "MyTestObject_new",
        argNames: [],
      );

  @override
  Future<String> myTestObjectReadText(
      {required MyTestObject that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_my_test_object(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 95, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kMyTestObjectReadTextConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kMyTestObjectReadTextConstMeta => const TaskConstMeta(
        debugName: "MyTestObject_read_text",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AndromedaApiProtonWalletApiClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AndromedaApiProtonWalletApiClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  AndromedaApiProtonWalletApiClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AndromedaApiProtonWalletApiClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  AndromedaApiProtonWalletApiClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AndromedaApiProtonWalletApiClient.dcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressIndex dco_decode_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressIndex_New();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        return AddressIndex_Peek(
          index: dco_decode_u_32(raw[1]),
        );
      case 3:
        return AddressIndex_Reset(
          index: dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AddressInfo dco_decode_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AddressInfo(
      index: dco_decode_u_32(arr[0]),
      address: dco_decode_String(arr[1]),
    );
  }

  @protected
  ApiError dco_decode_api_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ApiError_Generic(
          dco_decode_String(raw[1]),
        );
      case 1:
        return ApiError_SessionError(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ApiFiatCurrency dco_decode_api_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ApiFiatCurrency.values[raw as int];
  }

  @protected
  ApiUserSettings dco_decode_api_user_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ApiUserSettings(
      bitcoinUnit: dco_decode_common_bitcoin_unit(arr[0]),
      fiatCurrency: dco_decode_api_fiat_currency(arr[1]),
      hideEmptyUsedAddresses: dco_decode_u_8(arr[2]),
      showWalletRecovery: dco_decode_u_8(arr[3]),
      twoFactorAmountThreshold: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: dco_decode_u_64(arr[0]),
      trustedPending: dco_decode_u_64(arr[1]),
      untrustedPending: dco_decode_u_64(arr[2]),
      confirmed: dco_decode_u_64(arr[3]),
      spendable: dco_decode_u_64(arr[4]),
      total: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  BlockTime dco_decode_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddressIndex dco_decode_box_autoadd_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_index(raw);
  }

  @protected
  BlockTime dco_decode_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_block_time(raw);
  }

  @protected
  CreateWalletAccountReq dco_decode_box_autoadd_create_wallet_account_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_create_wallet_account_req(raw);
  }

  @protected
  CreateWalletReq dco_decode_box_autoadd_create_wallet_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_create_wallet_req(raw);
  }

  @protected
  DatabaseConfig dco_decode_box_autoadd_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_database_config(raw);
  }

  @protected
  ElectrumConfig dco_decode_box_autoadd_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_electrum_config(raw);
  }

  @protected
  EsploraConfig dco_decode_box_autoadd_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_esplora_config(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  LocalUtxo dco_decode_box_autoadd_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_local_utxo(raw);
  }

  @protected
  MyTestObject dco_decode_box_autoadd_my_test_object(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_my_test_object(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  ProtonAPIService dco_decode_box_autoadd_proton_api_service(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_proton_api_service(raw);
  }

  @protected
  PsbtSigHashType dco_decode_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue dco_decode_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rbf_value(raw);
  }

  @protected
  (OutPoint, String, int) dco_decode_box_autoadd_record_out_point_string_usize(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as (OutPoint, String, int);
  }

  @protected
  Script dco_decode_box_autoadd_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_script(raw);
  }

  @protected
  SignOptions dco_decode_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_options(raw);
  }

  @protected
  SledDbConfiguration dco_decode_box_autoadd_sled_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sled_db_configuration(raw);
  }

  @protected
  SqliteDbConfiguration dco_decode_box_autoadd_sqlite_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sqlite_db_configuration(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ChangeSpendPolicy dco_decode_change_spend_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChangeSpendPolicy.values[raw as int];
  }

  @protected
  CommonBitcoinUnit dco_decode_common_bitcoin_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommonBitcoinUnit.values[raw as int];
  }

  @protected
  CreateWalletAccountReq dco_decode_create_wallet_account_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CreateWalletAccountReq(
      label: dco_decode_String(arr[0]),
      derivationPath: dco_decode_String(arr[1]),
      scriptType: dco_decode_u_8(arr[2]),
    );
  }

  @protected
  CreateWalletReq dco_decode_create_wallet_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return CreateWalletReq(
      name: dco_decode_String(arr[0]),
      isImported: dco_decode_u_8(arr[1]),
      type: dco_decode_u_8(arr[2]),
      hasPassphrase: dco_decode_u_8(arr[3]),
      userKeyId: dco_decode_String(arr[4]),
      walletKey: dco_decode_String(arr[5]),
      mnemonic: dco_decode_opt_String(arr[6]),
      publicKey: dco_decode_opt_String(arr[7]),
      fingerprint: dco_decode_opt_String(arr[8]),
    );
  }

  @protected
  DatabaseConfig dco_decode_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        return DatabaseConfig_Sqlite(
          config: dco_decode_box_autoadd_sqlite_db_configuration(raw[1]),
        );
      case 2:
        return DatabaseConfig_Sled(
          config: dco_decode_box_autoadd_sled_db_configuration(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ElectrumConfig dco_decode_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ElectrumConfig(
      url: dco_decode_String(arr[0]),
      socks5: dco_decode_opt_String(arr[1]),
      retry: dco_decode_u_8(arr[2]),
      timeout: dco_decode_opt_box_autoadd_u_8(arr[3]),
      stopGap: dco_decode_u_64(arr[4]),
      validateDomain: dco_decode_bool(arr[5]),
    );
  }

  @protected
  Error dco_decode_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Error_InvalidU32Bytes(
          dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 1:
        return Error_Generic(
          dco_decode_String(raw[1]),
        );
      case 2:
        return Error_ScriptDoesntHaveAddressForm();
      case 3:
        return Error_NoRecipients();
      case 4:
        return Error_NoUtxosSelected();
      case 5:
        return Error_OutputBelowDustLimit(
          dco_decode_usize(raw[1]),
        );
      case 6:
        return Error_InsufficientFunds(
          needed: dco_decode_u_64(raw[1]),
          available: dco_decode_u_64(raw[2]),
        );
      case 7:
        return Error_BnBTotalTriesExceeded();
      case 8:
        return Error_BnBNoExactMatch();
      case 9:
        return Error_UnknownUtxo();
      case 10:
        return Error_TransactionNotFound();
      case 11:
        return Error_TransactionConfirmed();
      case 12:
        return Error_IrreplaceableTransaction();
      case 13:
        return Error_FeeRateTooLow(
          required: dco_decode_f_32(raw[1]),
        );
      case 14:
        return Error_FeeTooLow(
          required: dco_decode_u_64(raw[1]),
        );
      case 15:
        return Error_FeeRateUnavailable();
      case 16:
        return Error_MissingKeyOrigin(
          dco_decode_String(raw[1]),
        );
      case 17:
        return Error_Key(
          dco_decode_String(raw[1]),
        );
      case 18:
        return Error_ChecksumMismatch();
      case 19:
        return Error_SpendingPolicyRequired(
          dco_decode_keychain_kind(raw[1]),
        );
      case 20:
        return Error_InvalidPolicyPathError(
          dco_decode_String(raw[1]),
        );
      case 21:
        return Error_Signer(
          dco_decode_String(raw[1]),
        );
      case 22:
        return Error_InvalidNetwork(
          requested: dco_decode_network(raw[1]),
          found: dco_decode_network(raw[2]),
        );
      case 23:
        return Error_InvalidOutpoint(
          dco_decode_box_autoadd_out_point(raw[1]),
        );
      case 24:
        return Error_Descriptor(
          dco_decode_String(raw[1]),
        );
      case 25:
        return Error_Encode(
          dco_decode_String(raw[1]),
        );
      case 26:
        return Error_Miniscript(
          dco_decode_String(raw[1]),
        );
      case 27:
        return Error_MiniscriptPsbt(
          dco_decode_String(raw[1]),
        );
      case 28:
        return Error_Bip32(
          dco_decode_String(raw[1]),
        );
      case 29:
        return Error_Secp256k1(
          dco_decode_String(raw[1]),
        );
      case 30:
        return Error_Json(
          dco_decode_String(raw[1]),
        );
      case 31:
        return Error_Hex(
          dco_decode_String(raw[1]),
        );
      case 32:
        return Error_Psbt(
          dco_decode_String(raw[1]),
        );
      case 33:
        return Error_PsbtParse(
          dco_decode_String(raw[1]),
        );
      case 34:
        return Error_MissingCachedScripts(
          dco_decode_usize(raw[1]),
          dco_decode_usize(raw[2]),
        );
      case 35:
        return Error_Electrum(
          dco_decode_String(raw[1]),
        );
      case 36:
        return Error_Esplora(
          dco_decode_String(raw[1]),
        );
      case 37:
        return Error_Sled(
          dco_decode_String(raw[1]),
        );
      case 38:
        return Error_Rpc(
          dco_decode_String(raw[1]),
        );
      case 39:
        return Error_Rusqlite(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EsploraConfig dco_decode_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return EsploraConfig(
      baseUrl: dco_decode_String(arr[0]),
      proxy: dco_decode_opt_String(arr[1]),
      concurrency: dco_decode_opt_box_autoadd_u_8(arr[2]),
      stopGap: dco_decode_u_64(arr[3]),
      timeout: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  KeychainKind dco_decode_keychain_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeychainKind.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<LocalUtxo> dco_decode_list_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_utxo).toList();
  }

  @protected
  List<OutPoint> dco_decode_list_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_out_point).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ScriptAmount> dco_decode_list_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_script_amount).toList();
  }

  @protected
  List<TransactionDetails> dco_decode_list_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_transaction_details).toList();
  }

  @protected
  List<TxIn> dco_decode_list_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_in).toList();
  }

  @protected
  List<TxOut> dco_decode_list_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_out).toList();
  }

  @protected
  List<WalletAccount> dco_decode_list_wallet_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_account).toList();
  }

  @protected
  List<WalletData> dco_decode_list_wallet_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_data).toList();
  }

  @protected
  LocalUtxo dco_decode_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalUtxo(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_tx_out(arr[1]),
      isSpent: dco_decode_bool(arr[2]),
      keychain: dco_decode_keychain_kind(arr[3]),
    );
  }

  @protected
  MyTestObject dco_decode_my_test_object(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 0)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return MyTestObject();
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BlockTime? dco_decode_opt_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_block_time(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  PsbtSigHashType? dco_decode_opt_box_autoadd_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_psbt_sig_hash_type(raw);
  }

  @protected
  RbfValue? dco_decode_opt_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rbf_value(raw);
  }

  @protected
  (OutPoint, String, int)?
      dco_decode_opt_box_autoadd_record_out_point_string_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_record_out_point_string_usize(raw);
  }

  @protected
  Script? dco_decode_opt_box_autoadd_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_script(raw);
  }

  @protected
  SignOptions? dco_decode_opt_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sign_options(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Payload dco_decode_payload(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Payload_PubkeyHash(
          pubkeyHash: dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 1:
        return Payload_ScriptHash(
          scriptHash: dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 2:
        return Payload_WitnessProgram(
          version: dco_decode_witness_version(raw[1]),
          program: dco_decode_list_prim_u_8_strict(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ProtonAPIService dco_decode_proton_api_service(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ProtonAPIService(
      api:
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
              arr[0]),
    );
  }

  @protected
  ProtonWallet dco_decode_proton_wallet(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return ProtonWallet(
      id: dco_decode_String(arr[0]),
      hasPassphrase: dco_decode_u_8(arr[1]),
      isImported: dco_decode_u_8(arr[2]),
      mnemonic: dco_decode_opt_String(arr[3]),
      name: dco_decode_String(arr[4]),
      priority: dco_decode_u_8(arr[5]),
      publicKey: dco_decode_opt_String(arr[6]),
      status: dco_decode_u_8(arr[7]),
      type: dco_decode_u_8(arr[8]),
      fingerprint: dco_decode_opt_String(arr[9]),
    );
  }

  @protected
  ProtonWalletKey dco_decode_proton_wallet_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ProtonWalletKey(
      userKeyId: dco_decode_String(arr[0]),
      walletKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  PsbtSigHashType dco_decode_psbt_sig_hash_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PsbtSigHashType(
      inner: dco_decode_u_32(arr[0]),
    );
  }

  @protected
  RbfValue dco_decode_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        return RbfValue_Value(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (OutPoint, String, int) dco_decode_record_out_point_string_usize(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_out_point(arr[0]),
      dco_decode_String(arr[1]),
      dco_decode_usize(arr[2]),
    );
  }

  @protected
  (String, Network) dco_decode_record_string_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_network(arr[1]),
    );
  }

  @protected
  (String, TransactionDetails) dco_decode_record_string_transaction_details(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_transaction_details(arr[1]),
    );
  }

  @protected
  Script dco_decode_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Script(
      internal: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  ScriptAmount dco_decode_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ScriptAmount(
      script: dco_decode_script(arr[0]),
      amount: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SignOptions dco_decode_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return SignOptions(
      isMultiSig: dco_decode_bool(arr[0]),
      trustWitnessUtxo: dco_decode_bool(arr[1]),
      assumeHeight: dco_decode_opt_box_autoadd_u_32(arr[2]),
      allowAllSighashes: dco_decode_bool(arr[3]),
      removePartialSigs: dco_decode_bool(arr[4]),
      tryFinalize: dco_decode_bool(arr[5]),
      signWithTapInternalKey: dco_decode_bool(arr[6]),
      allowGrinding: dco_decode_bool(arr[7]),
    );
  }

  @protected
  SledDbConfiguration dco_decode_sled_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SledDbConfiguration(
      path: dco_decode_String(arr[0]),
      treeName: dco_decode_String(arr[1]),
    );
  }

  @protected
  SqliteDbConfiguration dco_decode_sqlite_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SqliteDbConfiguration(
      path: dco_decode_String(arr[0]),
    );
  }

  @protected
  TransactionDetails dco_decode_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TransactionDetails(
      serializedTx: dco_decode_opt_String(arr[0]),
      txid: dco_decode_String(arr[1]),
      received: dco_decode_u_64(arr[2]),
      sent: dco_decode_u_64(arr[3]),
      fee: dco_decode_opt_box_autoadd_u_64(arr[4]),
      confirmationTime: dco_decode_opt_box_autoadd_block_time(arr[5]),
    );
  }

  @protected
  TxIn dco_decode_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxIn(
      previousOutput: dco_decode_out_point(arr[0]),
      scriptSig: dco_decode_script(arr[1]),
      sequence: dco_decode_u_32(arr[2]),
      witness: dco_decode_list_String(arr[3]),
    );
  }

  @protected
  TxOut dco_decode_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_script(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  WalletAccount dco_decode_wallet_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return WalletAccount(
      id: dco_decode_String(arr[0]),
      walletId: dco_decode_String(arr[1]),
      derivationPath: dco_decode_String(arr[2]),
      label: dco_decode_String(arr[3]),
      scriptType: dco_decode_u_8(arr[4]),
    );
  }

  @protected
  WalletData dco_decode_wallet_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WalletData(
      wallet: dco_decode_proton_wallet(arr[0]),
      walletKey: dco_decode_proton_wallet_key(arr[1]),
      walletSettings: dco_decode_wallet_settings(arr[2]),
    );
  }

  @protected
  WalletSettings dco_decode_wallet_settings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return WalletSettings(
      hideAccounts: dco_decode_u_8(arr[0]),
      invoiceDefaultDesc: dco_decode_opt_String(arr[1]),
      invoiceExpTime: dco_decode_u_64(arr[2]),
      maxChannelOpeningFee: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  WitnessVersion dco_decode_witness_version(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WitnessVersion.values[raw as int];
  }

  @protected
  WordCount dco_decode_word_count(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WordCount.values[raw as int];
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  AndromedaApiProtonWalletApiClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AndromedaApiProtonWalletApiClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AndromedaApiProtonWalletApiClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AndromedaApiProtonWalletApiClient.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressIndex sse_decode_address_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AddressIndex_New();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Peek(index: var_index);
      case 3:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Reset(index: var_index);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AddressInfo sse_decode_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_address = sse_decode_String(deserializer);
    return AddressInfo(index: var_index, address: var_address);
  }

  @protected
  ApiError sse_decode_api_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return ApiError_Generic(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return ApiError_SessionError(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ApiFiatCurrency sse_decode_api_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ApiFiatCurrency.values[inner];
  }

  @protected
  ApiUserSettings sse_decode_api_user_settings(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinUnit = sse_decode_common_bitcoin_unit(deserializer);
    var var_fiatCurrency = sse_decode_api_fiat_currency(deserializer);
    var var_hideEmptyUsedAddresses = sse_decode_u_8(deserializer);
    var var_showWalletRecovery = sse_decode_u_8(deserializer);
    var var_twoFactorAmountThreshold =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return ApiUserSettings(
        bitcoinUnit: var_bitcoinUnit,
        fiatCurrency: var_fiatCurrency,
        hideEmptyUsedAddresses: var_hideEmptyUsedAddresses,
        showWalletRecovery: var_showWalletRecovery,
        twoFactorAmountThreshold: var_twoFactorAmountThreshold);
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_immature = sse_decode_u_64(deserializer);
    var var_trustedPending = sse_decode_u_64(deserializer);
    var var_untrustedPending = sse_decode_u_64(deserializer);
    var var_confirmed = sse_decode_u_64(deserializer);
    var var_spendable = sse_decode_u_64(deserializer);
    var var_total = sse_decode_u_64(deserializer);
    return Balance(
        immature: var_immature,
        trustedPending: var_trustedPending,
        untrustedPending: var_untrustedPending,
        confirmed: var_confirmed,
        spendable: var_spendable,
        total: var_total);
  }

  @protected
  BlockTime sse_decode_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    return BlockTime(height: var_height, timestamp: var_timestamp);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddressIndex sse_decode_box_autoadd_address_index(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_index(deserializer));
  }

  @protected
  BlockTime sse_decode_box_autoadd_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_block_time(deserializer));
  }

  @protected
  CreateWalletAccountReq sse_decode_box_autoadd_create_wallet_account_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_create_wallet_account_req(deserializer));
  }

  @protected
  CreateWalletReq sse_decode_box_autoadd_create_wallet_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_create_wallet_req(deserializer));
  }

  @protected
  DatabaseConfig sse_decode_box_autoadd_database_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_database_config(deserializer));
  }

  @protected
  ElectrumConfig sse_decode_box_autoadd_electrum_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_electrum_config(deserializer));
  }

  @protected
  EsploraConfig sse_decode_box_autoadd_esplora_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_esplora_config(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  LocalUtxo sse_decode_box_autoadd_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_local_utxo(deserializer));
  }

  @protected
  MyTestObject sse_decode_box_autoadd_my_test_object(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_my_test_object(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  ProtonAPIService sse_decode_box_autoadd_proton_api_service(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_proton_api_service(deserializer));
  }

  @protected
  PsbtSigHashType sse_decode_box_autoadd_psbt_sig_hash_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_psbt_sig_hash_type(deserializer));
  }

  @protected
  RbfValue sse_decode_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rbf_value(deserializer));
  }

  @protected
  (OutPoint, String, int) sse_decode_box_autoadd_record_out_point_string_usize(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_record_out_point_string_usize(deserializer));
  }

  @protected
  Script sse_decode_box_autoadd_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_script(deserializer));
  }

  @protected
  SignOptions sse_decode_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_options(deserializer));
  }

  @protected
  SledDbConfiguration sse_decode_box_autoadd_sled_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sled_db_configuration(deserializer));
  }

  @protected
  SqliteDbConfiguration sse_decode_box_autoadd_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sqlite_db_configuration(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  ChangeSpendPolicy sse_decode_change_spend_policy(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChangeSpendPolicy.values[inner];
  }

  @protected
  CommonBitcoinUnit sse_decode_common_bitcoin_unit(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CommonBitcoinUnit.values[inner];
  }

  @protected
  CreateWalletAccountReq sse_decode_create_wallet_account_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_derivationPath = sse_decode_String(deserializer);
    var var_scriptType = sse_decode_u_8(deserializer);
    return CreateWalletAccountReq(
        label: var_label,
        derivationPath: var_derivationPath,
        scriptType: var_scriptType);
  }

  @protected
  CreateWalletReq sse_decode_create_wallet_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_isImported = sse_decode_u_8(deserializer);
    var var_type = sse_decode_u_8(deserializer);
    var var_hasPassphrase = sse_decode_u_8(deserializer);
    var var_userKeyId = sse_decode_String(deserializer);
    var var_walletKey = sse_decode_String(deserializer);
    var var_mnemonic = sse_decode_opt_String(deserializer);
    var var_publicKey = sse_decode_opt_String(deserializer);
    var var_fingerprint = sse_decode_opt_String(deserializer);
    return CreateWalletReq(
        name: var_name,
        isImported: var_isImported,
        type: var_type,
        hasPassphrase: var_hasPassphrase,
        userKeyId: var_userKeyId,
        walletKey: var_walletKey,
        mnemonic: var_mnemonic,
        publicKey: var_publicKey,
        fingerprint: var_fingerprint);
  }

  @protected
  DatabaseConfig sse_decode_database_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        var var_config =
            sse_decode_box_autoadd_sqlite_db_configuration(deserializer);
        return DatabaseConfig_Sqlite(config: var_config);
      case 2:
        var var_config =
            sse_decode_box_autoadd_sled_db_configuration(deserializer);
        return DatabaseConfig_Sled(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ElectrumConfig sse_decode_electrum_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_socks5 = sse_decode_opt_String(deserializer);
    var var_retry = sse_decode_u_8(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_validateDomain = sse_decode_bool(deserializer);
    return ElectrumConfig(
        url: var_url,
        socks5: var_socks5,
        retry: var_retry,
        timeout: var_timeout,
        stopGap: var_stopGap,
        validateDomain: var_validateDomain);
  }

  @protected
  Error sse_decode_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
        return Error_InvalidU32Bytes(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Generic(var_field0);
      case 2:
        return Error_ScriptDoesntHaveAddressForm();
      case 3:
        return Error_NoRecipients();
      case 4:
        return Error_NoUtxosSelected();
      case 5:
        var var_field0 = sse_decode_usize(deserializer);
        return Error_OutputBelowDustLimit(var_field0);
      case 6:
        var var_needed = sse_decode_u_64(deserializer);
        var var_available = sse_decode_u_64(deserializer);
        return Error_InsufficientFunds(
            needed: var_needed, available: var_available);
      case 7:
        return Error_BnBTotalTriesExceeded();
      case 8:
        return Error_BnBNoExactMatch();
      case 9:
        return Error_UnknownUtxo();
      case 10:
        return Error_TransactionNotFound();
      case 11:
        return Error_TransactionConfirmed();
      case 12:
        return Error_IrreplaceableTransaction();
      case 13:
        var var_required = sse_decode_f_32(deserializer);
        return Error_FeeRateTooLow(required: var_required);
      case 14:
        var var_required = sse_decode_u_64(deserializer);
        return Error_FeeTooLow(required: var_required);
      case 15:
        return Error_FeeRateUnavailable();
      case 16:
        var var_field0 = sse_decode_String(deserializer);
        return Error_MissingKeyOrigin(var_field0);
      case 17:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Key(var_field0);
      case 18:
        return Error_ChecksumMismatch();
      case 19:
        var var_field0 = sse_decode_keychain_kind(deserializer);
        return Error_SpendingPolicyRequired(var_field0);
      case 20:
        var var_field0 = sse_decode_String(deserializer);
        return Error_InvalidPolicyPathError(var_field0);
      case 21:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Signer(var_field0);
      case 22:
        var var_requested = sse_decode_network(deserializer);
        var var_found = sse_decode_network(deserializer);
        return Error_InvalidNetwork(requested: var_requested, found: var_found);
      case 23:
        var var_field0 = sse_decode_box_autoadd_out_point(deserializer);
        return Error_InvalidOutpoint(var_field0);
      case 24:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Descriptor(var_field0);
      case 25:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Encode(var_field0);
      case 26:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Miniscript(var_field0);
      case 27:
        var var_field0 = sse_decode_String(deserializer);
        return Error_MiniscriptPsbt(var_field0);
      case 28:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Bip32(var_field0);
      case 29:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Secp256k1(var_field0);
      case 30:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Json(var_field0);
      case 31:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Hex(var_field0);
      case 32:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Psbt(var_field0);
      case 33:
        var var_field0 = sse_decode_String(deserializer);
        return Error_PsbtParse(var_field0);
      case 34:
        var var_field0 = sse_decode_usize(deserializer);
        var var_field1 = sse_decode_usize(deserializer);
        return Error_MissingCachedScripts(var_field0, var_field1);
      case 35:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Electrum(var_field0);
      case 36:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Esplora(var_field0);
      case 37:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Sled(var_field0);
      case 38:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Rpc(var_field0);
      case 39:
        var var_field0 = sse_decode_String(deserializer);
        return Error_Rusqlite(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EsploraConfig sse_decode_esplora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseUrl = sse_decode_String(deserializer);
    var var_proxy = sse_decode_opt_String(deserializer);
    var var_concurrency = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_64(deserializer);
    return EsploraConfig(
        baseUrl: var_baseUrl,
        proxy: var_proxy,
        concurrency: var_concurrency,
        stopGap: var_stopGap,
        timeout: var_timeout);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  KeychainKind sse_decode_keychain_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return KeychainKind.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalUtxo> sse_decode_list_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalUtxo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_utxo(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutPoint> sse_decode_list_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_out_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ScriptAmount> sse_decode_list_script_amount(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScriptAmount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_script_amount(deserializer));
    }
    return ans_;
  }

  @protected
  List<TransactionDetails> sse_decode_list_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TransactionDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxIn> sse_decode_list_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxIn>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_in(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxOut> sse_decode_list_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_out(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletAccount> sse_decode_list_wallet_account(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletAccount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_account(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletData> sse_decode_list_wallet_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_data(deserializer));
    }
    return ans_;
  }

  @protected
  LocalUtxo sse_decode_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_tx_out(deserializer);
    var var_isSpent = sse_decode_bool(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    return LocalUtxo(
        outpoint: var_outpoint,
        txout: var_txout,
        isSpent: var_isSpent,
        keychain: var_keychain);
  }

  @protected
  MyTestObject sse_decode_my_test_object(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MyTestObject();
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BlockTime? sse_decode_opt_box_autoadd_block_time(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_block_time(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PsbtSigHashType? sse_decode_opt_box_autoadd_psbt_sig_hash_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_psbt_sig_hash_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RbfValue? sse_decode_opt_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rbf_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (OutPoint, String, int)?
      sse_decode_opt_box_autoadd_record_out_point_string_usize(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_record_out_point_string_usize(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Script? sse_decode_opt_box_autoadd_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_script(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SignOptions? sse_decode_opt_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sign_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  Payload sse_decode_payload(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_pubkeyHash = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_PubkeyHash(pubkeyHash: var_pubkeyHash);
      case 1:
        var var_scriptHash = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_ScriptHash(scriptHash: var_scriptHash);
      case 2:
        var var_version = sse_decode_witness_version(deserializer);
        var var_program = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_WitnessProgram(
            version: var_version, program: var_program);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ProtonAPIService sse_decode_proton_api_service(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_api =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
            deserializer);
    return ProtonAPIService(api: var_api);
  }

  @protected
  ProtonWallet sse_decode_proton_wallet(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_hasPassphrase = sse_decode_u_8(deserializer);
    var var_isImported = sse_decode_u_8(deserializer);
    var var_mnemonic = sse_decode_opt_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_priority = sse_decode_u_8(deserializer);
    var var_publicKey = sse_decode_opt_String(deserializer);
    var var_status = sse_decode_u_8(deserializer);
    var var_type = sse_decode_u_8(deserializer);
    var var_fingerprint = sse_decode_opt_String(deserializer);
    return ProtonWallet(
        id: var_id,
        hasPassphrase: var_hasPassphrase,
        isImported: var_isImported,
        mnemonic: var_mnemonic,
        name: var_name,
        priority: var_priority,
        publicKey: var_publicKey,
        status: var_status,
        type: var_type,
        fingerprint: var_fingerprint);
  }

  @protected
  ProtonWalletKey sse_decode_proton_wallet_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userKeyId = sse_decode_String(deserializer);
    var var_walletKey = sse_decode_String(deserializer);
    return ProtonWalletKey(userKeyId: var_userKeyId, walletKey: var_walletKey);
  }

  @protected
  PsbtSigHashType sse_decode_psbt_sig_hash_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inner = sse_decode_u_32(deserializer);
    return PsbtSigHashType(inner: var_inner);
  }

  @protected
  RbfValue sse_decode_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return RbfValue_Value(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (OutPoint, String, int) sse_decode_record_out_point_string_usize(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_out_point(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    var var_field2 = sse_decode_usize(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  (String, Network) sse_decode_record_string_network(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_network(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, TransactionDetails) sse_decode_record_string_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_transaction_details(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  Script sse_decode_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_internal = sse_decode_list_prim_u_8_strict(deserializer);
    return Script(internal: var_internal);
  }

  @protected
  ScriptAmount sse_decode_script_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_script = sse_decode_script(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    return ScriptAmount(script: var_script, amount: var_amount);
  }

  @protected
  SignOptions sse_decode_sign_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isMultiSig = sse_decode_bool(deserializer);
    var var_trustWitnessUtxo = sse_decode_bool(deserializer);
    var var_assumeHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_allowAllSighashes = sse_decode_bool(deserializer);
    var var_removePartialSigs = sse_decode_bool(deserializer);
    var var_tryFinalize = sse_decode_bool(deserializer);
    var var_signWithTapInternalKey = sse_decode_bool(deserializer);
    var var_allowGrinding = sse_decode_bool(deserializer);
    return SignOptions(
        isMultiSig: var_isMultiSig,
        trustWitnessUtxo: var_trustWitnessUtxo,
        assumeHeight: var_assumeHeight,
        allowAllSighashes: var_allowAllSighashes,
        removePartialSigs: var_removePartialSigs,
        tryFinalize: var_tryFinalize,
        signWithTapInternalKey: var_signWithTapInternalKey,
        allowGrinding: var_allowGrinding);
  }

  @protected
  SledDbConfiguration sse_decode_sled_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    var var_treeName = sse_decode_String(deserializer);
    return SledDbConfiguration(path: var_path, treeName: var_treeName);
  }

  @protected
  SqliteDbConfiguration sse_decode_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    return SqliteDbConfiguration(path: var_path);
  }

  @protected
  TransactionDetails sse_decode_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serializedTx = sse_decode_opt_String(deserializer);
    var var_txid = sse_decode_String(deserializer);
    var var_received = sse_decode_u_64(deserializer);
    var var_sent = sse_decode_u_64(deserializer);
    var var_fee = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_confirmationTime =
        sse_decode_opt_box_autoadd_block_time(deserializer);
    return TransactionDetails(
        serializedTx: var_serializedTx,
        txid: var_txid,
        received: var_received,
        sent: var_sent,
        fee: var_fee,
        confirmationTime: var_confirmationTime);
  }

  @protected
  TxIn sse_decode_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_previousOutput = sse_decode_out_point(deserializer);
    var var_scriptSig = sse_decode_script(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    var var_witness = sse_decode_list_String(deserializer);
    return TxIn(
        previousOutput: var_previousOutput,
        scriptSig: var_scriptSig,
        sequence: var_sequence,
        witness: var_witness);
  }

  @protected
  TxOut sse_decode_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_script(deserializer);
    return TxOut(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  WalletAccount sse_decode_wallet_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_walletId = sse_decode_String(deserializer);
    var var_derivationPath = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_scriptType = sse_decode_u_8(deserializer);
    return WalletAccount(
        id: var_id,
        walletId: var_walletId,
        derivationPath: var_derivationPath,
        label: var_label,
        scriptType: var_scriptType);
  }

  @protected
  WalletData sse_decode_wallet_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_wallet = sse_decode_proton_wallet(deserializer);
    var var_walletKey = sse_decode_proton_wallet_key(deserializer);
    var var_walletSettings = sse_decode_wallet_settings(deserializer);
    return WalletData(
        wallet: var_wallet,
        walletKey: var_walletKey,
        walletSettings: var_walletSettings);
  }

  @protected
  WalletSettings sse_decode_wallet_settings(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hideAccounts = sse_decode_u_8(deserializer);
    var var_invoiceDefaultDesc = sse_decode_opt_String(deserializer);
    var var_invoiceExpTime = sse_decode_u_64(deserializer);
    var var_maxChannelOpeningFee = sse_decode_u_64(deserializer);
    return WalletSettings(
        hideAccounts: var_hideAccounts,
        invoiceDefaultDesc: var_invoiceDefaultDesc,
        invoiceExpTime: var_invoiceExpTime,
        maxChannelOpeningFee: var_maxChannelOpeningFee);
  }

  @protected
  WitnessVersion sse_decode_witness_version(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WitnessVersion.values[inner];
  }

  @protected
  WordCount sse_decode_word_count(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WordCount.values[inner];
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ((');
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
          AndromedaApiProtonWalletApiClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
          AndromedaApiProtonWalletApiClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_index(AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressIndex_New():
        sse_encode_i_32(0, serializer);
      case AddressIndex_LastUnused():
        sse_encode_i_32(1, serializer);
      case AddressIndex_Peek(index: final index):
        sse_encode_i_32(2, serializer);
        sse_encode_u_32(index, serializer);
      case AddressIndex_Reset(index: final index):
        sse_encode_i_32(3, serializer);
        sse_encode_u_32(index, serializer);
    }
  }

  @protected
  void sse_encode_address_info(AddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_api_error(ApiError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ApiError_Generic(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case ApiError_SessionError(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_api_fiat_currency(
      ApiFiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_api_user_settings(
      ApiUserSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_common_bitcoin_unit(self.bitcoinUnit, serializer);
    sse_encode_api_fiat_currency(self.fiatCurrency, serializer);
    sse_encode_u_8(self.hideEmptyUsedAddresses, serializer);
    sse_encode_u_8(self.showWalletRecovery, serializer);
    sse_encode_opt_box_autoadd_u_64(self.twoFactorAmountThreshold, serializer);
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.immature, serializer);
    sse_encode_u_64(self.trustedPending, serializer);
    sse_encode_u_64(self.untrustedPending, serializer);
    sse_encode_u_64(self.confirmed, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.total, serializer);
  }

  @protected
  void sse_encode_block_time(BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address_index(
      AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_index(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_block_time(
      BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_create_wallet_account_req(
      CreateWalletAccountReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_create_wallet_account_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_create_wallet_req(
      CreateWalletReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_create_wallet_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_database_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_electrum_config(
      ElectrumConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_electrum_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_esplora_config(
      EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_esplora_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_local_utxo(
      LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_local_utxo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_my_test_object(
      MyTestObject self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_my_test_object(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_proton_api_service(
      ProtonAPIService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_proton_api_service(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_psbt_sig_hash_type(
      PsbtSigHashType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_psbt_sig_hash_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rbf_value(
      RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rbf_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_record_out_point_string_usize(
      (OutPoint, String, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_out_point_string_usize(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_script(Script self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_options(
      SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sled_db_configuration(
      SledDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sled_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sqlite_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_change_spend_policy(
      ChangeSpendPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_common_bitcoin_unit(
      CommonBitcoinUnit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_create_wallet_account_req(
      CreateWalletAccountReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.derivationPath, serializer);
    sse_encode_u_8(self.scriptType, serializer);
  }

  @protected
  void sse_encode_create_wallet_req(
      CreateWalletReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_8(self.isImported, serializer);
    sse_encode_u_8(self.type, serializer);
    sse_encode_u_8(self.hasPassphrase, serializer);
    sse_encode_String(self.userKeyId, serializer);
    sse_encode_String(self.walletKey, serializer);
    sse_encode_opt_String(self.mnemonic, serializer);
    sse_encode_opt_String(self.publicKey, serializer);
    sse_encode_opt_String(self.fingerprint, serializer);
  }

  @protected
  void sse_encode_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DatabaseConfig_Memory():
        sse_encode_i_32(0, serializer);
      case DatabaseConfig_Sqlite(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_sqlite_db_configuration(config, serializer);
      case DatabaseConfig_Sled(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_sled_db_configuration(config, serializer);
    }
  }

  @protected
  void sse_encode_electrum_config(
      ElectrumConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.socks5, serializer);
    sse_encode_u_8(self.retry, serializer);
    sse_encode_opt_box_autoadd_u_8(self.timeout, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_bool(self.validateDomain, serializer);
  }

  @protected
  void sse_encode_error(Error self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Error_InvalidU32Bytes(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_list_prim_u_8_strict(field0, serializer);
      case Error_Generic(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case Error_ScriptDoesntHaveAddressForm():
        sse_encode_i_32(2, serializer);
      case Error_NoRecipients():
        sse_encode_i_32(3, serializer);
      case Error_NoUtxosSelected():
        sse_encode_i_32(4, serializer);
      case Error_OutputBelowDustLimit(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_usize(field0, serializer);
      case Error_InsufficientFunds(
          needed: final needed,
          available: final available
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_u_64(needed, serializer);
        sse_encode_u_64(available, serializer);
      case Error_BnBTotalTriesExceeded():
        sse_encode_i_32(7, serializer);
      case Error_BnBNoExactMatch():
        sse_encode_i_32(8, serializer);
      case Error_UnknownUtxo():
        sse_encode_i_32(9, serializer);
      case Error_TransactionNotFound():
        sse_encode_i_32(10, serializer);
      case Error_TransactionConfirmed():
        sse_encode_i_32(11, serializer);
      case Error_IrreplaceableTransaction():
        sse_encode_i_32(12, serializer);
      case Error_FeeRateTooLow(required: final required):
        sse_encode_i_32(13, serializer);
        sse_encode_f_32(required, serializer);
      case Error_FeeTooLow(required: final required):
        sse_encode_i_32(14, serializer);
        sse_encode_u_64(required, serializer);
      case Error_FeeRateUnavailable():
        sse_encode_i_32(15, serializer);
      case Error_MissingKeyOrigin(field0: final field0):
        sse_encode_i_32(16, serializer);
        sse_encode_String(field0, serializer);
      case Error_Key(field0: final field0):
        sse_encode_i_32(17, serializer);
        sse_encode_String(field0, serializer);
      case Error_ChecksumMismatch():
        sse_encode_i_32(18, serializer);
      case Error_SpendingPolicyRequired(field0: final field0):
        sse_encode_i_32(19, serializer);
        sse_encode_keychain_kind(field0, serializer);
      case Error_InvalidPolicyPathError(field0: final field0):
        sse_encode_i_32(20, serializer);
        sse_encode_String(field0, serializer);
      case Error_Signer(field0: final field0):
        sse_encode_i_32(21, serializer);
        sse_encode_String(field0, serializer);
      case Error_InvalidNetwork(requested: final requested, found: final found):
        sse_encode_i_32(22, serializer);
        sse_encode_network(requested, serializer);
        sse_encode_network(found, serializer);
      case Error_InvalidOutpoint(field0: final field0):
        sse_encode_i_32(23, serializer);
        sse_encode_box_autoadd_out_point(field0, serializer);
      case Error_Descriptor(field0: final field0):
        sse_encode_i_32(24, serializer);
        sse_encode_String(field0, serializer);
      case Error_Encode(field0: final field0):
        sse_encode_i_32(25, serializer);
        sse_encode_String(field0, serializer);
      case Error_Miniscript(field0: final field0):
        sse_encode_i_32(26, serializer);
        sse_encode_String(field0, serializer);
      case Error_MiniscriptPsbt(field0: final field0):
        sse_encode_i_32(27, serializer);
        sse_encode_String(field0, serializer);
      case Error_Bip32(field0: final field0):
        sse_encode_i_32(28, serializer);
        sse_encode_String(field0, serializer);
      case Error_Secp256k1(field0: final field0):
        sse_encode_i_32(29, serializer);
        sse_encode_String(field0, serializer);
      case Error_Json(field0: final field0):
        sse_encode_i_32(30, serializer);
        sse_encode_String(field0, serializer);
      case Error_Hex(field0: final field0):
        sse_encode_i_32(31, serializer);
        sse_encode_String(field0, serializer);
      case Error_Psbt(field0: final field0):
        sse_encode_i_32(32, serializer);
        sse_encode_String(field0, serializer);
      case Error_PsbtParse(field0: final field0):
        sse_encode_i_32(33, serializer);
        sse_encode_String(field0, serializer);
      case Error_MissingCachedScripts(
          field0: final field0,
          field1: final field1
        ):
        sse_encode_i_32(34, serializer);
        sse_encode_usize(field0, serializer);
        sse_encode_usize(field1, serializer);
      case Error_Electrum(field0: final field0):
        sse_encode_i_32(35, serializer);
        sse_encode_String(field0, serializer);
      case Error_Esplora(field0: final field0):
        sse_encode_i_32(36, serializer);
        sse_encode_String(field0, serializer);
      case Error_Sled(field0: final field0):
        sse_encode_i_32(37, serializer);
        sse_encode_String(field0, serializer);
      case Error_Rpc(field0: final field0):
        sse_encode_i_32(38, serializer);
        sse_encode_String(field0, serializer);
      case Error_Rusqlite(field0: final field0):
        sse_encode_i_32(39, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_esplora_config(EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.proxy, serializer);
    sse_encode_opt_box_autoadd_u_8(self.concurrency, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_opt_box_autoadd_u_64(self.timeout, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_keychain_kind(KeychainKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_local_utxo(
      List<LocalUtxo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_utxo(item, serializer);
    }
  }

  @protected
  void sse_encode_list_out_point(
      List<OutPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_out_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_script_amount(
      List<ScriptAmount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_script_amount(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction_details(
      List<TransactionDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_in(List<TxIn> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_in(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_out(List<TxOut> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_out(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_account(
      List<WalletAccount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_account(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_data(
      List<WalletData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_data(item, serializer);
    }
  }

  @protected
  void sse_encode_local_utxo(LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_tx_out(self.txout, serializer);
    sse_encode_bool(self.isSpent, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
  }

  @protected
  void sse_encode_my_test_object(MyTestObject self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_block_time(
      BlockTime? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_block_time(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_psbt_sig_hash_type(
      PsbtSigHashType? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_psbt_sig_hash_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rbf_value(
      RbfValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rbf_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_record_out_point_string_usize(
      (OutPoint, String, int)? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_record_out_point_string_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_script(
      Script? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_script(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sign_options(
      SignOptions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sign_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payload(Payload self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Payload_PubkeyHash(pubkeyHash: final pubkeyHash):
        sse_encode_i_32(0, serializer);
        sse_encode_list_prim_u_8_strict(pubkeyHash, serializer);
      case Payload_ScriptHash(scriptHash: final scriptHash):
        sse_encode_i_32(1, serializer);
        sse_encode_list_prim_u_8_strict(scriptHash, serializer);
      case Payload_WitnessProgram(
          version: final version,
          program: final program
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_witness_version(version, serializer);
        sse_encode_list_prim_u_8_strict(program, serializer);
    }
  }

  @protected
  void sse_encode_proton_api_service(
      ProtonAPIService self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockandromeda_apiProtonWalletApiClient(
        self.api, serializer);
  }

  @protected
  void sse_encode_proton_wallet(ProtonWallet self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_8(self.hasPassphrase, serializer);
    sse_encode_u_8(self.isImported, serializer);
    sse_encode_opt_String(self.mnemonic, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_u_8(self.priority, serializer);
    sse_encode_opt_String(self.publicKey, serializer);
    sse_encode_u_8(self.status, serializer);
    sse_encode_u_8(self.type, serializer);
    sse_encode_opt_String(self.fingerprint, serializer);
  }

  @protected
  void sse_encode_proton_wallet_key(
      ProtonWalletKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userKeyId, serializer);
    sse_encode_String(self.walletKey, serializer);
  }

  @protected
  void sse_encode_psbt_sig_hash_type(
      PsbtSigHashType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.inner, serializer);
  }

  @protected
  void sse_encode_rbf_value(RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RbfValue_RbfDefault():
        sse_encode_i_32(0, serializer);
      case RbfValue_Value(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
    }
  }

  @protected
  void sse_encode_record_out_point_string_usize(
      (OutPoint, String, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
    sse_encode_usize(self.$3, serializer);
  }

  @protected
  void sse_encode_record_string_network(
      (String, Network) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_network(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_transaction_details(
      (String, TransactionDetails) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_transaction_details(self.$2, serializer);
  }

  @protected
  void sse_encode_script(Script self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.internal, serializer);
  }

  @protected
  void sse_encode_script_amount(ScriptAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script(self.script, serializer);
    sse_encode_u_64(self.amount, serializer);
  }

  @protected
  void sse_encode_sign_options(SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isMultiSig, serializer);
    sse_encode_bool(self.trustWitnessUtxo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.assumeHeight, serializer);
    sse_encode_bool(self.allowAllSighashes, serializer);
    sse_encode_bool(self.removePartialSigs, serializer);
    sse_encode_bool(self.tryFinalize, serializer);
    sse_encode_bool(self.signWithTapInternalKey, serializer);
    sse_encode_bool(self.allowGrinding, serializer);
  }

  @protected
  void sse_encode_sled_db_configuration(
      SledDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
    sse_encode_String(self.treeName, serializer);
  }

  @protected
  void sse_encode_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_transaction_details(
      TransactionDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.serializedTx, serializer);
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.received, serializer);
    sse_encode_u_64(self.sent, serializer);
    sse_encode_opt_box_autoadd_u_64(self.fee, serializer);
    sse_encode_opt_box_autoadd_block_time(self.confirmationTime, serializer);
  }

  @protected
  void sse_encode_tx_in(TxIn self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.previousOutput, serializer);
    sse_encode_script(self.scriptSig, serializer);
    sse_encode_u_32(self.sequence, serializer);
    sse_encode_list_String(self.witness, serializer);
  }

  @protected
  void sse_encode_tx_out(TxOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_script(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_wallet_account(WalletAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.walletId, serializer);
    sse_encode_String(self.derivationPath, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_u_8(self.scriptType, serializer);
  }

  @protected
  void sse_encode_wallet_data(WalletData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_proton_wallet(self.wallet, serializer);
    sse_encode_proton_wallet_key(self.walletKey, serializer);
    sse_encode_wallet_settings(self.walletSettings, serializer);
  }

  @protected
  void sse_encode_wallet_settings(
      WalletSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self.hideAccounts, serializer);
    sse_encode_opt_String(self.invoiceDefaultDesc, serializer);
    sse_encode_u_64(self.invoiceExpTime, serializer);
    sse_encode_u_64(self.maxChannelOpeningFee, serializer);
  }

  @protected
  void sse_encode_witness_version(
      WitnessVersion self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_word_count(WordCount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}
