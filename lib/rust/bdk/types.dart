// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.24.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

@freezed
sealed class AddressIndex with _$AddressIndex {
  ///Return a new address after incrementing the current descriptor index.
  const factory AddressIndex.new() = AddressIndex_New;

  ///Return the address for the current descriptor index if it has not been used in a received transaction. Otherwise return a new address as with AddressIndex.New.
  ///Use with caution, if the wallet has not yet detected an address has been used it could return an already used address. This function is primarily meant for situations where the caller is untrusted; for example when deriving donation addresses on-demand for a public web page.
  const factory AddressIndex.lastUnused() = AddressIndex_LastUnused;

  /// Return the address for a specific descriptor index. Does not change the current descriptor
  /// index used by `AddressIndex` and `AddressIndex.LastUsed`.
  /// Use with caution, if an index is given that is less than the current descriptor index
  /// then the returned address may have already been used.
  const factory AddressIndex.peek({
    required int index,
  }) = AddressIndex_Peek;

  /// Return the address for a specific descriptor index and reset the current descriptor index
  /// used by `AddressIndex` and `AddressIndex.LastUsed` to this value.
  /// Use with caution, if an index is given that is less than the current descriptor index
  /// then the returned address and subsequent addresses returned by calls to `AddressIndex`
  /// and `AddressIndex.LastUsed` may have already been used. Also if the index is reset to a
  /// value earlier than the Blockchain stopGap (default is 20) then a
  /// larger stopGap should be used to monitor for all possibly used addresses.
  const factory AddressIndex.reset({
    required int index,
  }) = AddressIndex_Reset;
}

///A derived address and the index it was found at For convenience this automatically derefs to Address
class AddressInfo {
  ///Child index of this address
  final int index;

  /// Address
  final String address;

  const AddressInfo({
    required this.index,
    required this.address,
  });

  @override
  int get hashCode => index.hashCode ^ address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressInfo &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          address == other.address;
}

/// Local Wallet's Balance
class Balance {
  final int immature;

  /// Unconfirmed UTXOs generated by a wallet tx
  final int trustedPending;

  /// Unconfirmed UTXOs received from an external wallet
  final int untrustedPending;

  /// Confirmed and immediately spendable balance
  final int confirmed;

  /// Get sum of trusted_pending and confirmed coins
  final int spendable;

  /// Get the whole balance visible to the wallet
  final int total;

  const Balance({
    required this.immature,
    required this.trustedPending,
    required this.untrustedPending,
    required this.confirmed,
    required this.spendable,
    required this.total,
  });

  @override
  int get hashCode =>
      immature.hashCode ^
      trustedPending.hashCode ^
      untrustedPending.hashCode ^
      confirmed.hashCode ^
      spendable.hashCode ^
      total.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Balance &&
          runtimeType == other.runtimeType &&
          immature == other.immature &&
          trustedPending == other.trustedPending &&
          untrustedPending == other.untrustedPending &&
          confirmed == other.confirmed &&
          spendable == other.spendable &&
          total == other.total;
}

///Block height and timestamp of a block
class BlockTime {
  ///Confirmation block height
  final int height;

  ///Confirmation block timestamp
  final int timestamp;

  const BlockTime({
    required this.height,
    required this.timestamp,
  });

  @override
  int get hashCode => height.hashCode ^ timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockTime &&
          runtimeType == other.runtimeType &&
          height == other.height &&
          timestamp == other.timestamp;
}

enum ChangeSpendPolicy {
  changeAllowed,
  onlyChange,
  changeForbidden,
}

///Types of keychains
enum KeychainKind {
  External,

  ///Internal, usually used for change outputs
  internal,
}

///The cryptocurrency to act on
enum Network {
  ///Bitcoin’s testnet
  testnet,

  ///Bitcoin’s regtest
  regtest,

  ///Classic Bitcoin
  bitcoin,

  ///Bitcoin’s signet
  signet,
}

/// A reference to a transaction output.
class OutPoint {
  /// The referenced transaction's txid.
  final String txid;

  /// The index of the referenced output in its transaction's vout.
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

@freezed
sealed class Payload with _$Payload {
  /// P2PKH address.
  const factory Payload.pubkeyHash({
    required Uint8List pubkeyHash,
  }) = Payload_PubkeyHash;

  /// P2SH address.
  const factory Payload.scriptHash({
    required Uint8List scriptHash,
  }) = Payload_ScriptHash;

  /// Segwit address.
  const factory Payload.witnessProgram({
    /// The witness program version.
    required WitnessVersion version,

    /// The witness program.
    required Uint8List program,
  }) = Payload_WitnessProgram;
}

class PsbtSigHashType {
  final int inner;

  const PsbtSigHashType({
    required this.inner,
  });

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PsbtSigHashType &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

@freezed
sealed class RbfValue with _$RbfValue {
  const factory RbfValue.rbfDefault() = RbfValue_RbfDefault;
  const factory RbfValue.value(
    int field0,
  ) = RbfValue_Value;
}

/// A Bitcoin script.
class Script {
  final Uint8List internal;

  const Script({
    required this.internal,
  });

  @override
  int get hashCode => internal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Script &&
          runtimeType == other.runtimeType &&
          internal == other.internal;
}

/// A output script and an amount of satoshis.
class ScriptAmount {
  final Script script;
  final int amount;

  const ScriptAmount({
    required this.script,
    required this.amount,
  });

  @override
  int get hashCode => script.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScriptAmount &&
          runtimeType == other.runtimeType &&
          script == other.script &&
          amount == other.amount;
}

///A wallet transaction
class TransactionDetails {
  final String? serializedTx;

  /// Transaction id.
  final String txid;

  /// Received value (sats)
  /// Sum of owned outputs of this transaction.
  final int received;

  /// Sent value (sats)
  /// Sum of owned inputs of this transaction.
  final int sent;

  /// Fee value (sats) if confirmed.
  /// The availability of the fee depends on the backend. It's never None with an Electrum
  /// Server backend, but it could be None with a Bitcoin RPC node without txindex that receive
  /// funds while offline.
  final int? fee;

  /// If the transaction is confirmed, contains height and timestamp of the block containing the
  /// transaction, unconfirmed transaction contains `None`.
  final BlockTime? confirmationTime;

  const TransactionDetails({
    this.serializedTx,
    required this.txid,
    required this.received,
    required this.sent,
    this.fee,
    this.confirmationTime,
  });

  @override
  int get hashCode =>
      serializedTx.hashCode ^
      txid.hashCode ^
      received.hashCode ^
      sent.hashCode ^
      fee.hashCode ^
      confirmationTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionDetails &&
          runtimeType == other.runtimeType &&
          serializedTx == other.serializedTx &&
          txid == other.txid &&
          received == other.received &&
          sent == other.sent &&
          fee == other.fee &&
          confirmationTime == other.confirmationTime;
}

class TxIn {
  final OutPoint previousOutput;
  final Script scriptSig;
  final int sequence;
  final List<String> witness;

  const TxIn({
    required this.previousOutput,
    required this.scriptSig,
    required this.sequence,
    required this.witness,
  });

  @override
  int get hashCode =>
      previousOutput.hashCode ^
      scriptSig.hashCode ^
      sequence.hashCode ^
      witness.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxIn &&
          runtimeType == other.runtimeType &&
          previousOutput == other.previousOutput &&
          scriptSig == other.scriptSig &&
          sequence == other.sequence &&
          witness == other.witness;
}

///A transaction output, which defines new coins to be created from old ones.
class TxOut {
  /// The value of the output, in satoshis.
  final int value;

  /// The address of the output.
  final Script scriptPubkey;

  const TxOut({
    required this.value,
    required this.scriptPubkey,
  });

  @override
  int get hashCode => value.hashCode ^ scriptPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOut &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          scriptPubkey == other.scriptPubkey;
}

enum WitnessVersion {
  /// Initial version of witness program. Used for P2WPKH and P2WPK outputs
  v0,

  /// Version of witness program used for Taproot P2TR outputs.
  v1,

  /// Future (unsupported) version of witness program.
  v2,

  /// Future (unsupported) version of witness program.
  v3,

  /// Future (unsupported) version of witness program.
  v4,

  /// Future (unsupported) version of witness program.
  v5,

  /// Future (unsupported) version of witness program.
  v6,

  /// Future (unsupported) version of witness program.
  v7,

  /// Future (unsupported) version of witness program.
  v8,

  /// Future (unsupported) version of witness program.
  v9,

  /// Future (unsupported) version of witness program.
  v10,

  /// Future (unsupported) version of witness program.
  v11,

  /// Future (unsupported) version of witness program.
  v12,

  /// Future (unsupported) version of witness program.
  v13,

  /// Future (unsupported) version of witness program.
  v14,

  /// Future (unsupported) version of witness program.
  v15,

  /// Future (unsupported) version of witness program.
  v16,
}

///Type describing entropy length (aka word count) in the mnemonic
enum WordCount {
  ///12 words mnemonic (128 bits entropy)
  words12,

  ///18 words mnemonic (192 bits entropy)
  words18,

  ///24 words mnemonic (256 bits entropy)
  words24,
}
