// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.35.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../bdk/blockchain.dart';
import '../bdk/error.dart';
import '../bdk/types.dart';
import '../bdk/wallet.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `RUNTIME` is not used by any `pub` functions, thus it is ignored.

class Api {
  const Api();

  static Future<String> addressFromScript(
          {required Script script, required Network network, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiAddressFromScript(
          script: script, network: network, hint: hint);

  static Future<Network> addressNetwork(
          {required String address, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiAddressNetwork(address: address, hint: hint);

  static Future<Script> addressToScriptPubkey(
          {required String address, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiAddressToScriptPubkey(
          address: address, hint: hint);

  static Future<String> broadcast(
          {required String tx, required String blockchainId, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiBroadcast(
          tx: tx, blockchainId: blockchainId, hint: hint);

  static Future<(String, TransactionDetails)> bumpFeeTxBuilderFinish(
          {required String txid,
          required double feeRate,
          String? allowShrinking,
          required String walletId,
          required bool enableRbf,
          int? nSequence,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiBumpFeeTxBuilderFinish(
          txid: txid,
          feeRate: feeRate,
          allowShrinking: allowShrinking,
          walletId: walletId,
          enableRbf: enableRbf,
          nSequence: nSequence,
          hint: hint);

  static Future<String> combinePsbt(
          {required String psbtStr, required String other, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiCombinePsbt(
          psbtStr: psbtStr, other: other, hint: hint);

  static Future<String> createAddress(
          {required String address, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiCreateAddress(address: address, hint: hint);

  static Future<String> createDerivationPath(
          {required String path, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiCreateDerivationPath(path: path, hint: hint);

  static Future<String> createDescriptor(
          {required String descriptor,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiCreateDescriptor(
          descriptor: descriptor, network: network, hint: hint);

  static Future<String> createDescriptorPublic(
          {String? xpub,
          required String path,
          required bool derive,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiCreateDescriptorPublic(
          xpub: xpub, path: path, derive: derive, hint: hint);

  static Future<String> createDescriptorSecret(
          {required Network network,
          required String mnemonic,
          String? password,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiCreateDescriptorSecret(
          network: network, mnemonic: mnemonic, password: password, hint: hint);

  /// create esplora blockchain with proton api
  static Future<String> createEsploraBlockchainWithApi(
          {required EsploraConfig config, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiCreateEsploraBlockchainWithApi(
          config: config, hint: hint);

  static Future<String> createTransaction(
          {required List<int> tx, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiCreateTransaction(tx: tx, hint: hint);

  static Future<String> createWallet(
          {required String descriptor,
          String? changeDescriptor,
          required Network network,
          required DatabaseConfig databaseConfig,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiCreateWallet(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          network: network,
          databaseConfig: databaseConfig,
          hint: hint);

  static Future<String> deriveDescriptorSecret(
          {required String secret, required String path, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDeriveDescriptorSecret(
          secret: secret, path: path, hint: hint);

  static Future<String> descriptorAsString(
          {required String descriptor,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDescriptorAsString(
          descriptor: descriptor, network: network, hint: hint);

  static Future<String> descriptorAsStringPrivate(
          {required String descriptor,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDescriptorAsStringPrivate(
          descriptor: descriptor, network: network, hint: hint);

  static Future<String> descriptorPublicFromString(
          {required String publicKey, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDescriptorPublicFromString(
          publicKey: publicKey, hint: hint);

  static Future<String> descriptorSecretAsPublic(
          {required String secret, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDescriptorSecretAsPublic(
          secret: secret, hint: hint);

  static Future<Uint8List> descriptorSecretAsSecretBytes(
          {required String secret, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDescriptorSecretAsSecretBytes(
          secret: secret, hint: hint);

  static Future<String> descriptorSecretFromString(
          {required String secret, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiDescriptorSecretFromString(
          secret: secret, hint: hint);

  static Future<double> estimateFee(
          {required int target, required String blockchainId, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiEstimateFee(
          target: target, blockchainId: blockchainId, hint: hint);

  static Future<String> extendDescriptorSecret(
          {required String secret, required String path, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiExtendDescriptorSecret(
          secret: secret, path: path, hint: hint);

  static Future<String> extractTx({required String psbtStr, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiExtractTx(psbtStr: psbtStr, hint: hint);

  static Future<String> generateSeedFromEntropy(
          {required List<int> entropy, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGenerateSeedFromEntropy(
          entropy: entropy, hint: hint);

  static Future<String> generateSeedFromString(
          {required String mnemonic, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGenerateSeedFromString(
          mnemonic: mnemonic, hint: hint);

  static Future<String> generateSeedFromWordCount(
          {required WordCount wordCount, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGenerateSeedFromWordCount(
          wordCount: wordCount, hint: hint);

  static Future<AddressInfo> getAddress(
          {required String walletId,
          required AddressIndex addressIndex,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGetAddress(
          walletId: walletId, addressIndex: addressIndex, hint: hint);

  static Future<Balance> getBalance({required String walletId, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiGetBalance(walletId: walletId, hint: hint);

  static Future<String> getBlockchainHash(
          {required int blockchainHeight,
          required String blockchainId,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGetBlockchainHash(
          blockchainHeight: blockchainHeight,
          blockchainId: blockchainId,
          hint: hint);

  static Future<(String, Network)> getDescriptorForKeychain(
          {required String walletId,
          required KeychainKind keychain,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGetDescriptorForKeychain(
          walletId: walletId, keychain: keychain, hint: hint);

  static Future<int> getHeight({required String blockchainId, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiGetHeight(blockchainId: blockchainId, hint: hint);

  static Future<AddressInfo> getInternalAddress(
          {required String walletId,
          required AddressIndex addressIndex,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGetInternalAddress(
          walletId: walletId, addressIndex: addressIndex, hint: hint);

  /// get the corresponding PSBT Input for a LocalUtxo
  static Future<String> getPsbtInput(
          {required String walletId,
          required LocalUtxo utxo,
          required bool onlyWitnessUtxo,
          PsbtSigHashType? psbtSighashType,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGetPsbtInput(
          walletId: walletId,
          utxo: utxo,
          onlyWitnessUtxo: onlyWitnessUtxo,
          psbtSighashType: psbtSighashType,
          hint: hint);

  static Future<List<TransactionDetails>> getTransactions(
          {required String walletId, required bool includeRaw, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiGetTransactions(
          walletId: walletId, includeRaw: includeRaw, hint: hint);

  static Future<List<TxIn>> input({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiInput(tx: tx, hint: hint);

  static Future<bool> isCoinBase({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiIsCoinBase(tx: tx, hint: hint);

  static Future<bool> isExplicitlyRbf({required String tx, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiIsExplicitlyRbf(tx: tx, hint: hint);

  static Future<bool> isLockTimeEnabled({required String tx, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiIsLockTimeEnabled(tx: tx, hint: hint);

  static Future<bool> isMine(
          {required Script script, required String walletId, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiIsMine(
          script: script, walletId: walletId, hint: hint);

  static Future<String> jsonSerialize(
          {required String psbtStr, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiJsonSerialize(psbtStr: psbtStr, hint: hint);

  static Future<List<LocalUtxo>> listUnspent(
          {required String walletId, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiListUnspent(walletId: walletId, hint: hint);

  static Future<List<LocalUtxo>> listUnspentOutputs(
          {required String walletId, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiListUnspentOutputs(walletId: walletId, hint: hint);

  static Future<int> lockTime({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiLockTime(tx: tx, hint: hint);

  static Future<int> maxSatisfactionWeight(
          {required String descriptor,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiMaxSatisfactionWeight(
          descriptor: descriptor, network: network, hint: hint);

  static Future<String> newBip44Descriptor(
          {required KeychainKind keyChainKind,
          required String secretKey,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiNewBip44Descriptor(
          keyChainKind: keyChainKind,
          secretKey: secretKey,
          network: network,
          hint: hint);

  static Future<String> newBip44Public(
          {required KeychainKind keyChainKind,
          required String publicKey,
          required Network network,
          required String fingerprint,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiNewBip44Public(
          keyChainKind: keyChainKind,
          publicKey: publicKey,
          network: network,
          fingerprint: fingerprint,
          hint: hint);

  static Future<String> newBip49Descriptor(
          {required KeychainKind keyChainKind,
          required String secretKey,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiNewBip49Descriptor(
          keyChainKind: keyChainKind,
          secretKey: secretKey,
          network: network,
          hint: hint);

  static Future<String> newBip49Public(
          {required KeychainKind keyChainKind,
          required String publicKey,
          required Network network,
          required String fingerprint,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiNewBip49Public(
          keyChainKind: keyChainKind,
          publicKey: publicKey,
          network: network,
          fingerprint: fingerprint,
          hint: hint);

  static Future<String> newBip84Descriptor(
          {required KeychainKind keyChainKind,
          required String secretKey,
          required Network network,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiNewBip84Descriptor(
          keyChainKind: keyChainKind,
          secretKey: secretKey,
          network: network,
          hint: hint);

  static Future<String> newBip84Public(
          {required KeychainKind keyChainKind,
          required String publicKey,
          required Network network,
          required String fingerprint,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiNewBip84Public(
          keyChainKind: keyChainKind,
          publicKey: publicKey,
          network: network,
          fingerprint: fingerprint,
          hint: hint);

  static Future<List<TxOut>> output({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiOutput(tx: tx, hint: hint);

  static Future<int?> psbtFeeAmount({required String psbtStr, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiPsbtFeeAmount(psbtStr: psbtStr, hint: hint);

  static Future<double?> psbtFeeRate({required String psbtStr, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiPsbtFeeRate(psbtStr: psbtStr, hint: hint);

  static Future<String> psbtTxid({required String psbtStr, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiPsbtTxid(psbtStr: psbtStr, hint: hint);

  static Future<String> serializePsbt(
          {required String psbtStr, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiSerializePsbt(psbtStr: psbtStr, hint: hint);

  static Future<String?> sign(
          {required String walletId,
          required String psbtStr,
          SignOptions? signOptions,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiSign(
          walletId: walletId,
          psbtStr: psbtStr,
          signOptions: signOptions,
          hint: hint);

  static Future<int> size({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiSize(tx: tx, hint: hint);

  static Future<void> syncWallet(
          {required String walletId,
          required String blockchainId,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiSyncWallet(
          walletId: walletId, blockchainId: blockchainId, hint: hint);

  static Future<(String, TransactionDetails)> txBuilderFinish(
          {required String walletId,
          required List<ScriptAmount> recipients,
          required List<OutPoint> utxos,
          (OutPoint, String, int)? foreignUtxo,
          required List<OutPoint> unspendable,
          required ChangeSpendPolicy changePolicy,
          required bool manuallySelectedOnly,
          double? feeRate,
          int? feeAbsolute,
          required bool drainWallet,
          Script? drainTo,
          RbfValue? rbf,
          required List<int> data,
          dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiTxBuilderFinish(
          walletId: walletId,
          recipients: recipients,
          utxos: utxos,
          foreignUtxo: foreignUtxo,
          unspendable: unspendable,
          changePolicy: changePolicy,
          manuallySelectedOnly: manuallySelectedOnly,
          feeRate: feeRate,
          feeAbsolute: feeAbsolute,
          drainWallet: drainWallet,
          drainTo: drainTo,
          rbf: rbf,
          data: data,
          hint: hint);

  static Future<String> txTxid({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiTxTxid(tx: tx, hint: hint);

  static Future<int> version({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiVersion(tx: tx, hint: hint);

  static Future<int> vsize({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiVsize(tx: tx, hint: hint);

  static Future<Network> walletNetwork(
          {required String walletId, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRustApiApiWalletNetwork(walletId: walletId, hint: hint);

  static Future<int> weight({required String tx, dynamic hint}) =>
      RustLib.instance.api.crateApiRustApiApiWeight(tx: tx, hint: hint);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Api && runtimeType == other.runtimeType;
}
