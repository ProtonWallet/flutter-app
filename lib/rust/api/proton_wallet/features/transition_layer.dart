// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../proton_api/proton_address.dart';
import '../../../proton_api/proton_users.dart';
import '../../../proton_api/wallet.dart';
import '../../../proton_wallet/crypto/wallet_key.dart';
import '../../errors.dart';
import '../crypto/wallet_key.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

class FrbSenderBody {
  final String toList;
  final String sender;
  final String body;

  const FrbSenderBody({
    required this.toList,
    required this.sender,
    required this.body,
  });

  static Future<FrbSenderBody> default_() => RustLib.instance.api
      .crateApiProtonWalletFeaturesTransitionLayerFrbSenderBodyDefault();

  @override
  int get hashCode => toList.hashCode ^ sender.hashCode ^ body.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbSenderBody &&
          runtimeType == other.runtimeType &&
          toList == other.toList &&
          sender == other.sender &&
          body == other.body;
}

class FrbTLEncryptedTransactionID {
  final String encryptedTransactionId;
  final int index;

  const FrbTLEncryptedTransactionID({
    required this.encryptedTransactionId,
    required this.index,
  });

  @override
  int get hashCode => encryptedTransactionId.hashCode ^ index.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbTLEncryptedTransactionID &&
          runtimeType == other.runtimeType &&
          encryptedTransactionId == other.encryptedTransactionId &&
          index == other.index;
}

class FrbTLTransactionID {
  final String transactionId;
  final int index;

  const FrbTLTransactionID({
    required this.transactionId,
    required this.index,
  });

  @override
  int get hashCode => transactionId.hashCode ^ index.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbTLTransactionID &&
          runtimeType == other.runtimeType &&
          transactionId == other.transactionId &&
          index == other.index;
}

/// this is a transition layer for the proton wallet move business logics from Dart to rust.
/// this file will be tempary and will be removed once all the business logics are moved to rust.
class FrbTransitionLayer {
  const FrbTransitionLayer();

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<FrbSenderBody> decryptMessages(
          {required List<ProtonUserKey> userKeys,
          required List<ProtonAddressKey> addrKeys,
          required String userKeyPassword,
          String? encToList,
          String? encSender,
          String? encBody}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerDecryptMessages(
              userKeys: userKeys,
              addrKeys: addrKeys,
              userKeyPassword: userKeyPassword,
              encToList: encToList,
              encSender: encSender,
              encBody: encBody);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<String> decryptTransactionId(
          {required List<ProtonUserKey> userKeys,
          required List<ProtonAddressKey> addrKeys,
          required String userKeyPassword,
          required String encTransactionId}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerDecryptTransactionId(
              userKeys: userKeys,
              addrKeys: addrKeys,
              userKeyPassword: userKeyPassword,
              encTransactionId: encTransactionId);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<List<FrbTLTransactionID>> decryptTransactionIds(
          {required List<ProtonUserKey> userKeys,
          required List<ProtonAddressKey> addrKeys,
          required String userKeyPassword,
          required List<FrbTLEncryptedTransactionID> encTransactionIds}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerDecryptTransactionIds(
              userKeys: userKeys,
              addrKeys: addrKeys,
              userKeyPassword: userKeyPassword,
              encTransactionIds: encTransactionIds);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<FrbUnlockedWalletKey> decryptWalletKey(
          {required ApiWalletKey walletKey,
          required ProtonUserKey userKey,
          required String userKeyPassphrase}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerDecryptWalletKey(
              walletKey: walletKey,
              userKey: userKey,
              userKeyPassphrase: userKeyPassphrase);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<String> decryptWalletKeyLegacy(
          {required String encryptedMnemonicText,
          required List<ProtonUserKey> userKeys,
          required String userKeyPassword}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerDecryptWalletKeyLegacy(
              encryptedMnemonicText: encryptedMnemonicText,
              userKeys: userKeys,
              userKeyPassword: userKeyPassword);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<String> encryptMessagesWithKeys(
          {required List<String> privateKeys,
          required String message,
          List<ProtonUserKey>? userKeys,
          List<ProtonAddressKey>? addrKeys,
          String? userKeyPassword}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerEncryptMessagesWithKeys(
              privateKeys: privateKeys,
              message: message,
              userKeys: userKeys,
              addrKeys: addrKeys,
              userKeyPassword: userKeyPassword);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<String> encryptMessagesWithUserkey(
          {required ProtonUserKey userKey, required String message}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerEncryptMessagesWithUserkey(
              userKey: userKey, message: message);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<FrbLockedWalletKey> encryptWalletKey(
          {required FrbUnlockedWalletKey walletKey,
          required ProtonUserKey userKey,
          required String userKeyPassphrase}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerEncryptWalletKey(
              walletKey: walletKey,
              userKey: userKey,
              userKeyPassphrase: userKeyPassphrase);

  static String getHmacHashedString(
          {required String base64SecureKey, required String transactionId}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerGetHmacHashedString(
              base64SecureKey: base64SecureKey, transactionId: transactionId);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<String> sign(
          {required List<ProtonUserKey> userKeys,
          required ProtonAddressKey addrKeys,
          required String userKeyPassword,
          required String message,
          required String context}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerSign(
              userKeys: userKeys,
              addrKeys: addrKeys,
              userKeyPassword: userKeyPassword,
              message: message,
              context: context);

  /// Dart async + Rust sync ** handled by Frb thread pool
  static Future<bool> verifySignature(
          {required List<String> verifier,
          required String message,
          required String signature,
          required String context}) =>
      RustLib.instance.api
          .crateApiProtonWalletFeaturesTransitionLayerFrbTransitionLayerVerifySignature(
              verifier: verifier,
              message: message,
              signature: signature,
              context: context);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbTransitionLayer && runtimeType == other.runtimeType;
}
