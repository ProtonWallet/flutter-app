// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.33.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../common/errors.dart';
import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'proton_api_service.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressBalance>>
@sealed
class AddressBalance extends RustOpaque {
  AddressBalance.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AddressBalance.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AddressBalance,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AddressBalance,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AddressBalancePtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressClient>>
@sealed
class AddressClient extends RustOpaque {
  AddressClient.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AddressClient.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AddressClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AddressClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AddressClientPtr,
  );

  /// Get recent block summaries, starting at tip or height if provided
  Future<AddressBalance> getAddressBalance(
          {required String address, dynamic hint}) =>
      RustLib.instance.api.addressClientGetAddressBalance(
          that: this, address: address, hint: hint);

  /// Get a [`BlockHeader`] given a particular block hash.
  Future<List<ApiTx>> getScripthashTransactions(
          {required String scriptHash, dynamic hint}) =>
      RustLib.instance.api.addressClientGetScripthashTransactions(
          that: this, scriptHash: scriptHash, hint: hint);

  /// Get a [`BlockHeader`] given a particular block hash.
  Future<List<ApiTx>> getScripthashTransactionsAtTransactionId(
          {required String scriptHash,
          required String transactionId,
          dynamic hint}) =>
      RustLib.instance.api
          .addressClientGetScripthashTransactionsAtTransactionId(
              that: this,
              scriptHash: scriptHash,
              transactionId: transactionId,
              hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<AddressClient> newInstance(
          {required ProtonApiService service, dynamic hint}) =>
      RustLib.instance.api.addressClientNew(service: service, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiTx>>
@sealed
class ApiTx extends RustOpaque {
  ApiTx.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  ApiTx.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ApiTx,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ApiTx,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ApiTxPtr,
  );
}
